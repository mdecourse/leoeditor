<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20131223123155.1734" a="E"><vh>Speed Ream's leo2html.leo</vh>
<v t="dsr.20131205110138.1387"><vh>scripts</vh>
<v t="dsr.20131219141031.2779"><vh>@button example1</vh>
<v t="dsr.20131219235522.2808"><vh>Define classes</vh>
<v t="dsr.20131219141031.2790"><vh>class qtag</vh>
<v t="dsr.20131219141031.2793"><vh>init</vh></v>
<v t="dsr.20131219141031.2794"><vh>_open</vh></v>
<v t="dsr.20131219141031.2795"><vh>close</vh></v>
</v>
<v t="dsr.20131219141031.2781"><vh>class to_html</vh>
<v t="dsr.20131219141031.2782"><vh>init</vh></v>
<v t="dsr.20131219141031.2784"><vh>get_start_node</vh></v>
<v t="dsr.20131219141031.2786"><vh>process</vh></v>
<v t="dsr.20131219141031.2789"><vh>add_tag</vh></v>
<v t="dsr.20131219141031.2792"><vh>process_level</vh></v>
<v t="ekr.20131222175517.1719"><vh>&lt;&lt;to_html docstring&gt;&gt;</vh></v>
</v>
</v>
<v t="dsr.20131219141031.2787"><vh>doit</vh></v>
</v>
<v t="dsr.20131220200720.2837"><vh>@button example2</vh>
<v t="dsr.20131219235522.2808"></v>
<v t="dsr.20131220200720.2849"><vh>doit</vh></v>
</v>
<v t="dsr.20131220200720.2911"><vh>@button example3</vh>
<v t="dsr.20131219235522.2808"></v>
<v t="dsr.20131220200720.2923"><vh>doit</vh></v>
</v>
</v>
<v t="dsr.20131220200720.2811"><vh>Examples</vh>
<v t="dsr.20131220200720.2812"><vh>Example 1</vh>
<v t="dsr.20131220200720.2810"><vh>@html my_test</vh>
<v t="dsr.20131220200720.2813"><vh>doctype</vh></v>
<v t="dsr.20131220200720.2814"><vh>html</vh>
<v t="dsr.20131220200720.2815"><vh>head</vh>
<v t="dsr.20131220200720.2816"><vh>meta</vh></v>
<v t="dsr.20131220200720.2817"><vh>title</vh>
<v t="dsr.20131220200720.2823"><vh>content</vh></v>
</v>
</v>
<v t="dsr.20131220200720.2818"><vh>body</vh>
<v t="dsr.20131220200720.2819"><vh>div</vh>
<v t="dsr.20131220200720.2820"><vh>p</vh>
<v t="dsr.20131220200720.2821"><vh>content</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="dsr.20131220200720.2862"><vh>Example 2</vh>
<v t="dsr.20131220200720.2863"><vh>@html my_test2</vh>
<v t="dsr.20131220200720.2864"><vh>content</vh></v>
</v>
</v>
<v t="dsr.20131220200720.2886"><vh>Example 3</vh>
<v t="dsr.20131220200720.2887"><vh>@html Example 3</vh>
<v t="dsr.20131220200720.2888"><vh>doctype</vh></v>
<v t="dsr.20131220200720.2889"><vh>html</vh>
<v t="dsr.20131220200720.2890"><vh>head</vh>
<v t="dsr.20131220221447.2865"><vh>!+ Meta comment</vh></v>
<v t="dsr.20131220200720.2891"><vh>meta</vh></v>
<v t="dsr.20131220200720.2892"><vh>title</vh>
<v t="dsr.20131220200720.2893"><vh>content</vh></v>
</v>
</v>
<v t="dsr.20131220221447.2866"><vh>! body comment</vh></v>
<v t="dsr.20131220200720.2894"><vh>body</vh>
<v t="dsr.20131220200720.2925"><vh>-Clone Body Content</vh>
<v t="dsr.20131220200720.2895"><vh>div ! Headline Div</vh>
<v t="dsr.20131220200720.2896"><vh>p</vh>
<v t="dsr.20131220200720.2897"><vh>content</vh></v>
</v>
</v>
<v t="dsr.20131220221447.2860"><vh>!+ Run-on Text</vh></v>
<v t="dsr.20131220200720.2926"><vh>div ! Run-On Text</vh>
<v t="dsr.20131220200720.2929"><vh>p</vh>
<v t="dsr.20131220200720.2930"><vh>content</vh></v>
</v>
</v>
<v t="dsr.20131220200720.2931"><vh>- With Formatted Text (in html, not 
display)</vh></v>
<v t="dsr.20131220200720.2938"><vh>! Formatted Text</vh></v>
<v t="dsr.20131220200720.2935"><vh>div ! Text w/Line Feeds</vh>
<v t="dsr.20131220200720.2936"><vh>p</vh>
<v t="dsr.20131220200720.2937"><vh>+content</vh></v>
</v>
</v>
<v t="dsr.20131220221447.2861"><vh>- Lets put in a line</vh></v>
<v t="dsr.20131220221447.2862"><vh>div</vh>
<v t="dsr.20131220221447.2864"><vh>! hr comment</vh></v>
<v t="dsr.20131220221447.2863"><vh>hr</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="dsr.20131219235522.2808"></v>
<v t="ekr.20131222175517.1719"></v>
<v t="dsr.20131220200720.2810"></v>
<v t="ekr.20131222175517.1721"><vh>special headlines</vh>
<v t="ekr.20131222175517.1722"><vh>content</vh></v>
<v t="ekr.20131222175517.1723"><vh>+content (created with 
reformat-paragraph)</vh></v>
<v t="ekr.20131222175517.1724"><vh>! (anything)</vh></v>
<v t="ekr.20131222175517.1725"><vh>!+ (anything)</vh></v>
<v t="ekr.20131222175517.1726"><vh>-(anything)</vh></v>
<v t="ekr.20131222175517.1727"><vh>&lt;tag name&gt; ! comments</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="dsr.20131205110138.1387">@language python

</t>
<t tx="dsr.20131219141031.2779">ME = "example 1"
c.frame.log.setAllText("")
g.es("Starting Script: " + ME)
g.es("")
g.es("")
@others
g.es("")
g.es("")
g.es("Ending Script: " + ME)
</t>
<t tx="dsr.20131219141031.2781">class to_html(object):
    &lt;&lt;to_html docstring&gt;&gt;
    @others
</t>
<t tx="dsr.20131219141031.2782">def __init__(self, node_name, indent=" "):
    '''
    Setup instance variables
    '''
    self.data = ""
    # How many spaces for each indent
    self.indent = indent
    # If html node doesn't start at level 1, account for that.
    self.level_offset = 0
    # The name under which the html starts. Does not include the
    # @html. Example:
    # @html my_html_file.html
    # node_name = my_html_file.html
    # The node_name may be anything and may include spaces but no
    # characters that will confuse python or ascii-to-utf-8.
    self.node_name = node_name
    self.start_node = None
    self.tag_list = []
    '''
    Process the leo file into html
    '''
    assert self.get_start_node() is True
    assert self.process() is True
    return

</t>
<t tx="dsr.20131219141031.2784">def get_start_node(self):
    node_start = "@HTML"
    for ap in c.all_positions():
        item = ap.h.upper()
        if node_start in item:
            if self.node_name.upper() in item:
                self.start_node = ap.copy()
                return True
    if 0:g.es("Not found: Node name: %s" % self.node_name)
    return False

</t>
<t tx="dsr.20131219141031.2786">def process(self):
    for ap in self.start_node.subtree():
        assert self.add_tag(ap, self.indent) is True
    index = 0
    L = self.tag_list
    while index &lt; len(L):
        index = self.process_level(index)
    for index in range (len(L)-1, -1, -1):
        if not L[index].closed:
            data, ok = L[index].close()
            assert ok is True
            self.data += data
    return True
</t>
<t tx="dsr.20131219141031.2787">LEO=1
DEBUG=1
PRINTING=0
node_name="my_test"
indent = " "
h = to_html(node_name,indent=indent)
if DEBUG:
    if LEO:g.es(h.data)
    else:print(h.data)
if PRINTING:
    with open("example01.htm", "wb") as f:
        f.write(h.data)
</t>
<t tx="dsr.20131219141031.2789">def add_tag(self, node, indent):
    tag = qtag(node, indent)
    assert tag is not None
    self.tag_list.append(tag)
    return True

</t>
<t tx="dsr.20131219141031.2790">class qtag(object):
    '''
    non typical html tags 
    '''
    special_tags = [

("doctype", "alone"),

("br", "empty"),
("hr", "empty"),

("img",   "single"),
("input", "single"),
("link",  "single"),
("meta",  "single"),

("body",  "newline"),
("div",   "newline"),
("form",  "newline"),
("head",  "newline"),
("html",  "newline"),
("style", "newline"),
("ul",    "newline"),

]

    @others

</t>
<t tx="dsr.20131219141031.2792">def process_level(self, index):
    ## In all cases, output the opening of the tag
    nindex = index
    L = self.tag_list
    data, comment, ok = L[nindex]._open()
    assert ok is True
    self.data += data
    next_index = nindex + 1
    while 1:
        try:
            level = L[next_index].level
            L[next_index].comment=comment

        except:
            ## If we get here, we are at the end of the
            ## node list, so we are done
            #raise
            return next_index
    
        ## if this node has children, process the child tree
        if level &gt; L[nindex].level:
            next_index = self.process_level(next_index)
            continue

        # output closing tag
        data, ok = L[nindex].close()
        assert ok is True
        self.data += data
        return next_index
</t>
<t tx="dsr.20131219141031.2793">def __init__(self, node, indent):
    self.body = node.b
    self.closed = False
    self.comment = None
    self.end = "" # closing tag text
    self.head = node.h
    self.level = node.level() - 3
    self.indent = ""
    if self.level:
        self.indent = self.level*indent
</t>
<t tx="dsr.20131219141031.2794">def _open(self):
    body = self.body
    comment1 = None
    comment2 = None
    data = ""
    head = self.head.strip(" ")
    indent = self.indent
    
    '''
    Handle the case, we have been told to wrap outselves into an html
    comment. Create the comments now.
    '''
    if self.comment:
        comment1 = "%s&lt;!-- %s --&gt;\n" % (indent, self.comment[0])
        comment2 = " &lt;!-- /%s --&gt;\n" % self.comment[0]
        if self.comment[1]:
            comment2 = "%s%s&lt;!-- /%s --&gt;\n" % \
                       ("\n", indent, self.comment[0])

    '''
    Handle the case, this node is a comment. We need to tell the next
    node to wrap itself in a comment, and give it the text it needs.
    '''
    if head.startswith("!+"):
        comment = (head[1:].strip("+ "), True)
        return data, comment, True

    if head.startswith("!"):
        comment = (head[1:].strip(), False)
        return data, comment, True

    '''
    Strip Leo file inline comments
    '''
    if "!" in head:
        head = head.split("!")[0].strip()

    '''
    Strip Leo file whole line comments
    '''
    if head.startswith("-"):
        return "", None, True

    '''
    handle any special case tags
    '''
    for tag, _type in self.special_tags:
        if tag == head:
            body = body.replace("\n", "\n  " + indent + len(head)*" ")
            if _type == "alone":
                data = "%s%s\n" % (indent, body)
                return data, None, True
            if _type == "empty":
                data = "%s&lt;%s /&gt;\n" % (indent, head)
                if comment1:
                    data = "%s%s&lt;%s /&gt;%s" % \
                           (comment1, indent, head, comment2)
                return data, None, True
            if _type == "single":
                data = "%s&lt;%s /&gt;\n" % (indent, head)
                if len(body):
                    data = "%s&lt;%s %s/&gt;\n" % (indent, head, body)
                if comment1:
                    data = "%s%s&lt;%s %s/&gt;%s" % \
                    (comment1, indent, head, body, comment2)
                return data, None, True
            if _type == "newline":
                data = "%s&lt;%s&gt;\n" % (indent, head)
                if comment1:
                    data = "%s%s&lt;%s&gt;\n" % (comment1, indent, head)
                if len(body):
                    data = "%s&lt;%s %s&gt;\n" % (indent, head, body)
                    if comment1:
                        data = "%s%s&lt;%s %s&gt;\n" % \
                               (comment1, indent, head, body)
                self.end = "%s&lt;/%s&gt;\n" % (indent, head)
                if comment2:
                    self.end = "%s&lt;/%s&gt;%s" % (indent, head, comment2)
                return data, None, True
            return "", None, False

    '''
    Handle contents
    '''
    if head == "content":
        data = "%s" % (body)
        return data, None, True
    if head == "+content":
        body = body.replace("\n", "\n" + indent)
        data = "%s" % (body)
        return data, None, True

    '''
    Handle normal tags
    '''
    body = body.replace("\n", "\n  " + indent + len(head)*" ")
    data = "%s&lt;%s&gt;" % (indent, head)
    if comment1:
        data = "%s%s&lt;%s %s&gt;" % (comment1, indent, head, body)
    if len(body):
        data = "%s&lt;%s %s&gt;" % (indent, head, body)
        if comment1:
            data = "%s%s&lt;%s %s&gt;" % (comment1, indent, head, body)
    self.end = "&lt;/%s&gt;\n" % (head)
    if comment2:
        self.end = "&lt;/%s&gt;%s" % (head, comment2)
    return data, None, True
</t>
<t tx="dsr.20131219141031.2795">def close(self):
    self.closed = True
    return self.end, True
</t>
<t tx="dsr.20131219235522.2808">@others
</t>
<t tx="dsr.20131220200720.2810"></t>
<t tx="dsr.20131220200720.2811">@language html</t>
<t tx="dsr.20131220200720.2812"></t>
<t tx="dsr.20131220200720.2813">&lt;!doctype html&gt;</t>
<t tx="dsr.20131220200720.2814">xmlns="http://www.w3.org/1999/xhtml"</t>
<t tx="dsr.20131220200720.2815"></t>
<t tx="dsr.20131220200720.2816">content="text/html; charset=utf-8" 
http-equiv="Content-Type"</t>
<t tx="dsr.20131220200720.2817"></t>
<t tx="dsr.20131220200720.2818"></t>
<t tx="dsr.20131220200720.2819"></t>
<t tx="dsr.20131220200720.2820"></t>
<t tx="dsr.20131220200720.2821">Hello World</t>
<t tx="dsr.20131220200720.2823">My Test Html Document (From Leo)</t>
<t tx="dsr.20131220200720.2837">ME = "example 2"
c.frame.log.setAllText("")
g.es("Starting Script: " + ME)
g.es("")
g.es("")
@others
g.es("")
g.es("")
g.es("Ending Script: " + ME)
</t>
<t tx="dsr.20131220200720.2849">LEO=1
DEBUG=1
PRINTING=0
node_name="my_test2"
indent = " "
h = to_html(node_name,indent=indent)
if DEBUG:
    if LEO:g.es(h.data)
    else:print(h.data)
if PRINTING:
    with open("example02.htm", "wb") as f:
        f.write(h.data)
</t>
<t tx="dsr.20131220200720.2862"></t>
<t tx="dsr.20131220200720.2863"></t>
<t tx="dsr.20131220200720.2864">&lt;!doctype html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
 &lt;head&gt;
  &lt;meta content="text/html; charset=utf-8" http-equiv="Content-Type"/&gt;
  &lt;title&gt;My Test Html Document (From Leo)&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;Hello World&lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;</t>
<t tx="dsr.20131220200720.2886"></t>
<t tx="dsr.20131220200720.2887"></t>
<t tx="dsr.20131220200720.2888">&lt;!doctype html&gt;</t>
<t tx="dsr.20131220200720.2889">xmlns="http://www.w3.org/1999/xhtml"</t>
<t tx="dsr.20131220200720.2890"></t>
<t tx="dsr.20131220200720.2891">content="text/html; charset=utf-8" 
http-equiv="Content-Type"</t>
<t tx="dsr.20131220200720.2892"></t>
<t tx="dsr.20131220200720.2893">My Test Html Document (From Leo)</t>
<t tx="dsr.20131220200720.2894">style="margin:0 
auto;text-align:center;font-family:Verdana,Arial,sans-serif;"</t>
<t tx="dsr.20131220200720.2895"></t>
<t tx="dsr.20131220200720.2896"></t>
<t tx="dsr.20131220200720.2897">This is the greatest html document in the 
world!</t>
<t tx="dsr.20131220200720.2911">ME = "example 3"
c.frame.log.setAllText("")
g.es("Starting Script: " + ME)
g.es("")
g.es("")
@others
g.es("")
g.es("")
g.es("Ending Script: " + ME)
</t>
<t tx="dsr.20131220200720.2923">LEO=1
DEBUG=1
PRINTING=1
node_name="Example 3"
indent = " "
h = to_html(node_name,indent=indent)
if DEBUG:
    if LEO:g.es(h.data)
    else:print(h.data)
if PRINTING:
    with open("example03.htm", "wb") as f:
        f.write(h.data)
</t>
<t tx="dsr.20131220200720.2925"></t>
<t tx="dsr.20131220200720.2926">style="margin:0 
auto;text-align:center;width:300px;"</t>
<t tx="dsr.20131220200720.2929"></t>
<t tx="dsr.20131220200720.2930">Volutpat at varius sed sollicitudin et, 
arcu. Vivamus viverra. Nullam turpis. Vestibulum sed etiam. Lorem ipsum sit 
amet dolore. Nulla facilisi. Sed tortor. Aenean felis. Quisque eros. Cras 
lobortis commodo metus. Vestibulum vel purus. In eget odio in sapien 
adipiscing blandit. Quisque augue tortor, facilisis sit amet, aliquam, 
suscipit vitae, cursus sed, arcu lorem ipsum dolor sit amet.

Fermentum at, varius pretium, elit. Mauris egestas scelerisque nunc. Mauris 
non ligula quis wisi laoreet malesuada. In commodo. Maecenas lobortis 
cursus dolor.</t>
<t tx="dsr.20131220200720.2931"></t>
<t tx="dsr.20131220200720.2935">style="margin:0 
auto;text-align:center;width:300px;"</t>
<t tx="dsr.20131220200720.2936"></t>
<t tx="dsr.20131220200720.2937">
Volutpat at varius sed sollicitudin et, arcu.
Vivamus viverra.
Nullam turpis. Vestibulum sed etiam.
Lorem ipsum sit amet dolore. Nulla facilisi. Sed tortor. Aenean felis. 
Quisque eros. Cras lobortis commodo metus. Vestibulum vel purus.
In eget odio in sapien adipiscing blandit.

Quisque augue tortor, facilisis sit amet, aliquam, suscipit vitae,
cursus sed, arcu lorem ipsum dolor sit amet.

Fermentum at, varius pretium, elit. Mauris egestas scelerisque nunc.
Mauris non ligula quis wisi laoreet malesuada. In commodo.
Maecenas lobortis cursus dolor.</t>
<t tx="dsr.20131220200720.2938"></t>
<t tx="dsr.20131220221447.2860"></t>
<t tx="dsr.20131220221447.2861"></t>
<t tx="dsr.20131220221447.2862">id="horizontal-line"
class="looks-good"
style="margin:0 auto;
       text-align:center;"</t>
<t tx="dsr.20131220221447.2863"></t>
<t tx="dsr.20131220221447.2864"></t>
<t tx="dsr.20131220221447.2865"></t>
<t tx="dsr.20131220221447.2866"></t>
<t tx="ekr.20131222175517.1719">@nocolor-node
'''
~~~~~~~~~~~~~~~~~~~~~~

What is Leo2Html?

Leo2Html consists of two parts.

Part 1: A Leo file written with a certain syntax.
Part 2: A python module (leo2html.py) that reads the source outline and
    generates an html file.

If you are lucky and are reading these comments within a Leo file, then
both Part 1 and Part 2 are contained within a single Leo file.

If you are even luckier, you have three script buttons within the Leo file.
The "build" button turns the Leo file into a final html file.
The "ftp" button ftps the file to its intended destination.
The "both" does a build and then an ftp with one command.

~~~~~~~~~~~~~~~~~~~~~~

Why Use Leo2Html?

I use Leo2Html because I want several things:

1. I want to write HTML from scratch using the HTML language. For many
   projects, I don't need or want an HTML editor (I have several good
   ones to choose from.) I can write the code faster by just writing it.
2. I want my code to always match every open tag with a closing tag (for
   those tags which have closing tags.)
3. I want my code to automatically indent in a sensible way when the
   final code is generated in order to make it easier to read.
4. I want my code to automatically insert optional comments when tags
   start and stop.
5. I want to write my code in Leo because of its outlining capability
   and ease of scripting from outside python modules. Almost all code I
   write (python, c++) is from within Leo already, so using
   Leo to format HTML seems like a logical time-saving solution.
6. The existing Leo-to-Html solutions don't provide the solution set I
   was looking for.

~~~~~~~~~~~~~~~~~~~~~~

What is the Syntax for the Source Outline?

An html file is represented by beginning any node in a Leo file with the
character sequence:

@html &lt;some identifier&gt;

All the children of that node (actually, the entire sub-tree below the
starting node) will be processed by the to_leo python class into an html
file.

The Leo file that contains the @html node may contain any other content,
and may contain an unlimited number of @html nodes.

@html nodes may be cloned, moved or copied just like any other node.

If more that one headline has exactly the same @html text,
ie: "@html my_test", then the first node encounted in a top-to-bottom
traversal of the file will be processed.

~~~~~~~~~~~~~~~~~~~~~~

Example 1:
    
1. I have a Leo file with:
    A. A script button named @build.
    B. The @ script button contains the classes to_html and qtag.
    C. Below the classes is the following python code:

    node_name="my_test"
    indent = " "
    h = to_html(node_name,indent=indent)
    if DEBUG:
        if LEO:g.es(h.data)
        else:print(h.data)
    
2, In the same leo file, anywhere in the file, is a subtree starting
   with:
        @html my_test

3. The content of the @html my_test tree is:

headline text                    |  body text
------------------------------------------------------------------------

@html my_test                    |  
  doctype                        |&lt;!doctype html&gt;
  html                           |xmlns="http://www.w3.org/1999/xhtml"
    head                         |
      meta                       |content="text/html;
                                 |charset=utf-8"
                                 |http-equiv="Content-Type"
      title                      |
        content                  |My Test Html Document (From Leo)
    body                         |
      div                        |
        p                        |
          content                |Hello World
------------------------------------------------------------------------

3. The content of the resulting html code is:

&lt;!doctype html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
 &lt;head&gt;
  &lt;meta content="text/html; charset=utf-8" http-equiv="Content-Type"/&gt;
  &lt;title&gt;My Test Html Document (From Leo)&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;Hello World&lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;

~~~~~~~~~~~~~~~~~~~~~~

When processing a node with a headline text starting with @html, none of
the siblings or parents of the @html node will be processed.

During the processing of the @html tree, the basic idea is that each Leo
headline is either:
    A. An HTML tag or
    B. A 'special' headline.

Each Leo body pane is either:
    A. Some in-line HTML content or
    B. Attributes to be contained inside the opening of an HTML tag.

The 'special' Leo headline 'content' is always copied straight to the
final HTML document with no processing.

~~~~~~~~~~~~~~~~~~~~~~

Example 2:

One could therefore write the entire html file shown in Example 1 like
this: (all the text is in one single body pane.)

headline text |  body text
------------------------------------------------------------------------

@html my_test2 |  
  content      |&lt;!doctype html&gt;
               |&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
               | &lt;head&gt;
               |  &lt;meta content="text/html; charset=utf-8" 
http-equiv="Content-Type"/&gt;
               |  &lt;title&gt;My Test Html Document (From 
Leo)&lt;/title&gt;
               | &lt;/head&gt;
               | &lt;body&gt;
               |  &lt;div&gt;
               |   &lt;p&gt;Hello World&lt;/p&gt;
               |  &lt;/div&gt;
               | &lt;/body&gt;
               |&lt;/html&gt;
------------------------------------------------------------------------

When I manually import an existing html file into Leo, the above is often
how I start the process to convert the file to an @html node.

~~~~~~~~~~~~~~~~~~~~~~

When Leo2Html processes a Leo outline, it traverses the Leo file from
the top down. All headlines are ignored until a headline is encountered
that starts with '@html'. This headline is examined to determinine if it
contains the "node_name". Both examinations are case insensitive.

If the @html node matches, the first child of that node starts a tree
that will be processed into an html file.

~~~~~~~~~~~~~~~~~~~~~~

What are the 'special' headlines?

@html
    explained above

content
    This is where the actual data of the file is inserted. Can be used
    almost anywhere. The data is not formated at all. As an example, to
    place content within a &lt;p&gt; tag, one must add a headline
    containing the single character p, then add a child node named
    'content' and place the content of the paragraph there.
    If one places text in the body pane of the node containing the
    single character p, this text will appear in opening tag of the
    paragraph tag.
    
    To get:
        
    &lt;p class="Title"&gt;This is My Title&lt;/p&gt;
    
    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    p              |class="Title"
      content      |This is My Title
    ------------------------------------------------------------------------

+content
    Data is inserted as a series of lines. Each line is preceeded by the
    current line indentation. The data within the body pane must contain
    new-line characters for this to work. The new-line characters are
    platform specific, but this is handled automatically by python in
    many cases.

    To get:

    &lt;p style="text-align:center;margin:0 auto;"&gt;
      Hi Joe,
      How is it hanging?
      Talk with you later.
    &lt;/p&gt;

    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    p              |style="text-align:center;margin:0 auto;"
      +content     |
                   |Hi Joe,
                   |How is it hanging?
                   |Talk with you later.
                   |
    ------------------------------------------------------------------------

! (anything)
    The contents of this headline are added as an HTML comment in the
    HTML file. A closing comment is added when the comment's first
    sibling node goes out of scope.

    To get:

    &lt;!-- Headline --&gt;
    &lt;div class="headline"&gt;
      &lt;p&gt;This is the greatest site in the world&lt;/p&gt;
    &lt;/div&gt; &lt;!-- /Headline --&gt;

    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    ! Headline     |
    div            |class="headline"
      p            |
        content    |This is the greatest site in the world.
    ------------------------------------------------------------------------

    NOTE: Do not try to put a ! or !+ comment around a 'content' node.
    Such a comment will be ignored.
    
    You may place regular html comment inside a 'content' node.

!+ (anything)
    Same as ! (anything) except you get:

    &lt;!-- Headline --&gt;
    &lt;div class="headline"&gt;
      &lt;p&gt;This is the greatest site in the world&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- /Headline --&gt;

-(anything)
    A comment in the LEO file, for clarity to the LEO coder. All the
    data in the headline and body text (if any) is ignored by the HTML
    generator.

&lt;tag name&gt; ! comments
    A comment in the LEO file, for clarity to the LEO coder. The tag
    name is processed as normal. Everything from the '!' on is ignored,
    including the "!"

    To Get:
    
    &lt;p&gt;Hello World&lt;/p&gt;
    
    One writes in the Leo file:

    headline text                         |  body text
    ------------------------------------------------------------------------
    p ! This is my hello world paragraph  |
      content                             |Hello World
    ------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~

Example 3:

If you have the Leo file for Leo2Html, example 3 gives at least one
example of each formatting tool or situation.

I use example 3 as a sanity-check unit test for the module.

'''</t>
<t tx="ekr.20131222175517.1721">@nocolor

This is a copy of the to_html docstring, reformatted into separate nodes.

What are the 'special' headlines?

@html
    explained above
</t>
<t tx="ekr.20131222175517.1722">content

    This is where the actual data of the file is inserted. Can be used
    almost anywhere. The data is not formated at all.
    
    As an example, to place content within a &lt;p&gt; tag, one must add a
    headline containing the single character p, then add a child node named
    'content' and place the content of the paragraph there.
    
    If one places text in the body pane of the node containing the single
    character p, this text will appear in opening tag of the paragraph tag.
    
    To get:
        
    &lt;p class="Title"&gt;This is My Title&lt;/p&gt;
    
    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    p              |class="Title"
      content      |This is My Title
    ------------------------------------------------------------------------
</t>
<t tx="ekr.20131222175517.1723">+content

    Data is inserted as a series of lines. Each line is preceeded by the
    current line indentation. The data within the body pane must contain
    new-line characters for this to work. The new-line characters are
    platform specific, but this is handled automatically by python in
    many cases.

    To get:

    &lt;p style="text-align:center;margin:0 auto;"&gt;
      Hi Joe,
      How is it hanging?
      Talk with you later.
    &lt;/p&gt;

    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    p              |style="text-align:center;margin:0 auto;"
      +content     |
                   |Hi Joe,
                   |How is it hanging?
                   |Talk with you later.
                   |
    ------------------------------------------------------------------------
</t>
<t tx="ekr.20131222175517.1724">! (anything)

    The contents of this headline are added as an HTML comment in the
    HTML file. A closing comment is added when the comment's first
    sibling node goes out of scope.

    To get:

    &lt;!-- Headline --&gt;
    &lt;div class="headline"&gt;
      &lt;p&gt;This is the greatest site in the world&lt;/p&gt;
    &lt;/div&gt; &lt;!-- /Headline --&gt;

    One writes in the Leo file:

    headline text  |  body text
    ------------------------------------------------------------------------
    ! Headline     |
    div            |class="headline"
      p            |
        content    |This is the greatest site in the world.
    ------------------------------------------------------------------------

    NOTE: Do not try to put a ! or !+ comment around a 'content' node.
    Such a comment will be ignored.
    
    You may place regular html comment inside a 'content' node.
</t>
<t tx="ekr.20131222175517.1725">!+ (anything)

    Same as ! (anything) except you get:

    &lt;!-- Headline --&gt;
    &lt;div class="headline"&gt;
      &lt;p&gt;This is the greatest site in the world&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- /Headline --&gt;
</t>
<t tx="ekr.20131222175517.1726">-(anything)

    A comment in the LEO file, for clarity to the LEO coder. All the
    data in the headline and body text (if any) is ignored by the HTML
    generator.
</t>
<t tx="ekr.20131222175517.1727">&lt;tag name&gt; ! comments

    A comment in the LEO file, for clarity to the LEO coder. The tag
    name is processed as normal. Everything from the '!' on is ignored,
    including the "!"

    To Get:
    
    &lt;p&gt;Hello World&lt;/p&gt;
    
    One writes in the Leo file:

    headline text                         |  body text
    ------------------------------------------------------------------------
    p ! This is my hello world paragraph  |
      content                             |Hello World
    ------------------------------------------------------------------------
</t>
<t tx="ekr.20131223123155.1734"></t>
</tnodes>
</leo_file>
