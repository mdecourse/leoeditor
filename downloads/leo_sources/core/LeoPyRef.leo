<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons &amp; commands</vh>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20201018062305.1"><vh>@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018063747.1"><vh>get_content</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
</v>
<v t="ekr.20210113054702.1"><vh>@command pwd</vh></v>
<v t="ekr.20201013034659.1"><vh>Unused buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
</v>
<v t="ekr.20201013034742.1"><vh>Unused buttons re plugins</vh>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20201013034742.14"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20201013034742.15"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20201013034742.25"><vh>@@button test-jup-export</vh></v>
<v t="ekr.20201013034742.26"><vh>@@button test-jup-import</vh></v>
</v>
</v>
<v t="ekr.20210110092457.1"><vh>leojs buttons</vh>
<v t="ekr.20210110092457.5"><vh>@@@button cov @key=ctrl-6</vh></v>
<v t="ekr.20210110092457.6"><vh>@@@button moz @key=ctrl-7</vh></v>
<v t="ekr.20210110092457.7"><vh>@@@button unit</vh></v>
</v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 90</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.1"><vh>@data:@auto leo_cloud.py</vh>
<v t="ekr.20210501094953.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.3"><vh>@data:@auto leo_cloud_server.py</vh>
<v t="ekr.20210501094953.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20201222095250.1"><vh>script: check for duplicate settings in theme files</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20210309083845.1"><vh>script: check-files</vh></v>
<v t="ekr.20210118013157.1"><vh>script: convert-LeoFind</vh>
<v t="ekr.20210118024739.1"><vh>convert</vh></v>
<v t="ekr.20210118013807.1"><vh>main</vh></v>
<v t="ekr.20210118020530.1"><vh>new_name</vh></v>
<v t="ekr.20210118021337.1"><vh>exists</vh></v>
</v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20201208114843.1"><vh>script: diff-pr</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d7100285806000000302e31362e3071017d71025808000000616e6e6f7461746571037d7104735806000000302e31372e3071057d710668037d7107735806000000302e31392e3171087d710968037d710a735806000000302e32302e31710b7d710c68037d710d73752e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20190515070742.1"><vh>@file leoMarkup.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@@file leoQt.py</vh></v>
<v t="ekr.20210407010904.1"><vh>@@file leoQt4.py</vh></v>
<v t="ekr.20210407010914.1"><vh>@@file leoQt5.py</vh></v>
<v t="ekr.20210407011013.1"><vh>@@file leoQt6.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040236.1"><vh>@file ../commands/searchCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file ../plugins/trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
<v t="ekr.20210329114352.1"><vh>@file ../plugins/example_rst_filter.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file ../plugins/settings_finder.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file ../plugins/viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file ../plugins/leoflexx_js.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file ../plugins/importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file ../plugins/importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file ../plugins/importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="ekr.20181028052650.1"><vh>@file ../plugins/leowapp.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20190805022257.1"><vh>Unused: @file ../plugins/file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init (pyzo_file_browser)</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
<v t="ekr.20210223152423.1"><vh>@edit ../plugins/anki.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit ../plugins/QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file ../plugins/writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file ../plugins/writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707" descendentVnodeUnknownAttributes="7d71005809000000302e312e322e322e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d323971077573732e"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh></v>
<v t="ekr.20210302164046.1"><vh>@edit ../../launchLeo.py</vh></v>
<v t="ekr.20210202110241.1"><vh>@file ../../leoclient.py</vh></v>
<v t="ekr.20210202110128.1"><vh>@file ../../leoserver.py</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20180628055640.1"><vh>@file ../external/pdb_listener.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20210223151922.1"><vh>@edit ../modes/julia.py</vh></v>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt; (forth.py)</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt; (forth.py)</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt; (forth.py)</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
<v t="ekr.20210219115553.109"><vh>@edit ../modes/python.py</vh></v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
<v t="ekr.20201129023817.1"><vh>@file leoTest2.py</vh></v>
<v t="ekr.20201202144529.1"><vh>leo/unittests</vh>
<v t="ekr.20201202144422.1"><vh>@file ../unittests/commands/test_editCommands.py</vh></v>
<v t="ekr.20201203042030.1"><vh>@file ../unittests/core/test_leoNodes.py</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517080049.10">def launchExplorer(self,event=None):

    global pathToExplorer

    d = self._getCurrentNodePath()
    os.spawnl(os.P_NOWAIT,pathToExplorer, ' ', d)

</t>
<t tx="EKR.20040517080049.11">def launchxTerm(self,event=None):

    d = self._getCurrentNodePath()
    curdir = os.getcwd()
    os.chdir(d)
    os.spawnlp(os.P_NOWAIT, 'xterm', '-title Leo')
    os.chdir(curdir)
</t>
<t tx="EKR.20040517080049.6">def load_menu (self):

    c = self.c
    if sys.platform == "win32":
        table = (
            ("&amp;Open Console Window",None,self.launchCmd),
            ("Open &amp;Explorer",None,self.launchExplorer))
    else:
        table = (("Open &amp;xterm",None,self.launchxTerm),)
    c.frame.menu.createNewMenu("E&amp;xtensions","top")
    c.frame.menu.createMenuItemsFromTable("Extensions", table)
</t>
<t tx="EKR.20040517080049.7">def _getpath (self,p):

    c = self.c
    dict = c.scanAllDirectives(p)
    d = dict.get("path")
    if p.isAnyAtFileNode():
        filename = p.anyAtFileNodeName()
        filename = g.os_path_join(d,filename)
        if filename:
            d = g.os_path_dirname(filename)
    return '' if d is None else g.os_path_normpath(d)
</t>
<t tx="EKR.20040517080049.8">def _getCurrentNodePath(self):

    c = self.c
    p = c.p
    d = self._getpath(p)
    return d
</t>
<t tx="EKR.20040517080049.9">def launchCmd(self,event=None):

    global pathToCmd

    d = self._getCurrentNodePath()
    myCmd = 'cd ' + d
    os.spawnl(os.P_NOWAIT, pathToCmd, '/k ', myCmd)
</t>
<t tx="EKR.20040517080250.10">class nodeNotFound(Exception):
    pass
</t>
<t tx="EKR.20040517080250.20">class leo_interface:
    # pylint: disable=no-member
        # .path, .send_error, .send_response and .end_headers
        # appear to be undefined.
    @others
</t>
<t tx="EKR.20040517080250.21">def add_leo_links(self, window, node, f):
    """
    Given a node 'node', add links to:
        The next sibling, if any.
        the next node.
        the parent.
        The children, if any.
    """
    # Collecting the navigational links.
    if node:
        nodename = node.h
        threadNext = node.threadNext()
        sibling = node.next()
        parent = node.parent()
        f.write("&lt;p&gt;\n")
        children = []
        firstChild = node.firstChild()
        if firstChild:
            child = firstChild
            while child:
                children.append(child)
                child = child.next()
        if threadNext is not None:
            self.create_leo_reference(window, threadNext, "next", f)
        f.write("&lt;br /&gt;")
        if sibling is not None:
            self.create_leo_reference(window, sibling, "next Sibling", f)
        f.write("&lt;br /&gt;")
        if parent is None:
            self.create_href("/", "Top level", f)
        else:
            self.create_leo_reference(window, parent, "Up", f)
        f.write("&lt;br /&gt;")
        f.write("\n&lt;/p&gt;\n")
    else:
        # top level
        child = window.c.rootPosition()
        children = [child]
        next = child.next()
        while next:
            child = next
            children.append(child)
            next = child.next()
        nodename = window.shortFileName()
    if children:
        f.write("\n&lt;h2&gt;")
        f.write("Children of ")
        f.write(escape(nodename))
        f.write("&lt;/h2&gt;\n")
        f.write("&lt;ol&gt;\n")
        for child in children:
            f.write("&lt;li&gt;\n")
            self.create_leo_reference(window, child, child.h, f)
            f.write("&lt;/li&gt;\n")
        f.write("&lt;/ol&gt;\n")
</t>
<t tx="EKR.20040517080250.22">def create_href(self, href, text, f):
    f.write('&lt;a href="%s"&gt;' % href)
    f.write(escape(text))
    f.write("&lt;/a&gt;\n")
</t>
<t tx="EKR.20040517080250.23">def create_leo_reference(self, window, node, text, f):
    """
    Create a reference to 'node' in 'window', displaying 'text'
    """
    href = self.create_leo_h_reference(window, node)
    self.create_href(href, text, f)
</t>
<t tx="EKR.20040517080250.26">def find_window_and_root(self, path):
    """
    given a path of the form:
        [&lt;short filename&gt;,&lt;number1&gt;,&lt;number2&gt;...&lt;numbern&gt;]
        identify the leo node which is in that file, and,
        from top to bottom, is the &lt;number1&gt; child of the topmost
        node, the &lt;number2&gt; child of that node, and so on.

        Return None if that node can not be identified that way.
    """
    for w in g.app.windowList:
        if w.shortFileName() == path[0]:
            return w, w.c.rootPosition()
    return None, None
</t>
<t tx="EKR.20040517080250.27">def write_leo_windowlist(self):
    f = StringIO()
    f.write('''&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;
    &lt;style&gt;%s&lt;/style&gt;
    &lt;style&gt;%s&lt;/style&gt;
    &lt;title&gt;ROOT for LEO HTTP plugin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Windowlist&lt;/h1&gt;
    &lt;hr /&gt;
    &lt;ul&gt;
''' % (
    getData('http_stylesheet'),
    getData('user_http_stylesheet'),
))
    a = g.app # get the singleton application instance.
    windows = a.windowList # get the list of all open frames.
    for w in windows:
        shortfilename = w.shortFileName()
        f.write('&lt;li&gt;&lt;a href="%s"&gt;"file name: %s"&lt;/a&gt;&lt;/li&gt;' % (
            shortfilename, shortfilename))
    f.write('&lt;/ul&gt;&lt;hr /&gt;&lt;/body&gt;&lt;/html&gt;')
    return f
</t>
<t tx="EKR.20040517080250.28">def write_path(self, node, f):
    result = []
    while node:
        result.append(node.h)
        node = node.parent()
    result.reverse()
    if result:
        result2 = result[: -1]
        if result2:
            result2 = ' / '.join(result2)
            f.write("&lt;p&gt;\n")
            f.write("&lt;br /&gt;\n")
            f.write(escape(result2))
            f.write("&lt;br /&gt;\n")
            f.write("&lt;/p&gt;\n")
        f.write("&lt;h2&gt;")
        f.write(escape(result[-1]))
        f.write("&lt;/h2&gt;\n")
</t>
<t tx="EKR.20040517080250.30">def split_leo_path(self, path):
    '''Split self.path.'''
    if path == '/':
        return '/'
    if path.startswith("/"):
        path = path[1:]
    return path.split('/')
</t>
<t tx="EKR.20040517080250.4">class delayedSocketStream(asyncore.dispatcher_with_send):
    @others
</t>
<t tx="EKR.20040517080250.5">def __init__(self, sock):
    # pylint: disable=super-init-not-called
    self._map = asyncore.socket_map
    self.socket = sock
    self.socket.setblocking(0)
    self.closed = 1 # compatibility with SocketServer
    self.buffer = []
</t>
<t tx="EKR.20040517080250.6">def write(self, data):
    self.buffer.append(data)
</t>
<t tx="EKR.20040517080250.7">def initiate_sending(self):
    # Create a bytes string.
    aList = [g.toEncodedString(z) for z in self.buffer]
    self.out_buffer = b''.join(aList)
    del self.buffer
    self.set_socket(self.socket, None)
    self.socket.setblocking(0)
    self.connected = 1
    try:
        self.addr = self.socket.getpeername()
    except socket.error:
        # The addr isn't crucial
        pass
</t>
<t tx="EKR.20040517080250.8">def handle_read(self):
    pass
</t>
<t tx="EKR.20040517080250.9">def writable(self):
    result = (not self.connected) or len(self.out_buffer)
    if not result:
        sockets_to_close.append(self)
    return result
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="EKR.20040610094819"># Visible externally so plugins may add to the list of directives.
globalDirectiveList = [
    # Order does not matter.
    'all',
    'beautify',
    'colorcache', 'code', 'color', 'comment', 'c',
    'delims', 'doc',
    'encoding', 'end_raw',
    'first', 'header', 'ignore',
    'killbeautify', 'killcolor',
    'language', 'last', 'lineending',
    'markup',
    'nobeautify',
    'nocolor-node', 'nocolor', 'noheader', 'nowrap',
    'nopyflakes',  # Leo 6.1.
    'nosearch',  # Leo 5.3.
    'others', 'pagewidth', 'path', 'quiet',
    'raw', 'root-code', 'root-doc', 'root', 'silent',
    'tabwidth', 'terse',
    'unit', 'verbose', 'wrap',
]

directives_pat = None  # Set below.
</t>
<t tx="EKR.20040614071102.1">def getScript(c, p,
    useSelectedText=True,
    forcePythonSentinels=True,
    useSentinels=True,
):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p: p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s, c.tab_width)
        s = g.extractExecutableString(c, p, s)
        script = g.composeScript(c, p, s,
                    forcePythonSentinels=forcePythonSentinels,
                    useSentinels=useSentinels)
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''
    return script
</t>
<t tx="TomP.20200329223820.10">def set_group_action(label, kind):
    """Coordinates the menu's checked state.

    The triggered function sets the value of the self.default_kind variable.

    ARGUMENTS
    label -- a string containing the display label for the action.
    kind -- the kind of structure to be used by default (e.g., 'rst',
            'md', 'text')

    RETURNS
    nothing.
    """

    _action = QtWidgets.QAction(label, self, checkable=True)
    _action.triggered.connect(lambda: set_default_kind(kind))
    group.addAction(_action)
    menu.addAction(_action)
</t>
<t tx="TomP.20200329223820.11">def set_menu_var(menu_var_name, action):
    """Update an QAction's linked variable's value.

    ARGUMENTS
    menu_var_name -- the name of the instance variable that holds this action's
                     isChecked() value.
    action -- the QAction.

    RETURNS
    nothing
    """

    setattr(self, menu_var_name, action.isChecked())
    self.c.k.simulateCommand('vr3-update')
</t>
<t tx="TomP.20200329223820.12">def set_tree_lock(checked):
    self.lock_to_tree = checked
    self.current_tree_root = self.c.p if checked else None
</t>
<t tx="TomP.20200329223820.13">menu = QtWidgets.QMenu()
set_action("Entire Tree", 'show_whole_tree')
_action = QtWidgets.QAction('Lock to Tree Root', self, checkable=True)
_action.triggered.connect(lambda checked: set_tree_lock(checked))
menu.addAction(_action)

_action = QtWidgets.QAction('Freeze', self, checkable=True)
_action.triggered.connect(lambda checked: set_freeze(checked))
menu.addAction(_action)

set_action("Code Only", 'code_only')
_options_button.setMenu(menu)

menu = QtWidgets.QMenu()
group = QtWidgets.QActionGroup(self)
set_group_action('RsT', RST)
set_group_action('MD', MD)
set_group_action('Text', TEXT)
set_group_action('Asciidoc', ASCIIDOC)
_default_type_button.setMenu(menu)
</t>
<t tx="TomP.20200329223820.14">_export_button = QtWidgets.QPushButton("Export")
_export_button.setDefault(True)
_export_button.clicked.connect(lambda: c.k.simulateCommand('vr3-export-rst-html'))
_toolbar.addWidget(_export_button)

_reload_button = QtWidgets.QPushButton("Reload")
_reload_button.setDefault(True)
_reload_button.clicked.connect(lambda: c.k.simulateCommand('vr3-update'))
_toolbar.addWidget(_reload_button)

_execute_button = QtWidgets.QPushButton('Execute')
_execute_button.setDefault(True)
_execute_button.clicked.connect(lambda: c.k.simulateCommand('vr3-execute'))
_toolbar.addWidget(_execute_button)

self.layout().setMenuBar(_toolbar)
self.vr3_toolbar = _toolbar
</t>
<t tx="TomP.20200329223820.6">def create_toolbar(self):
    """Create toolbar and attach to the VR3 widget.

    Child widgets can be found using the findChild() method with the
    name of the child widget.  E.g.,

    label = self.findChild(QtWidgets.QLabel, 'vr3-toolbar-label')

    Note that "self" refers to the enclosing viewrendered3 instance.

    NAMES CREATED
    'vr3-toolbar-label' -- the toolbar label.
    """
    # pylint: disable=unnecessary-lambda

    # Ref: https://forum.qt.io/topic/52022/solved-how-can-i-add-a-toolbar-for-a-qwidget-not-qmainwindow
    # Ref: https://stackoverflow.com/questions/51459331/pyqt5-how-to-add-actions-menu-in-a-toolbar

    c = self.c
    _toolbar = QtWidgets.QToolBar('Menus')
    _options_button = QtWidgets.QPushButton("View Options")
    _options_button.setDefault(True)
    _toolbar.addWidget(_options_button)

    _default_type_button = QtWidgets.QPushButton("Default Kind")
    _toolbar.addWidget(_default_type_button)

    @others  # functions.
    &lt;&lt; vr3: create menus &gt;&gt;
    &lt;&lt; vr3: finish toolbar &gt;&gt;
</t>
<t tx="TomP.20200329223820.7">def set_action(label, menu_var_name):
    """Add a QAction to a QT menu.

    ARGUMENTS
    label -- a string containing the display label for the action.
    menu_var_name -- the name of the instance variable that holds this action's
                     isChecked() value.  For example, if the menu_var_name
                     is 'code_only', then a variable self.code_only will be
                     created, and updated if the action's isChecked status
                     is changed.

                     Note that "self" refers to the enclosing viewrendered3 instance.

    RETURNS
    nothing
    """

    setattr(self, menu_var_name, False)
    _action = QtWidgets.QAction(label, self, checkable=True)
    _action.triggered.connect(lambda: set_menu_var(menu_var_name, _action))
    menu.addAction(_action)
</t>
<t tx="TomP.20200329223820.8">def set_default_kind(kind):
    self.default_kind = kind
    self.c.k.simulateCommand('vr3-update')
</t>
<t tx="TomP.20200329223820.9">def set_freeze(checked):
    self.freeze = checked
</t>
<t tx="bob.20080107154757">class pluginController:
    """A per commander plugin controller to create and handle
    minibuffer commands that control the plugins functions.
    """

    @others
</t>
<t tx="bob.20080107154757.1">def __init__ (self,c):
    """
    Initialze pluginController by registering minibuffer commands.
    """
    self.c = c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
    for command in (
        'export-html',
        'export-html-bullet',
        'export-html-number',
        'export-html-head',

        'export-html-node',
        'export-html-node-bullet',
        'export-html-node-number',
        'export-html-node-head',

        'show-html',
        'show-html-bullet',
        'show-html-number',
        'show-html-head',

        'show-html-node',
        'show-html-node-bullet',
        'show-html-node-number',
        'show-html-node-head'
    ):
        method = getattr(self, command.replace('-','_'))
        c.k.registerCommand(command, method)
</t>
<t tx="bob.20080107154757.3"># EXPORT ALL

def export_html(self, event=None, bullet=None, show=False, node=False):
    """Command handler for leo_to_html. See modules docstring for details."""
    html = Leo_to_HTML(self.c)
    html.main(bullet=bullet, show=show, node=node)

def export_html_bullet(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet='bullet')

def export_html_number(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet='number')

def export_html_head(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet='head')

# EXPORT NODE


def export_html_node(self,event=None, bullet=None,):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet=bullet, node=True)

def export_html_node_bullet(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html_node(bullet='bullet')

def export_html_node_number(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html_node(bullet='number')

def export_html_node_head(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html_node(bullet='head')


# SHOW ALL


def show_html(self, event=None, bullet=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet=bullet, show=True)

def show_html_bullet(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html(bullet='bullet')

def show_html_number(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html(bullet='number')

def show_html_head(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html(bullet='head')


## SHOW NODE

def show_html_node(self, event=None, bullet=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.export_html(bullet=bullet, show=True, node=True)

def show_html_node_bullet(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html_node(bullet='bullet')

def show_html_node_number(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html_node(bullet='number')

def show_html_node_head(self, event=None):
    """Command handler for leo_to_html. See modules docstring for details."""
    self.show_html_node(bullet='head')
</t>
<t tx="bob.20110119123023.7395">class graphcanvasUI(QtWidgets.QWidget):
    @others
</t>
<t tx="bob.20110119123023.7396">def __init__(self, owner=None):

    self.owner = owner
    super().__init__()
    uiPath = g.os_path_join(g.app.leoDir,
        'plugins', 'GraphCanvas', 'GraphCanvas.ui')
    # change directory for this to work
    old_dir = os.getcwd()
    try:
        os.chdir(g.os_path_join(g.computeLeoDir(), ".."))
        form_class, base_class = uic.loadUiType(uiPath)
        self.owner.c.frame.log.createTab('Graph', widget = self)
        self.UI = form_class()
        self.UI.setupUi(self)
    finally:
        os.chdir(old_dir)
    self.canvas = QtWidgets.QGraphicsScene()
    self.canvasView = GraphicsView(self.owner, self.canvas)
    self.canvasView.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
    self.UI.canvasFrame.addWidget(self.canvasView)
    self.canvasView.setSceneRect(0,0,300,300)
    self.canvasView.setRenderHints(QtGui.QPainter.Antialiasing)
    u = self.UI
    o = self.owner

    u.btnUpdate.clicked.connect(lambda checked: o.do_update())
    u.btnGoto.clicked.connect(lambda checked: o.goto())

    u.btnLoad.clicked.connect(lambda checked: o.loadGraph())
    u.btnLoadSibs.clicked.connect(lambda checked: o.loadGraph('sibs'))
    u.btnLoadRecur.clicked.connect(lambda checked: o.loadGraph('recur'))

    u.btnLoadLinked.clicked.connect(lambda checked: o.loadLinked('linked'))
    u.btnLoadAll.clicked.connect(lambda checked: o.loadLinked('all'))

    u.btnUnLoad.clicked.connect(lambda checked: o.unLoad())
    u.btnClear.clicked.connect(lambda checked: o.clear())

    u.btnLocate.clicked.connect(lambda checked: o.locateNode())
    u.btnReset.clicked.connect(lambda checked: o.resetNode())
    u.btnColor.clicked.connect(lambda checked: o.setColor())
    u.btnTextColor.clicked.connect(lambda checked: o.setTextColor())
    u.btnClearFormatting.clicked.connect(lambda checked: o.clearFormatting())

    u.btnRect.clicked.connect(lambda checked: o.setNode(nodeRect))
    u.btnEllipse.clicked.connect(lambda checked: o.setNode(nodeEllipse))
    u.btnDiamond.clicked.connect(lambda checked: o.setNode(nodeDiamond))
    u.btnNone.clicked.connect(lambda checked: o.setNode(nodeNone))
    u.btnTable.clicked.connect(lambda checked: o.setNode(nodeTable))

    u.btnComment.clicked.connect(lambda checked: o.setNode(nodeComment))

    u.btnImage.clicked.connect(lambda checked: o.setNode(nodeImage))

    u.btnExport.clicked.connect(lambda checked: o.exportGraph())

    u.chkHierarchy.clicked.connect(lambda checked: o.do_update())

    menu = QtWidgets.QMenu(u.btnLayout)
    for name, func in o.layouts():
        menu.addAction(name, func)
    u.btnLayout.setMenu(menu)

</t>
<t tx="bob.20110119123023.7405">def __init__(self, glue, hierarchyLink=False, *args, **kargs):
    """:Parameters:
        - `glue`: glue object owning this

    pass glue object and let it key nodeItems to leo nodes
    """
    self.glue = glue
    super().__init__()
    self.line = QtWidgets.QGraphicsLineItem(*args)

    pen = QtGui.QPen()

    self.line.setZValue(0)
    if not hierarchyLink:
        self.setZValue(1)
        pen.setWidth(2)
    else:
        self.setZValue(0)
        pen.setColor(QtGui.QColor(240,240,240))
        pen.setWidth(2) # (0.5)

    self.line.setPen(pen)
    self.addToGroup(self.line)

    self.head = QtWidgets.QGraphicsPolygonItem()

    if hierarchyLink:
        self.head.setBrush(QtGui.QBrush(QtGui.QColor(180,180,180)))
    else:
        self.head.setBrush(QtGui.QBrush(QtGui.QColor(0,0,0)))

    self.head.setPen(QtGui.QPen(QtConst.NoPen))
    self.addToGroup(self.head)
</t>
<t tx="bob.20110119123023.7406">def mousePressEvent(self, event):
    QtWidgets.QGraphicsItemGroup.mousePressEvent(self, event)
    self.glue.pressLink(self, event)
</t>
<t tx="bob.20110119123023.7407">def setLine(self, x0, y0, x1, y1, hierarchyLink = False):

    self.line.setLine(x0, y0, x1, y1)

    x,y = x1-(x1-x0)/3., y1-(y1-y0)/3.

    if not hierarchyLink:
        r = 12.
    else:
        r = 6.

    a = atan2(y1-y0, x1-x0)
    w = 2.79252680
    pts = [
        QtCore.QPointF(x, y),
        QtCore.QPointF(x+r*cos(a+w), y+r*sin(a+w)),
        QtCore.QPointF(x+r*cos(a-w), y+r*sin(a-w)),
        # QtCore.QPointF(x, y),
    ]
    self.head.setPolygon(QtGui.QPolygonF(pts))
</t>
<t tx="bob.20110119123023.7408">class graphcanvasController:
    """Display and edit links in leo"""
    @others
</t>
<t tx="bob.20110119123023.7409">def __init__ (self,c):

    self.c = c
    self.c.graphcanvasController = self
    self.selectPen = QtGui.QPen(QtGui.QColor(255,0,0))
    self.selectPen.setWidth(2)
    self.ui = graphcanvasUI(self)
    g.registerHandler('headkey2', lambda a,b: self.do_update())
    g.registerHandler("select2", self.onSelect2)
    # g.registerHandler('open2', self.loadLinks)
        # already missed initial 'open2' because of after-create-leo-frame, so
        # self.loadLinksInt()
    self.initIvars()
    self.reloadSettings()
    
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.graph_manual_layout = \
        c.config.getBool('graph-manual-layout',default=False)
</t>
<t tx="bob.20110119123023.7410">def initIvars(self):
    """initialize, called by __init__ and clear"""
    self.node = {}  # item to vnode map
    self.nodeItem = {}  # vnode to item map
    self.link = {}
    self.linkItem = {}
    self.hierarchyLink = {}
    self.hierarchyLinkItem = {}
    self.lastNodeItem = None
    self.internal_select = False
    # avoid selection of a @graph node on the graph triggering onSelect2
</t>
<t tx="bob.20110119123023.7411">def locateNode(self):

    node, item = self.nodeitemForPos()

    if not item:
        return

    if 'x' in node.u['_bklnk']:
        x,y = node.u['_bklnk']['x'], node.u['_bklnk']['y']

    self.ui.canvasView.centerOn(x, y)

    self.loadGraph()

    self.releaseNode(item)  # fake click on node to select
</t>
<t tx="bob.20110119123023.7412">def loadLinked(self, what='linked'):

    blc = getattr(self.c, 'backlinkController')
    if not blc:
        return
    while True:
        # loaded = len(self.node)
        linked = set()
        for i in self.nodeItem:
            for j in blc.linksTo(i):
                if j not in self.nodeItem:
                    linked.add(j)
            for j in blc.linksFrom(i):
                if j not in self.nodeItem:
                    linked.add(j)
        for node in linked:
            self.loadGraph(what=[node])
        if not linked or what != 'all':
            # none added, or doing just one round
            break
</t>
<t tx="bob.20110119123023.7413">def addLinkItem(self, from_, to, hierarchyLink = False):
    if from_ not in self.nodeItem:
        return
    if to not in self.nodeItem:
        return
    key = (from_, to)
    if key in self.linkItem:
        return

    li = linkItem(self, hierarchyLink)
    self.setLinkItem(li, from_, to)

    if not hierarchyLink:
        self.linkItem[key] = li
        self.link[li] = key
    else:
        self.hierarchyLinkItem[key] = li
        self.hierarchyLink[li] = key

    self.ui.canvas.addItem(li)
</t>
<t tx="bob.20110119123023.7414">def setLinkItem(self, li, from_, to, hierarchyLink=False):

    fromSize = self.nodeItem[from_].size()
    toSize = self.nodeItem[to].size()

    li.setLine(
        from_.u['_bklnk']['x'] + fromSize.width()/2,
        from_.u['_bklnk']['y'] + fromSize.height()/2+self.nodeItem[from_].iconVPos,
        to.u['_bklnk']['x'] + toSize.width()/2,
        to.u['_bklnk']['y'] + toSize.height()/2+self.nodeItem[to].iconVPos,
        hierarchyLink)
</t>
<t tx="bob.20110119123023.7416">def releaseNode(self, nodeItem, event=None):
    """nodeItem is telling us it has a new position"""

    if self.lastNodeItem == nodeItem:
        return

    #X node = self.node[nodeItem]
    #X node.u['_bklnk']['x'] = nodeItem.x()
    #X node.u['_bklnk']['y'] = nodeItem.y()

    # text only node needs pen used to indicate selection removed
    lastNode = self.lastNodeItem
    if (lastNode and
        not isinstance(lastNode, nodeNone) and
        not isinstance(lastNode, nodeImage)
    ):
        lastNode.bg.setPen(QtGui.QPen(QtConst.NoPen))

    if  (not isinstance(nodeItem, nodeNone) and
         not isinstance(nodeItem, nodeImage)
    ):
        nodeItem.bg.setPen(self.selectPen)

    oldItem = self.lastNodeItem
    self.lastNodeItem = nodeItem  # needed for self.goto()

    if event and self.ui.UI.chkTrack.isChecked():
        # event is none if this is an internal call
        self.goto()

    blc = getattr(self.c, 'backlinkController')

    if not blc:
        return

    if event and event.modifiers() &amp; QtConst.ShiftModifier:
        links = blc.linksFrom(self.node[oldItem])
        if self.node[nodeItem] not in links:
            blc.vlink(self.node[oldItem], self.node[nodeItem])
            # blc will call our do_update(), so in retaliation...
            blc.updateTabInt()
</t>
<t tx="bob.20110119123023.7417">def newNode(self, pnt):
    nn = self.c.currentPosition().insertAfter()
    nn.setHeadString('node')
    self.c.selectPosition(nn)
    self.c.redraw()
    self.loadGraph(pnt=pnt)

</t>
<t tx="bob.20110119123023.7418">def pressLink(self, linkItem, event):
    """nodeItem is telling us it was clicked"""

    blc = getattr(self.c, 'backlinkController')

    if not blc:
        return

    if not (event.modifiers() &amp; QtConst.ControlModifier):
        return

    if linkItem in self.link:
        link = self.link[linkItem]

    v0, v1 = link

    # delete in both directions, only one will be needed, typically
    id0 = v0.gnx
    id1 = v1.gnx
    blc.deleteLink(v0, id1, 'S')
    blc.deleteLink(v1, id0, 'S')

    # blc will call our do_update(), so in retaliation...
    blc.updateTabInt()

    print('done')
</t>
<t tx="bob.20110119123023.7419">def unLoad(self):

    if not self.lastNodeItem:
        return
    node = self.node[self.lastNodeItem]

    self.ui.canvas.removeItem(self.lastNodeItem)

    culls = [i for i in self.linkItem if node in i]

    for i in culls:
        del self.link[self.linkItem[i]]
        self.ui.canvas.removeItem(self.linkItem[i])
        del self.linkItem[i]

    culls = [i for i in self.hierarchyLinkItem if node in i]

    for i in culls:
        del self.hierarchyLink[self.hierarchyLinkItem[i]]
        self.ui.canvas.removeItem(self.hierarchyLinkItem[i])
        del self.hierarchyLinkItem[i]

    del self.nodeItem[node]
    del self.node[self.lastNodeItem]

    self.lastNodeItem = None
</t>
<t tx="bob.20110119123023.7420">def clear(self):

    for i in self.node:
        self.ui.canvas.removeItem(i)
    for i in self.link:
        self.ui.canvas.removeItem(i)
    for i in self.hierarchyLink:
        self.ui.canvas.removeItem(i)

    self.initIvars()

    self.ui.reset_zoom()
</t>
<t tx="bob.20110119123023.7421">def do_update(self, adjust=True):
    """rescan name, links, extent"""

    self.ui.reset_zoom()

    for i in self.linkItem:
        self.ui.canvas.removeItem(self.linkItem[i])
    self.linkItem = {}

    blc = getattr(self.c, 'backlinkController')

    for i in list(self.nodeItem):
        # can't iterate dict because nodeTable can add items on update

        self.nodeItem[i].do_update()

        if blc:
            for link in blc.linksFrom(i):
                self.addLinkItem(i, link)
            for link in blc.linksTo(i):
                self.addLinkItem(link, i)

    for i in self.hierarchyLinkItem:
        self.ui.canvas.removeItem(self.hierarchyLinkItem[i])
    self.hierarchyLinkItem = {}

    if self.ui.UI.chkHierarchy.isChecked():
        for i in self.nodeItem:
            for child in i.children:
                if child in self.nodeItem:
                    self.addLinkItem(i, child, hierarchyLink=True)

    if adjust:
        self.ui.canvasView.setSceneRect(self.ui.canvas.sceneRect().adjusted(-50,-50,50,50))
</t>
<t tx="bob.20110119123023.7422">def goto(self):
    """make outline select node"""
    if not self.lastNodeItem:
        return
    v = self.node[self.lastNodeItem]
    p = self.c.vnode2position(v)
    if self.c.positionExists(p):
        self.internal_select = True
        self.c.selectPosition(p)
</t>
<t tx="bob.20110119133133.3353">def loadGraph(self, what='node', create = True, pnt=None):

    if what == 'sibs':
        collection = self.c.currentPosition().self_and_siblings()
    elif what == 'recur':
        collection = self.c.currentPosition().subtree()
    elif what == 'node':
        collection = [self.c.currentPosition()]
    else:
        collection = what

    for pos in collection:

        try:
            node = pos.v
        except AttributeError:
            node = pos

        if node in self.nodeItem:
            continue

        if self.graph_manual_layout:
            if '_bklnk' not in node.u and not create:
                continue

        # use class name rather than class to avoid saving pickled
        # class in .leo file
        ntype = nodeRect.__name__
        if '_bklnk' not in node.u:
            node.u['_bklnk'] = {}
        if 'type' in node.u['_bklnk']:
            ntype = node.u['_bklnk']['type']
        elif node.h.startswith('@image '):
            ntype = nodeImage.__name__

        if isinstance(ntype, int):
            # old style
            ntype = {
                0: nodeRect.__name__,
                1: nodeEllipse.__name__,
                2: nodeDiamond.__name__,
                3: nodeNone.__name__,
                4: nodeComment.__name__,
                5: nodeImage.__name__,
            }[ntype]

        node.u['_bklnk']['type'] = ntype  # updates old graphs

        node_obj = nodeBase.make_node(self, node, ntype)

        self.node[node_obj] = node
        self.nodeItem[node] = node_obj

        if 'x' not in node.u['_bklnk']:
            node.u['_bklnk']['x'] = 0
            node.u['_bklnk']['y'] = 0

        if 'color' in node.u['_bklnk']:
            node_obj.set_bg_color(node.u['_bklnk']['color'])
        if 'tcolor' in node.u['_bklnk']:
            node_obj.set_text_color(node.u['_bklnk']['tcolor'])

        x,y = 0,0
        if pnt:
            x,y = pnt.x(), pnt.y()
            node.u['_bklnk']['x'] = x
            node.u['_bklnk']['y'] = y
        elif 'x' in node.u['_bklnk']:
            x,y = node.u['_bklnk']['x'], node.u['_bklnk']['y']
        else:
            node.u['_bklnk']['x'] = x
            node.u['_bklnk']['y'] = y

        node_obj.setPos(x,y)
        self.ui.canvas.addItem(node_obj)

    self.do_update()

    if what == 'node' and collection[0].v in self.nodeItem:
        # then select it
        self.releaseNode(self.nodeItem[collection[0].v])
</t>
<t tx="bob.20110120111825.3352">@others
</t>
<t tx="bob.20110120111825.3354">def resetNode(self):

    if not self.lastNodeItem:
        return
    node = self.node[self.lastNodeItem]

    if 'x' in node.u['_bklnk']:
        del node.u['_bklnk']['x']
        del node.u['_bklnk']['y']
    if 'color' in node.u['_bklnk']:
        del node.u['_bklnk']['color']
    if 'tcolor' in node.u['_bklnk']:
        del node.u['_bklnk']['tcolor']
    if 'type' in node.u['_bklnk']:
        del node.u['_bklnk']['type']

    del node.u['_bklnk']

    self.unLoad()
</t>
<t tx="bob.20110120111825.3356">def setColor(self):

    if self.lastNodeItem not in self.node:
        return
    node = self.node[self.lastNodeItem]
    item = self.nodeItem[node]

    if 'color' in node.u['_bklnk']:
        color = node.u['_bklnk']['color']
        newcolor = QtWidgets.QColorDialog.getColor(QtGui.QColor(color))
    else:
        newcolor = QtWidgets.QColorDialog.getColor()

    if QtGui.QColor.isValid(newcolor):
        newcolor = str(newcolor.name())  # store strings not objects
        item.set_bg_color(newcolor)
        node.u['_bklnk']['color'] = newcolor

    self.releaseNode(item)  # reselect
    self.c.redraw()  # update color of node in the tree too
</t>
<t tx="bob.20110120111825.3358">def setTextColor(self):

    if self.lastNodeItem not in self.node:
        return
    node = self.node[self.lastNodeItem]
    item = self.nodeItem[node]

    if 'tcolor' in node.u['_bklnk']:
        color = node.u['_bklnk']['tcolor']
        newcolor = QtWidgets.QColorDialog.getColor(QtGui.QColor(color))
    else:
        newcolor = QtWidgets.QColorDialog.getColor()

    if QtGui.QColor.isValid(newcolor):
        newcolor = str(newcolor.name())  # store strings not objects
        item.set_text_color(newcolor)
        node.u['_bklnk']['tcolor'] = newcolor

    self.releaseNode(item)  # reselect
    self.c.redraw()  # update color of node in the tree too
</t>
<t tx="bob.20110120111825.3360">def clearFormatting(self):

    if self.lastNodeItem not in self.node:
        return
    node = self.node[self.lastNodeItem]
    item = self.nodeItem[node]
    # FIXME: need node.clear_formatting()
    if hasattr(item, 'bg') and hasattr(item.bg, 'setBrush'):
        item.bg.setBrush(QtGui.QBrush(QtGui.QColor(200,240,200)))
    if hasattr(item, 'text'):
        item.text.setDefaultTextColor(QtGui.QColor(0,0,0))
    if 'color' in node.u['_bklnk']:
        del node.u['_bklnk']['color']
    if 'tcolor' in node.u['_bklnk']:
        del node.u['_bklnk']['tcolor']
    self.releaseNode(self.nodeItem[node])
    self.c.redraw()  # update color of node in the tree too
</t>
<t tx="bob.20110120173002.3405">def onSelect2 (self,tag,keywords):

    """Shows the UNL in the status line whenever a node gets selected."""

    if self.internal_select:
        self.internal_select = False
        return

    c = keywords.get("c")

    # c.p is not valid while using the settings panel.
    new_p = keywords.get('new_p')
    if not new_p: return

    if new_p.h.startswith('@graph'):
        self.clear()
        self.loadGraph('node', create = False)
        if '_bklnk' in new_p.v.u:
            # self.loadLinked('all')
            self.loadGraph('recur', create = False)
        elif self.lastNodeItem and '_bklnk' in self.lastNodeItem.node.u:
            x,y = self.lastNodeItem.node.u['_bklnk']['x'], self.lastNodeItem.node.u['_bklnk']['y']
            self.ui.canvasView.centerOn(x, y)

    if c.p.v in self.nodeItem and self.ui.UI.chkTrack.isChecked():
        self.locateNode()
</t>
<t tx="bob.20110121113659.3412"></t>
<t tx="bob.20110121113659.3413"></t>
<t tx="bob.20110121113659.3414"></t>
<t tx="bob.20110121161547.3424">class linkItem(QtWidgets.QGraphicsItemGroup):
    """Node on the canvas"""
    @others
</t>
<t tx="bob.20110127092345.6036">def newPos(self, nodeItem, event):
    """nodeItem is telling us it has a new position

    need to do_update links to reflect new position, while still dragging
    """
    node = self.node[nodeItem]
    node.u['_bklnk']['x'] = nodeItem.x()
    node.u['_bklnk']['y'] = nodeItem.y()

    blc = getattr(self.c, 'backlinkController')
    if blc:
        for link in blc.linksFrom(node):
            if (node, link) in self.linkItem:
                self.setLinkItem(self.linkItem[(node, link)], node, link)

        for link in blc.linksTo(node):
            if (link, node) in self.linkItem:
                self.setLinkItem(self.linkItem[(link, node)], link, node)

    for parent in node.parents:
        if (parent, node) in self.hierarchyLinkItem:
            self.setLinkItem(self.hierarchyLinkItem[(parent, node)], parent, node)

    for child in node.children:
        if (node, child) in self.hierarchyLinkItem:
            self.setLinkItem(self.hierarchyLinkItem[(node, child)], node, child)
</t>
<t tx="bob.20110202125047.4170">def exportGraph(self):

    image = QtGui.QImage(2048,1536,QtGui.QImage.Format_ARGB32_Premultiplied)
    painter = QtGui.QPainter(image)
    self.ui.canvas.render(painter)
    painter.end()
    filepath, extension = QtWidgets.QFileDialog.getSaveFileName(
        caption="Export to File",
        filter="*.png",
    )
    if filepath:
        image.save(filepath)
</t>
<t tx="bobjack.20080509080123.2">def universalCallback(self, source_c, function):
    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """

    def minibufferCallback(event, function=function):
        # Avoid a pylint complaint.
        if hasattr(self, 'theContextMenuController'):
            cm = getattr(self, 'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None
        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}
        keywords['mb_event'] = event
        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
        # For g.getDocStringForFunction
    minibufferCallback.source_c = source_c
        # For GetArgs.command_source
    return minibufferCallback

#fix bobjack's spelling error

universallCallback = universalCallback
</t>
<t tx="bwmulder.20050319134815">def create_leo_h_reference(self, window, node):
    parts = [window.shortFileName()] + self.get_leo_nameparts(node)
    href = '/' + '/'.join(parts)
    return href
</t>
<t tx="bwmulder.20050319135316">def node_reference(self, vnode):
    """
    Given a position p, return the name of the node.

    This is called from leo.core.leoRst.
    """
    # 1. Find the root
    root = vnode
    parent = root.parent()
    while parent:
        root = parent
        parent = root.parent()
    while root.v._back:
        root.moveToBack()
    # 2. Return the window
    window = [w for w in g.app.windowList if w.c.rootVnode().v == root.v][0]
    result = self.create_leo_h_reference(window, vnode)
    return result
</t>
<t tx="bwmulder.20050322224921">def send_head(self):
    """Common code for GET and HEAD commands.

     This sends the response code and MIME headers.

     Return value is either a file object (which has to be copied
     to the outputfile by the caller unless the command was HEAD,
     and must be closed by the caller under all circumstances), or
     None, in which case the caller has nothing further to do.

     """
    try:
        # self.path is provided by the RequestHandler class.
        path = self.split_leo_path(self.path)
        if path[0] == '_':
            f = self.leo_actions.get_response()
        elif len(path) == 1 and path[0] == 'favicon.ico':
            f = self.leo_actions.get_favicon()
        elif path == '/':
            f = self.write_leo_windowlist()
        else:
            try:
                window, root = self.find_window_and_root(path)
                if window is None:
                    self.send_error(404, "File not found")
                    return None
                if root is None:
                    self.send_error(404, "No root node")
                    return None
                f = StringIO()
                self.write_leo_tree(f, window, root)
            except nodeNotFound:
                self.send_error(404, "Node not found")
                return None
            except noLeoNodePath:
                g.es("No Leo node path:", path)
                # Is there something better we can do here?
                self.send_error(404, "Node not found")
                return None
        if f is None:
            return None
        length = f.tell()
        f.seek(0)
        self.send_response(200)
        self.send_header("Content-type", getattr(f, "mime_type", "text/html"))
        self.send_header("Content-Length", str(length))
        self.end_headers()
        return f
    except Exception:
        import traceback
        traceback.print_exc()
        raise
    return None
</t>
<t tx="bwmulder.20050326191345">class config:
    enabled = None # True when security check re http-allow-remote-exec passes.
    http_active = False
    http_timeout = 0
    http_ip = '127.0.0.1'
    http_port = 8130
    rst2_http_attributename = 'rst_http_attribute'
</t>
<t tx="bwmulder.20061014153544">class noLeoNodePath(Exception):
    """
    Raised if the path can not be converted a filename and a series of numbers.
    Most likely a reference to a picture.
    """
    pass
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.743">def scanPluginDirectives (tag, keywords):

    """Add a tuple (d,v,s,k) to list for every directive d found"""

    global directives

    keys = ("c","p","s","theDict","pluginsList")
    c,p,s,theDict,pluginsList = [keywords.get(key) for key in keys]

    for d in directives:
        if d in theDict:
            # Point k at whatever follows the directive.
            s = theDict.get(d)
            g.trace('s',s)
            kind = d
            pluginsList.append((kind,p.v,s),)
</t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="ekr.20031218072017.1263">def utils_rename(c, src, dst, verbose=True):
    """Platform independent rename."""
    # Don't call g.makeAllNonExistentDirectories here!
    try:
        shutil.move(src, dst)
        return True
    except Exception:
        if verbose:
            g.error('exception renaming', src, 'to', dst)
            g.es_exception(full=False)
        return False
</t>
<t tx="ekr.20031218072017.1329">def onBodyChanged(self, undoType, oldSel=None):
    """
    Update Leo after the body has been changed.
    
    This method is deprecated. New Leo commands and scripts should
    call u.before/afterChangeBody instead.
    """
    p, u, w = self.c.p, self.c.undoer, self.wrapper
    #
    # Shortcut.
    newText = w.getAllText()
    if p.b == newText:
        return
    #
    # Init data.
    newSel = w.getSelectionRange()
    newInsert = w.getInsertPoint()
    #
    # The "Before" snapshot.
    #
    # #1743: Restore oldSel for u.beforeChangeBody
    if oldSel and newSel and oldSel != newSel:
        i, j = oldSel
        w.setSelectionRange(i, j, insert=j)
    bunch = u.beforeChangeBody(p)
    #
    # #1743: Restore newSel if necessary.
    if oldSel and newSel and oldSel != newSel:
        i, j = newSel
        w.setSelectionRange(i, j, insert=newInsert)
    #
    # Careful. Don't redraw unless necessary.
    p.v.b = newText  # p.b would cause a redraw.
    #
    # "after" snapshot.
    u.afterChangeBody(p, undoType, bunch)
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2817">command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True  # For sc.make_slide_show_command.
        # 1912: This message is annoying and unhelpful.
        # g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
</t>
<t tx="ekr.20031218072017.2824">def compute_ext(self, c, p, ext):
    """Return the file extension to be used in the temp file."""
    if ext:
        for ch in ("'", '"'):
            if ext.startswith(ch): ext = ext.strip(ch)
    if not ext:
        # if node is part of @&lt;file&gt; tree, get ext from file name
        for p2 in p.self_and_parents(copy=False):
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None, 1)[1]
                ext = g.os_path_splitext(fn)[1]
                break
    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
    if not ext:
        ext = '.txt'
    if ext[0] != '.':
        ext = '.' + ext
    return ext
</t>
<t tx="ekr.20031218072017.2829">def open_file_in_external_editor(self, c, d, fn, testing=False):
    """
    Open a file fn in an external editor.

    This will be an entire external file, or a temp file for a single node.

    d is a dictionary created from an @openwith settings node.

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
        'name':     menu label (used only by the menu code).
        'p':        the nearest @&lt;file&gt; node, or None.
        'shortcut': menu shortcut (used only by the menu code).
    """
    testing = testing or g.unitTesting
    arg_tuple = d.get('args', [])
    arg = ' '.join(arg_tuple)
    kind = d.get('kind')
    try:
        # All of these must be supported because they
        # could exist in @open-with nodes.
        command = '&lt;no command&gt;'
        if kind in ('os.system', 'os.startfile'):
            # New in Leo 5.7:
            # Use subProcess.Popen(..., shell=True)
            c_arg = self.join(arg, fn)
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif kind == 'exec':
            g.es_print('open-with exec no longer valid.')
        elif kind == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = f"os.spawnl({arg},{filename},{fn})"
            if not testing: os.spawnl(os.P_NOWAIT, arg, filename, fn)
        elif kind == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0])
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = f"os.spawnv({vtuple})"
            if not testing:
                os.spawnv(os.P_NOWAIT, arg[0], vtuple)  #???
        elif kind == 'subprocess.Popen':
            c_arg = self.join(arg, fn)
            command = f"subprocess.Popen({c_arg})"
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif hasattr(kind, '__call__'):
            # Invoke openWith like this:
            # c.openWith(data=[func,None,None])
            # func will be called with one arg, the filename
            command = f"{kind}({fn})"
            if not testing: kind(fn)
        else:
            command = 'bad command:' + str(kind)
            if not testing: g.trace(command)
        return command  # for unit testing.
    except Exception:
        g.es('exception executing open-with command:', command)
        g.es_exception()
        return f"oops: {command}"
</t>
<t tx="ekr.20031218072017.2832">def compute_temp_file_path(self, c, p, ext):
    """Return the path to the temp file for p and ext."""
    if c.config.getBool('open-with-clean-filenames'):
        path = self.clean_file_name(c, ext, p)
    else:
        path = self.legacy_file_name(c, ext, p)
    if not path:
        g.error('c.temp_file_path failed')
    return path
</t>
<t tx="ekr.20031218072017.3029">def readAtFileNodes(self):
    
    c, p = self.c, self.c.p
    c.endEditing()
    c.atFileCommands.readAll(p, force=True)
    c.redraw()
    # Force an update of the body pane.
    c.setBodyString(p, p.b)  # Not a do-nothing!
    
</t>
<t tx="ekr.20031218072017.3053">def __init__(self, c):
    """Ctor for LeoFind class."""
    self.c = c
    self.expert_mode = False  # Set in finishCreate.
    self.ftm = None  # Created by dw.createFindTab.
    self.frame = None
    self.k = c.k
    self.re_obj = None
    #
    # The work "widget".
    self.work_s = ''  # p.b or p.c.
    self.work_sel = (0, 0, 0)  # pos, newpos, insert.
    #
    # Options ivars: set by FindTabManager.init.
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.whole_word = None
    #
    # For isearch commands...
    self.stack = []  # Entries are (p, sel)
    self.isearch_ignore_case = None
    self.isearch_forward_flag = None
    self.isearch_regexp = None
    self.findTextList = []
    self.changeTextList = []
    #
    # For find/change...
    self.find_text = ""
    self.change_text = ""
    #
    # State machine...
    self.escape_handler = None
    self.handler = None
    # "Delayed" requests for do_find_next.
    self.request_reverse = False
    self.request_pattern_match = False
    self.request_whole_word = False
    # Internal state...
    self.changeAllFlag = False
    self.findAllUniqueFlag = False
    self.find_def_data = None
    self.in_headline = False
    self.match_obj = None
    self.reverse = False
    self.root = None  # The start of the search, especially for suboutline-only.
    self.unique_matches = set()
    #
    # User settings.
    self.minibuffer_mode = None
    self.reload_settings()
</t>
<t tx="ekr.20031218072017.3055"></t>
<t tx="ekr.20031218072017.3062">@cmd('replace-then-find')
@cmd('change-then-find')
def change_then_find(self, event=None):  # pragma: no cover (cmd)
    """Handle the replace-then-find command."""
    # Settings...
    self.init_in_headline()
    settings = self.ftm.get_settings()
    self.do_change_then_find(settings)
</t>
<t tx="ekr.20031218072017.3063">@cmd('find-next')
def find_next(self, event=None):  # pragma: no cover (cmd)
    """The find-next command."""
    # Settings...
    self.reverse = False
    self.init_in_headline()  # Do this *before* creating the settings.
    settings = self.ftm.get_settings()
    # Do the command!
    self.do_find_next(settings)

@cmd('find-prev')
def find_prev(self, event=None):  # pragma: no cover (cmd)
    """Handle F2 (find-previous)"""
    # Settings...
    self.init_in_headline()  # Do this *before* creating the settings.
    settings = self.ftm.get_settings()
    # Do the command!
    self.do_find_prev(settings)
</t>
<t tx="ekr.20031218072017.3067"></t>
<t tx="ekr.20031218072017.3068">@cmd('replace')
@cmd('change')
def change(self, event=None):  # pragma: no cover (cmd)
    p = self.c.p
    if self.check_args('replace'):
        self.init_in_headline()
        self.change_selection(p)

replace = change
</t>
<t tx="ekr.20031218072017.3069">def _change_all_helper(self, settings):
    """Do the change-all command. Return the number of changes, or 0 for error."""
    # Caller has checked settings.

    c, current, u = self.c, self.c.p, self.c.undoer
    undoType = 'Replace All'
    t1 = time.process_time()
    if not self.check_args('change-all'):  # pragma: no cover
        return 0
    self.init_in_headline()
    saveData = self.save()
    self.in_headline = self.search_headline  # Search headlines first.
    # Remember the start of the search.
    p = self.root = c.p.copy()
    # Set the work widget.
    s = p.h if self.in_headline else p.b
    ins = len(s) if self.reverse else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    count = 0
    u.beforeChangeGroup(current, undoType)
    # Fix bug 338172: ReplaceAll will not replace newlines
    # indicated as \n in target string.
    if not self.find_text:  # pragma: no cover
        return 0
    if not self.search_headline and not self.search_body:  # pragma: no cover
        return 0
    self.change_text = self.replace_back_slashes(self.change_text)
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:
            return 0
    # #1428: Honor limiters in replace-all.
    if self.node_only:
        positions = [c.p]
    elif self.suboutline_only:
        positions = c.p.self_and_subtree()
    else:
        positions = c.all_unique_positions()
    count = 0
    for p in positions:
        count_h, count_b = 0, 0
        undoData = u.beforeChangeNodeContents(p)
        if self.search_headline:
            count_h, new_h = self._change_all_search_and_replace(p.h)
            if count_h:
                count += count_h
                p.h = new_h
        if self.search_body:
            count_b, new_b = self._change_all_search_and_replace(p.b)
            if count_b:
                count += count_b
                p.b = new_b
        if count_h or count_b:
            u.afterChangeNodeContents(p, 'Replace All', undoData)
    self.ftm.set_radio_button('entire-outline')
    # suboutline-only is a one-shot for batch commands.
    self.root = None
    self.node_only = self.suboutline_only = False
    p = c.p
    u.afterChangeGroup(p, undoType, reportFlag=True)
    t2 = time.process_time()
    if not g.unitTesting:  # pragma: no cover
        g.es_print(
            f"changed {count} instances{g.plural(count)} "
            f"in {t2 - t1:4.2f} sec.")
    c.recolor()
    c.redraw(p)
    self.restore(saveData)
    return count
</t>
<t tx="ekr.20031218072017.3070">def change_selection(self, p):
    """Replace selection with self.change_text."""
    c = self.c
    wrapper = c.frame.body and c.frame.body.wrapper
    gui_w = c.edit_widget(p) if self.in_headline else wrapper
    if not gui_w:  # pragma: no cover
        self.in_headline = False
        gui_w = wrapper
    if not gui_w:  # pragma: no cover
        return False
    oldSel = sel = gui_w.getSelectionRange()
    start, end = sel
    if start &gt; end:  # pragma: no cover
        start, end = end, start
    if start == end:  # pragma: no cover
        g.es("no text selected")
        return False
    start, end = oldSel
    change_text = self.change_text
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.make_regex_subs(change_text, groups)
    change_text = self.replace_back_slashes(change_text)
    # Update both the gui widget and the work "widget"
    new_ins = start if self.reverse else start + len(change_text)
    if start != end:
        gui_w.delete(start, end)
        self.work_s = self.work_s[:start] + self.work_s[start + end :]
    gui_w.insert(start, change_text)
    gui_w.setInsertPoint(new_ins)
    self.work_sel = (new_ins, new_ins, new_ins)
    # Update the selection for the next match.
    gui_w.setSelectionRange(start, start + len(change_text))
    c.widgetWantsFocus(gui_w)
    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:  # pragma: no cover
        p.setMarked()
        p.setDirty()
    if self.in_headline:  # pragma: no cover
        pass
    else:
        c.frame.body.onBodyChanged('Change', oldSel=oldSel)
    c.frame.tree.updateIcon(p)  # redraw only the icon.
    return True
</t>
<t tx="ekr.20031218072017.3073">def do_find_all(self, settings):
    """Top-level helper for find-all command."""
    c = self.c
    count = 0
    self.init_ivars_from_settings(settings)
    if not self.check_args('find-all'):  # pragma: no cover
        return count
    # Init data.
    self.init_in_headline()
    data = self.save()
    self.in_headline = self.search_headline  # Search headlines first.
    self.unique_matches = set()  # 2021/02/20.
    # Remember the start of the search.
    p = self.root = c.p.copy()
    # Set the work widget.
    s = p.h if self.in_headline else p.b
    ins = len(s) if self.reverse else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:  # pragma: no cover
            return count
    if self.suboutline_only:
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Always search the entire outline.
        p = c.rootPosition()
        after = None
    # Fix #292: Never collapse nodes during find-all commands.
    old_sparse_find = c.sparse_find
    try:
        c.sparse_find = False
        count = self._find_all_helper(after, data, p, 'Find All')
        c.contractAllHeadlines()
    finally:
        c.sparse_find = old_sparse_find
        self.root = None
    if count:
        c.redraw()
    g.es("found", count, "matches for", self.find_text)
    return count
</t>
<t tx="ekr.20031218072017.3074">def do_find_prev(self, settings):
    """Find the previous instance of self.find_text."""
    self.request_reverse = True
    return self.do_find_next(settings)

def do_find_next(self, settings):
    """
    Find the next instance of self.find_text.
    
    Return True (for vim-mode) if a match was found.
    
    """
    c, p = self.c, self.c.p
    #
    # The gui widget may not exist for headlines.
    gui_w = c.edit_widget(p) if self.in_headline else c.frame.body.wrapper
    #
    # Init the work widget, so we don't get stuck.
    s = p.h if self.in_headline else p.b
    ins = gui_w.getInsertPoint() if gui_w else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    #
    # Set the settings *after* initing the search.
    self.init_ivars_from_settings(settings)
    #
    # Honor delayed requests.
    for ivar in ('reverse', 'pattern_match', 'whole_word'):
        request = 'request_' + ivar
        val = getattr(self, request)
        if val:  # Only *set* the ivar!
            setattr(self, ivar, val)  # Set the ivar.
            setattr(self, request, False)  # Clear the request!
    #
    # Leo 6.4: set/clear self.root
    if self.root:  # pragma: no cover
        if p != self.root and not self.root.isAncestorOf(p):
            # p is outside of self.root's tree.
            # Clear suboutline-only.
            self.root = None
            self.suboutline_only = False
            self.set_find_scope_every_where()  # Update find-tab &amp; status area.
    elif self.suboutline_only:
        # Start the range and set suboutline-only.
        self.root = c.p
        self.set_find_scope_suboutline_only()  # Update find-tab &amp; status area.
    #
    # Now check the args.
    tag = 'find-prev' if self.reverse else 'find-next'
    if not self.check_args(tag):  # Issues error message.
        return None, None, None
    data = self.save()
    p, pos, newpos = self.find_next_match(p)
    found = pos is not None
    if found:
        self.show_success(p, pos, newpos)
    else:
        # Restore previous position.
        self.restore(data)
    self.show_status(found)
    return p, pos, newpos
</t>
<t tx="ekr.20031218072017.3075">def find_next_match(self, p):
    """
    Resume the search where it left off.
    
    Return (p, pos, newpos).
    """
    c = self.c
    if not self.search_headline and not self.search_body:  # pragma: no cover
        return None, None, None
    if not self.find_text:  # pragma: no cover
        return None, None, None
    attempts = 0
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:
            return None, None, None
    while p:
        pos, newpos = self._fnm_search(p)
        if pos is not None:
            # Success.
            if self.mark_finds:  # pragma: no cover
                p.setMarked()
                p.setDirty()
                if not self.changeAllFlag:
                    c.frame.tree.updateIcon(p)  # redraw only the icon.
            return p, pos, newpos
        # Searching the pane failed: switch to another pane or node.
        if self._fnm_should_stay_in_node(p):
            # Switching panes is possible.  Do so.
            self.in_headline = not self.in_headline
            s = p.h if self.in_headline else p.b
            ins = len(s) if self.reverse else 0
            self.work_s = s
            self.work_sel = (ins, ins, ins)
        else:
            # Switch to the next/prev node, if possible.
            attempts += 1
            p = self._fnm_next_after_fail(p)
            if p:  # Found another node: select the proper pane.
                self.in_headline = self._fnm_first_search_pane()
                s = p.h if self.in_headline else p.b
                ins = len(s) if self.reverse else 0
                self.work_s = s
                self.work_sel = (ins, ins, ins)
    return None, None, None
</t>
<t tx="ekr.20031218072017.3077">def _fnm_search(self, p):
    """
    Search self.work_s for self.find_text with present options.
    Returns (pos, newpos) or (None, dNone).
    """
    index = self.work_sel[2]
    s = self.work_s
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:  # pragma: no cover
        return None, None
    stopindex = 0 if self.reverse else len(s)
    pos, newpos = self.inner_search_helper(s, index, stopindex, self.find_text)
    if self.in_headline and not self.search_headline:  # pragma: no cover
        return None, None
    if not self.in_headline and not self.search_body:  # pragma: no cover
        return None, None
    if pos == -1:  # pragma: no cover
        return None, None
    ins = min(pos, newpos) if self.reverse else max(pos, newpos)
    self.work_sel = (pos, newpos, ins)
    return pos, newpos
</t>
<t tx="ekr.20031218072017.3082"></t>
<t tx="ekr.20031218072017.3086">def init_in_headline(self):
    """
    Select the first pane to search for incremental searches and changes.
    This is called only at the start of each search.
    This must not alter the current insertion point or selection range.
    """
    #
    # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
    if self.search_headline and self.search_body:
        # We have no choice: we *must* search the present widget!
        self.in_headline = self.focus_in_tree()
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20031218072017.3089">def restore(self, data):
    """
    Restore Leo's gui and settings from data, a g.Bunch.
    """
    c, p = self.c, data.p
    c.frame.bringToFront()  # Needed on the Mac
    if not p or not c.positionExists(p):  # pragma: no cover
        # Better than selecting the root!
        return
    c.selectPosition(p)
    # Fix bug 1258373: https://bugs.launchpad.net/leo-editor/+bug/1258373
    if self.in_headline:
        c.treeWantsFocus()
    else:
        # Looks good and provides clear indication of failure or termination.
        w = c.frame.body.wrapper
        w.setSelectionRange(data.start, data.end, insert=data.insert)
        w.seeInsertPoint()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20031218072017.3090">def save(self):
    """Save everything needed to restore after a search fails."""
    c = self.c
    if self.in_headline:  # pragma: no cover
        # Fix bug 1258373: https://bugs.launchpad.net/leo-editor/+bug/1258373
        # Don't try to re-edit the headline.
        insert, start, end = None, None, None
    else:
        w = c.frame.body.wrapper
        insert = w.getInsertPoint()
        start, end = w.getSelectionRange()
    data = g.Bunch(
        end=end,
        in_headline=self.in_headline,
        insert=insert,
        p=c.p.copy(),
        start=start,
    )
    return data
</t>
<t tx="ekr.20031218072017.3091">def show_success(self, p, pos, newpos, showState=True):
    """Display the result of a successful find operation."""
    c = self.c
    # Set state vars.
    # Ensure progress in backwards searches.
    insert = min(pos, newpos) if self.reverse else max(pos, newpos)
    if c.sparse_find:  # pragma: no cover
        c.expandOnlyAncestorsOfNode(p=p)
    if self.in_headline:
        c.endEditing()
        selection = pos, newpos, insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        # Tricky code.  Do not change without careful thought.
        w = c.frame.body.wrapper
        # *Always* do the full selection logic.
        # This ensures that the body text is inited  and recolored.
        c.selectPosition(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        c.bodyWantsFocusNow()
        w.setSelectionRange(pos, newpos, insert=insert)
        k = g.see_more_lines(w.getAllText(), insert, 4)
        w.see(k)
            # #78: find-next match not always scrolled into view.
        c.outerUpdate()
            # Set the focus immediately.
        if c.vim_mode and c.vimCommands:  # pragma: no cover
            c.vimCommands.update_selection_after_search()
    # Support for the console gui.
    if hasattr(g.app.gui, 'show_find_success'):  # pragma: no cover
        g.app.gui.show_find_success(c, self.in_headline, insert, p)
    c.frame.bringToFront()
    return w  # Support for isearch.
    
</t>
<t tx="ekr.20031218072017.3154">def scanAtRootOptions(s, i, err_flag=False):
    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s, i, "@root"):
        i += len("@root")
        i = g.skip_ws(s, i)
    mode = None
    while g.match(s, i, '-'):
        &lt;&lt; scan another @root option &gt;&gt;
    if mode is None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = "doc" if doc else "code"
    return i, mode
</t>
<t tx="ekr.20031218072017.3155">i += 1; err = -1
if g.match_word(s, i, "code"):  # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
elif g.match(s, i, "doc"):  # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
else:
    err = i - 1
# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ', '\t', '\n', '-'):
    i += 1
if err &gt; -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s, i)
    g.es("unknown option:", z_opt, "in", z_line)
</t>
<t tx="ekr.20031218072017.3210">def createOutline(self,
    fileName,
    parent,
    atShadow=False,  # For error messages only.
    ext=None,
    s=None,
    # force_at_others=False,  # tag:no-longer-used
):
    """
    Create an outline by importing a file, reading the file with the
    given encoding if string s is None.

    ext,        The file extension to be used, or None.
    fileName:   A string or None. The name of the file to be read.
    parent:     The parent position of the created outline.
    s:          A string or None. The file's contents.
    """
    c = self.c
    p = parent.copy()
    self.treeType = '@file'
        # Fix #352.
    fn = self.get_import_filename(fileName, parent)
    if g.is_binary_external_file(fileName):
        return self.import_binary_file(fn, parent)
    # Init ivars.
    self.setEncoding(
        p=parent,
        default=c.config.default_at_auto_file_encoding,
    )
    ext, s = self.init_import(atShadow, ext, fileName, s)
    if s is None:
        return None
    # Get the so-called scanning func.
    func = self.dispatch(ext, p)
        # Func is a callback. It must have a c argument.
    # Call the scanning function.
    if g.unitTesting:
        assert func or ext in ('.txt', '.w', '.xxx'), (repr(func), ext, p.h)
    if func and not c.config.getBool('suppress-import-parsing', default=False):
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        # func is actually a factory: it instantiates the importer class.
        func(c=c, parent=p, s=s)
            # force_at_others=force_at_others #tag:no-longer-used
    else:
        # Just copy the file to the parent node.
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        self.scanUnknownFileType(s, p, ext)
    # Fix bug 488894: unsettling dialog when saving Leo file
    # Fix bug 889175: Remember the full fileName.
    c.atFileCommands.rememberReadPath(fileName, p)
    p.contract()
    w = c.frame.body.wrapper
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context: Cmdr, gnx: Optional[str] = None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString: str = 'newHeadline'
    self._bodyString: str = ''
    # For zodb.
    self._p_changed = 0
    # Structure data...
    self.children: List["VNode"] = []
        # Ordered list of all children of this node.
    self.parents: List["VNode"] = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex: Union[str, None] = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions: List[Position] = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self) -&gt; bool:
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3395">def contract(self):
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20040205071616.5">def insertBodystamp (c,v):

    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    stamp = mnOKstamp() + '\n'
    bunch = u.beforeChangeBody(p)
    ins = w.getInsertPoint()
    w.insert(ins,stamp)
    p.v.b = w.getAllText()  # p.b would cause a redraw.
    u.afterChangeBody(p, 'insert-timestamp', bunch)
</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    """Handle the Insert User command."""
    c = self
    w = c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    w.deleteTextSelection() # Works if nothing is selected.
    stamp = mnstamp()
    i = w.getInsertPoint()
    w.insert(i,stamp)
    c.frame.body.onBodyChanged('insert-user',oldSel=oldSel)
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331151007.2">def onPostSave(tag=None, keywords=None):
    """After saving an @nosent file, replace all tabs with spaces."""

    global nosentNodes
    c = keywords.get('c')
    if c:
        at = c.atFileCommands
        for p in nosentNodes:
            g.red("node %s found" % p.h)
            at.scanAllDirectives(p)
            name = p.atNoSentinelsFileNodeName()
            fname = g.os_path_join(at.default_directory,name)
            f = open(fname,"r")
            lines = f.readlines()
            f.close()
            &lt;&lt; add a newline before def or class &gt;&gt;
            &lt;&lt; replace tabs with spaces &gt;&gt;

    nosentNodes = []
</t>
<t tx="ekr.20040331151007.3">for i, s in enumerate(lines):
    ls = s.lstrip()
    if ls.startswith("def ") or ls.startswith("class "):
        try:
            if lines[i-1].strip() != "":
                lines[i] = "\n" + lines[i]
        except IndexError:
            pass
</t>
<t tx="ekr.20040331151007.4">s = ''.join(lines)
fh = open(fname,"w")
fh.write(s.replace("\t",NSPACES))
fh.close()
</t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040910070811.6">class readingThread(threading.Thread):

    File = None
    TextLock = threading.Lock()
    TextLock.acquire()
    Text = ""

    @others
</t>
<t tx="ekr.20040910070811.7">def run(self):

    '''Called automatically when the thread is created.'''

    global Encoding

    if not self.File:
        return

    s=self.File.readline()
    while s:
        if s != "\n":
            self.TextLock.acquire()
            try:
                self.Text = self.Text + g.toUnicode(s,Encoding)
            except IOError as ioerr:
                self.Text = self.Text +"\n"+ "[@run] ioerror :"+str(ioerr)
            self.TextLock.release()
        s=self.File.readline()
        time.sleep(0.01)
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041005105605.10">def initCommonIvars(self):
    """
    Init ivars common to both reading and writing.

    The defaults set here may be changed later.
    """
    at = self
    c = at.c
    at.at_auto_encoding = c.config.default_at_auto_file_encoding
    at.default_directory = None
    at.encoding = c.config.default_derived_file_encoding
    at.endSentinelComment = ""
    at.errors = 0
    at.inCode = True
    at.indent = 0  # The unit of indentation is spaces, not tabs.
    at.language = None
    at.output_newline = g.getOutputNewline(c=c)
    at.page_width = None
    at.raw = False  # True: in @raw mode
    at.root = None  # The root (a position) of tree being read or written.
    at.startSentinelComment = ""
    at.startSentinelComment = ""
    at.tab_width = c.tab_width or -4
    at.writing_to_shadow_directory = False
</t>
<t tx="ekr.20041005105605.129">def scanHeader(self, fileName, giveErrors=True):
    """
    Scan the @+leo sentinel, using the old readLine interface.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file.
    """
    at = self
    new_df, isThinDerivedFile = False, False
    firstLines = []  # The lines before @+leo.
    s = self.scanFirstLines(firstLines)
    valid = len(s) &gt; 0
    if valid:
        valid, new_df, start, end, isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    elif giveErrors:
        at.error(f"No @+leo sentinel in: {fileName}")
        g.trace(g.callers())
    return firstLines, new_df, isThinDerivedFile
</t>
<t tx="ekr.20041005105605.13">def initReadIvars(self, root, fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):
    at = self
    at.initCommonIvars()
    at.bom_encoding = None
        # The encoding implied by any BOM (set by g.stripBOM)
    at.cloneSibCount = 0
        # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
    at.correctedLines = 0
        # For perfect import.
    at.docOut = []  # The doc part being accumulated.
    at.done = False  # True when @-leo seen.
    at.endSentinelIndentStack = []
        # Restored indentation for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelStack = []
        # Contains entries for +node sentinels only when not readVersion5
    at.endSentinelLevelStack = []
        # The saved level, len(at.thinNodeStack), for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelNodeStack = []
        # Used only when readVersion5.
    at.fromString = False
    at.importing = bool(importFileName)
    at.importRootSeen = False
    at.indentStack = []
    at.lastLines = []  # The lines after @-leo
    at.lastRefNode = None
        # The previous reference node, for at.readAfterRef.
        # No stack is needed because -&lt;&lt; sentinels restore at.v
        # to the node needed by at.readAfterRef.
    at.lastThinNode = None
        # The last thin node at this level.
        # Used by createThinChild4.
    at.leadingWs = ""
    at.lineNumber = 0  # New in Leo 4.4.8.
    at.out = None
    at.outStack = []
    at.perfectImportRoot = perfectImportRoot
    at.read_i = 0
    at.read_lines = []
    at.readVersion = ''
        # New in Leo 4.8: "4" or "5" for new-style thin files.
    at.readVersion5 = False
        # synonym for at.readVersion &gt;= '5' and not atShadow.
    at.root = root
    at.rootSeen = False
    at.atShadow = atShadow
    at.targetFileName = fileName
        # For at.writeError only.
    at.tnodeList = []
        # Needed until old-style @file nodes are no longer supported.
    at.tnodeListIndex = 0
    at.v = None
    at.vStack = []  # Stack of at.v values.
    at.thinChildIndexStack = []  # number of siblings at this level.
    at.thinNodeStack = []  # Entries are vnodes.
    at.updateWarningGiven = False
</t>
<t tx="ekr.20041005105605.130">def scanFirstLines(self, firstLines):
    '''
    Append all lines before the @+leo line to firstLines.

    Empty lines are ignored because empty @first directives are
    ignored.

    We can not call sentinelKind here because that depends on the comment
    delimiters we set here.
    '''
    at = self
    s = at.readLine()
    while s and s.find("@+leo") == -1:
        firstLines.append(s)
        s = at.readLine()
    return s
</t>
<t tx="ekr.20041005105605.144">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.outputList = []
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.147">def writeAll(self, all=False, dirty=False):
    """Write @file nodes in all or part of the outline"""
    at, c = self, self.c
    # This is the *only* place where these are set.
    # promptForDangerousWrite sets cancelFlag only if canCancelFlag is True.
    at.canCancelFlag = True
    at.cancelFlag = False
    at.yesToAll = False
    files, root = at.findFilesToWrite(all)
    for p in files:
        try:
            at.writeAllHelper(p, root)
        except Exception:
            at.internalWriteError(p)
    # Make *sure* these flags are cleared for other commands.
    at.canCancelFlag = False
    at.cancelFlag = False
    at.yesToAll = False
    # Say the command is finished.
    at.reportEndOfWrite(files, all, dirty)
    if c.isChanged():
        # Save the outline if only persistence data nodes are dirty.
        at.saveOutlineIfPossible()
</t>
<t tx="ekr.20041005105605.149">def writeAllHelper(self, p, root):
    '''
    Write one file for at.writeAll.
    
    Do *not* write @auto files unless p == root.
    
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    if p.isAtIgnoreNode():
        # Should have been handled in findFilesToWrite.
        g.trace(f"Can not happen: {p.h} is an @ignore node")
        return
    try:
        at.writePathChanged(p)
    except IOError:
        return
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode():
        at.write('@clean', p, sentinels=False)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write('@file', p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()
</t>
<t tx="ekr.20041005105605.15">def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory=None,
    forcePythonSentinels=False,
    kind=None,
    sentinels=True,
):
    """
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    """
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.kind = kind
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.outputList = []
        # For stream output.
    targetFileName = os.path.expanduser(targetFileName or '')  # #1900.
    at.targetFileName = targetFileName 
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    # #1341 and #1450.
    make_dirs = c and c.config and c.config.create_nonexistent_directories
    if at.default_directory:
        at.default_directory = c.expand_path_expression(at.default_directory)
        if make_dirs:
            ok = g.makeAllNonExistentDirectories(at.default_directory)
            if not ok:
                g.error(f"Did not create default directory: {at.default_directory}")
                return None
    # #1341 and #1450.
    targetFileName = c.expand_path_expression(targetFileName)
    if targetFileName:
        theDir = g.os_path_dirname(targetFileName)
        if theDir and make_dirs:
            ok = g.makeAllNonExistentDirectories(theDir)
            if not ok:
                g.trace(f"Did not create {theDir} for {targetFileName}")
                return None
    # #1341.
    return g.os_path_realpath(
        g.os_path_finalize_join(at.default_directory, targetFileName))
</t>
<t tx="ekr.20041005105605.151">def writeMissing(self, p):
    at, c = self, self.c
    writtenFiles = False
    c.init_error_dialogs()
    # #1450.
    at.initWriteIvars(root=p.copy(), targetFileName='')
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:  # Don't use iterator.
        if (
            p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode())
        ):
            fileName = p.anyAtFileNodeName()
            if fileName:
                fileName = c.expand_path_expression(fileName)  # #1341
                fileName = g.os_path_finalize_join(
                    at.default_directory, fileName)  # #1341
                if at.precheck(fileName, p):
                    at.writeMissingNode(p)
                    writtenFiles = True
                else:
                    at.addToOrphanList(p)
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if writtenFiles &gt; 0:
            g.es("finished")
        else:
            g.es("no @file node in the selected tree")
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20041005105605.152">def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtFileNode():
        at.write('@file', p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
</t>
<t tx="ekr.20041005105605.154">def asisWrite(self, root):
    at, c = self, self.c
    try:
        c.endEditing()
        c.init_error_dialogs()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.outputList = []
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        if not at.errors:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        at.writeException(fileName, root)

silentWrite = asisWrite  # Compatibility with old scripts.
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.176">def putRefLine(self, s, i, n1, n2, name, p):
    """Put a line containing one or more references."""
    at = self
    ref = at.findReference(name, p)
    if not ref:
        if hasattr(at, 'allow_undefined_refs'):
            # Allow apparent section reference: just write the line.
            at.putCodeLine(s, i)
        return
    # Compute delta only once.
    junk, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    # Write the lead-in sentinel only once.
    at.putLeadInSentinel(s, i, n1, delta)
    self.putRefAt(name, ref, delta)
    n_refs = 0
    while 1:
        progress = i
        i = n2
        n_refs += 1
        name, n1, n2 = at.findSectionName(s, i)
        if self.kind == '@clean' and n_refs &gt; 1:
            # #1232: allow only one section reference per line in @clean.
            i1, i2 = g.getLine(s, i)
            line = s[i1:i2].rstrip()
            at.writeError(f"Too many section references:\n{line!s}")
            break
        if name:
            ref = at.findReference(name, p)
                # Issues error if not found.
            if ref:
                middle_s = s[i:n1]
                self.putAfterMiddleRef(middle_s, delta)
                self.putRefAt(name, ref, delta)
        else:
            break
        assert progress &lt; i
    self.putAfterLastRef(s, i, delta)
</t>
<t tx="ekr.20041005105605.177">def putRefAt(self, name, ref, delta):
    at = self
    # #132: Section Reference causes clone...
    #
    # Never put any @+middle or @-middle sentinels.
    at.indent += delta
    at.putSentinel("@+" + name)
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    at.putSentinel("@-" + name)
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.178">def putAfterLastRef(self, s, start, delta):
    """Handle whatever follows the last ref of a line."""
    at = self
    j = g.skip_ws(s, start)
    if j &lt; len(s) and s[j] != '\n':
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        end = g.skip_line(s, start)
        after = s[start:end]
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl()  # Add a newline if the line didn't end with one.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.179">def putAfterMiddleRef(self, s, delta):
    """Handle whatever follows a ref that is not the last ref of a line."""
    at = self
    if s:
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(s)
        at.onl_sent()  # Not a real newline.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.19">def openFileForReading(self, fromString=False):
    """
    Open the file given by at.root.
    This will be the private file for @shadow nodes.
    """
    at, c = self, self.c
    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.initReadLine(fromString)
        return None, None
    #
    # Not from a string. Carefully read the file.
    fn = g.fullPath(c, at.root)
        # Returns full path, including file name.
    at.setPathUa(at.root, fn)
        # Remember the full path to this node.
    if at.atShadow:
        fn = at.openAtShadowFileForReading(fn)
        if not fn:
            return None, None
    assert fn
    try:
        s = at.readFileToUnicode(fn)
            # Sets at.encoding, regularizes whitespace and calls at.initReadLines.
        # #1466.
        if s is None:
            # The error has been given.
            at._file_bytes = g.toEncodedString('')
            return None, None
        at.warnOnReadOnlyFile(fn)
    except Exception:
        at.error(f"unexpected exception opening: '@file {fn}'")
        at._file_bytes = g.toEncodedString('')
        fn, s = None, None
    return fn, s
</t>
<t tx="ekr.20041005105605.193">def putOpenNodeSentinel(self, p, inAtAll=False):
    """Write @+node sentinel for p."""
    at = self
    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.h)
        return
    s = at.nodeSentinelText(p)
    at.putSentinel("@+node:" + s)
    # Leo 4.7 b2: we never write tnodeLists.
</t>
<t tx="ekr.20041005105605.199">def findSectionName(self, s, i):
    """
    Return n1, n2 representing a section name.
    The section name, *including* brackes is s[n1:n2]
    """
    end = s.find('\n', i)
    if end == -1:
        n1 = s.find("&lt;&lt;", i)
        n2 = s.find("&gt;&gt;", i)
    else:
        n1 = s.find("&lt;&lt;", i, end)
        n2 = s.find("&gt;&gt;", i, end)
    ok = -1 &lt; n1 &lt; n2
    if ok:
        # Warn on extra brackets.
        for ch, j in (('&lt;', n1 + 2), ('&gt;', n2 + 2)):
            if g.match(s, j, ch):
                line = g.get_line(s, i)
                g.es('dubious brackets in', line)
                break
        name = s[n1 : n2 + 2]
        return name, n1, n2 + 2
    return None, n1, len(s)
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041005105605.21">def read(self, root, importFileName=None,
    fromString=None, atShadow=False, force=False
):
    """Read an @thin or @file tree."""
    at, c = self, self.c
    fileName = g.fullPath(c, root)  # #1341. #1889.
    if not fileName:
        at.error("Missing file name. Restoring @file tree from .leo file.")
        return False
    at.rememberReadPath(g.fullPath(c, root), root)
        # Fix bug 760531: always mark the root as read, even if there was an error.
        # Fix bug 889175: Remember the full fileName.
    at.initReadIvars(root, fileName,
        importFileName=importFileName, atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        return False
    fileName, file_s = at.openFileForReading(fromString=fromString)
    # #1798:
    if file_s is None:
        return False
    #
    # Set the time stamp.
    if fileName:
        c.setFileTimeStamp(fileName)
    elif not fileName and not fromString and not file_s:
        return False
    root.clearVisitedInTree()
    at.scanAllDirectives(root, importing=at.importing, reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **changed later** by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    gnx2vnode = c.fileCommands.gnxDict
    contents = fromString or file_s
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    root.clearDirty()
    return True
</t>
<t tx="ekr.20041005105605.210">def putIndent(self, n, s=''):
    """Put tabs and spaces corresponding to n spaces,
    assuming that we are at the start of a line.

    Remove extra blanks if the line starts with the underindentEscapeString"""
    tag = self.underindentEscapeString
    if s.startswith(tag):
        n2, s2 = self.parseUnderindentTag(s)
        if n2 &gt;= n:
            return
        if n &gt; 0: n -= n2
        else: n += n2
    if n &gt; 0:
        w = self.tab_width
        if w &gt; 1:
            q, r = divmod(n, w)
            self.otabs(q)
            self.oblanks(r)
        else:
            self.oblanks(n)
</t>
<t tx="ekr.20041005105605.26">def readAll(self, root, force=False):
    """Scan positions, looking for @&lt;file&gt; nodes to read."""
    at, c = self, self.c
    old_changed = c.changed
    if force:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing()
    t1 = time.time()
    c.init_error_dialogs()
    files = at.findFilesToRead(force, root)
    for p in files:
        at.readFileAtPosition(force, p)
    for p in files:
        p.v.clearDirty()
    if not g.unitTesting:
        if files:
            t2 = time.time()
            g.es(f"read {len(files)} files in {t2 - t1:2.2f} seconds")
        elif force:
            g.es("no @&lt;file&gt; nodes in the selected tree")
    c.changed = old_changed
    c.raise_error_dialogs()
</t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20050104123726.3">def utils_remove(fileName, verbose=True):
    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            g.es("exception removing:", fileName)
            g.es_exception()
        return False
</t>
<t tx="ekr.20050104123726.4">def utils_stat(fileName):
    """Return the access mode of named file, removing any setuid, setgid, and sticky bits."""
    try:
        mode = (os.stat(fileName))[0] &amp; (7 * 8 * 8 + 7 * 8 + 7)  # 0777
    except Exception:
        mode = None
    return mode
</t>
<t tx="ekr.20050104124903">def utils_chmod(fileName, mode, verbose=True):
    if mode is None:
        return
    try:
        os.chmod(fileName, mode)
    except Exception:
        if verbose:
            g.es("exception in os.chmod", fileName)
            g.es_exception()
</t>
<t tx="ekr.20050104132018">def remove(self, fileName, verbose=True):
    if not fileName:
        g.trace('No file name', g.callers())
        return False
    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            self.error(f"exception removing: {fileName}")
            g.es_exception()
            g.trace(g.callers(5))
        return False
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

from leo.core import leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050301083306.10">def importDir (self,dir,compteurglobal):

    """ La routine récursive de lecture des fichiers """

    if not g.os_path_exists(dir):
        if language == 'french':
            g.es("Ce répertoire n'existe pas: %s" + dir)
        else:
            g.es("No such Directory: %s" + dir)
        return compteurglobal

    head,tail = g.os_path_split(dir)
    c = self.c ; current = c.p
    try:
        #ici, on liste le contenu du répertoire
        body=""
        &lt;&lt; listdir &gt;&gt;
        p = c.importCommands.createHeadline(current,body,tail)
        c.selectPosition(p)
        if dossiers:
            for d in dossiers:
                compteurglobal = self.importDir(d,compteurglobal)
        c.setChanged()
        #sélectionne le noeud parent
        c.selectPosition(current)
    except Exception:
        if language == 'french':
            g.es("erreur d'insertion de noeud...")
        else:
            g.es("error while creating node...")
        g.es_exception()

    return compteurglobal
</t>
<t tx="ekr.20050301083306.11">try:
    fichiers = os.listdir(dir)
    dossiers = []
    for f in fichiers:
        # mettre ici le code de création des noeuds
        path = g.os_path_join(dir,f)
        # est-ce un fichier ?
        if g.os_path_isfile(path):
            body += (f+"\n")
        else:
            # c'est alors un répertoire
            dossiers.append(path)
        compteurglobal += 1
except Exception:
    if language == 'french':
        g.es("erreur dans listage fichiers...")
    else:
        g.es("os.listdir error...")
    g.es_exception()
</t>
<t tx="ekr.20050301083306.6">class controller:

    @others
</t>
<t tx="ekr.20050301083306.7">def __init__ (self,c):

    self.c = c
</t>
<t tx="ekr.20050301083306.8">def readDir (self,event=None):

    # fr - Modifier pour adapter à votre environnement
    # en - Change it to select the starting browsing directory
    c = self.c ; startdir = "/home/"

    if language == 'french':
        titledialog = "Choisir le répertoire..."
    else:
        titledialog = "Please, select a directory..."

    dirName = g.app.gui.runOpenDirectoryDialog(
        title=titledialog,
        startdir=startdir,
    )

    if dirName:
        g.es(dirName)
        compteurglobal = self.importDir(dirName,compteurglobal=0)
        c.selectPosition(c.p)
        c.redraw()
        if language == 'french':
            g.es(str(compteurglobal)+" fichiers traités.")
        else:
            g.es(str(compteurglobal)+" files outlined.")
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050506084734">def stringToString(self, root, s, forcePythonSentinels=True, sentinels=True):
    """
    Write a 4.x derived file from a string.

    This is at.write specialized for scripting.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(
            root,
            targetFileName="&lt;string-file&gt;",
            forcePythonSentinels=forcePythonSentinels,
            sentinels=sentinels,
        )
        at.outputList = []
        at.putFile(root, fromString=s, sentinels=sentinels)
        contents = '' if at.errors else ''.join(at.outputList)
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if root:
            if hasattr(self.root.v, 'tnodeList'):
                delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return contents
    except Exception:
        at.exception("exception preprocessing script")
        return ''
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">g.cls()
import os
if c.changed:
    c.save()
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
if 1:
    dir_ = os.path.join(g.app.loadDir, '..', '..')
    command = 'python -m leoserver --unittest'
elif 1:
    dir_ = os.path.join(g.app.loadDir, '..', '..')
    command = prolog + r"leo.core.leoserver leo\core\leoserver.py"
else: # Fails.
    dir = g.app.loadDir
    command = prolog + "leoserver leoserver.py"
os.chdir(dir_)
g.execute_shell_commands(command)
</t>
<t tx="ekr.20060107110126.2">class pluginController:

    @others
</t>
<t tx="ekr.20060107110126.3">def __init__ (self,c):

    self.c = c
</t>
<t tx="ekr.20060328125925.10">def createChapterHoistButton (self,sc,c,p):

    '''Generates a hoist button for the headline at the given position'''
    h = p.h
    buttonText = sc.getButtonText(h)
    statusLine = "Hoist %s" % h

    def hoistButtonCallback (event=None,self=self,c=c,p=p.copy()):
        while (c.canDehoist()):
            c.dehoist()
        c.selectPosition(p)
        c.hoist()
        return 'break'

    sc.createIconButton(
        args=None,
        text=buttonText,
        command=hoistButtonCallback,
        statusLine=statusLine)
</t>
<t tx="ekr.20060328125925.6">class chapterHoist:
    @others
</t>
<t tx="ekr.20060328125925.7">def __init__ (self,sc,c):
    self.createSaveHoistButton(sc,c)
    self.createDehoistButton(sc,c)
</t>
<t tx="ekr.20060328125925.8">def createSaveHoistButton(self,sc,c):

    def saveHoistCallback(event=None,self=self,sc=sc,c=c):
        self.createChapterHoistButton(sc,c,c.p)
        c.hoist()

    b = sc.createIconButton(
        args=None,
        text='save-hoist',
        command = saveHoistCallback,
        statusLine='Create hoist button current node')

    return b
</t>
<t tx="ekr.20060328125925.9">def createDehoistButton(self,sc,c):

    def dehoistCallback(event=None,c=c):
        c.dehoist()
        return 'break'

    # Fix #426 with a kludge that satisfies k.registerCommand.
    dehoistCallback.__name__ = 'wrapper: dehoist'

    b = sc.createIconButton(
        args=None,
        text='dehoist',
        command=dehoistCallback,
        statusLine='Dehoist')

    return b
</t>
<t tx="ekr.20060621123339.6">class pluginController:
    @others
</t>
<t tx="ekr.20060621123339.7">def __init__(self, c):
    self.c = c
    c.k.registerCommand('print-cp', self.print_cp)
    script = "c.k.simulateCommand('print-cp')"
    g.app.gui.makeScriptButton(c, script=script, buttonText='Print c &amp; p', bg='red')
</t>
<t tx="ekr.20060621124649">def print_cp(self, event=None):
    c = self.c; p = c.p
    g.red('c: %s' % (c.fileName()))
    g.red('p: %s' % (p.h))
</t>
<t tx="ekr.20060831165845.6">class slideshowController:
    @others
</t>
<t tx="ekr.20060831165845.7">def __init__(self, c):
    self.c = c
    self.firstSlideShow = None
    self.slideShowRoot = None
    self.slide = None
    self.createCommands()
</t>
<t tx="ekr.20060831171016">def createCommands(self):
    c = self.c; k = c.k
    for commandName, func in (
        ('next-slide-command', self.nextSlide),
        ('next-slide-show-command', self.nextSlideShow),
        ('prev-slide-command', self.prevSlide),
        ('prev-slide-show-command', self.prevSlideShow),
    ):
        k.registerCommand(commandName, func)
</t>
<t tx="ekr.20060831171016.4">def prevSlide(self, event=None):
    c = self.c; p = c.p
    if self.ignored(p):
        p = p.threadBack()
    else:
        if self.slide and self.slide == self.slideShowRoot:
            return g.es('At start of slide show')
        if p == self.slide:
            p = self.slide.threadBack()
    while p:
        h = p.h.strip()
        if self.ignored(p):
            p = p.threadBack()
        elif h.startswith('@slideshow'):
            self.select(p)
            return g.es('At start of slide show')
        else:
            return self.select(p)
        # elif h.startswith('@slide'):
            # return self.select(p)
        # else: p = p.threadBack()
    p = self.findFirstSlideShow()
    if p:
        self.select(p)
        return g.es('At start of first slide show')
    return g.es('No slide show found')
</t>
<t tx="ekr.20060831171016.5">def nextSlide(self, event=None):
    c = self.c; p = c.p
    if p == self.slide:
        p = self.slide.threadNext()
        oldSlide = self.slide
    else:
        oldSlide = None
    while p:
        h = p.h.strip()
        if self.ignored(p):
            p = p.threadNext()
        elif h.startswith('@slideshow'):
            self.select(p)
            return g.es('At %s of slide show' % 'end' if oldSlide else 'start')
        elif g.match_word(h, 0, '@ignore') or g.match_word(h, 0, '@noslide'):
            p = p.nodeAfterTree()
        else:
            return self.select(p)
        # elif h.startswith('@slide'):
            # return self.select(p)
        # else: p = p.threadNext()
    return g.es('At end of slide show' if self.slideShowRoot else 'Not in any slide show')
</t>
<t tx="ekr.20060901142848">def nextSlideShow(self, event=None):
    c = self.c
    self.findFirstSlideShow()
    if not self.firstSlideShow:
        g.es('No slide show found')
        return
    if not self.slideShowRoot:
        self.select(self.firstSlideShow)
        return
    p = c.p
    h = p.h.strip()
    if h.startswith('@slideshow'):
        p = p.threadNext()
    while p:
        h = p.h.strip()
        if self.ignored(p):
            p = p.threadNext()
        elif h.startswith('@slideshow'):
            self.select(p)
            return
        elif g.match_word(h, 0, '@ignore'):
            p = p.nodeAfterTree()
        else:
            p = p.threadNext()
    self.select(self.slideShowRoot)
    g.es('At start of last slide show')
</t>
<t tx="ekr.20060901142848.1">def prevSlideShow(self, event=None):
    c = self.c
    self.findFirstSlideShow()
    if not self.firstSlideShow:
        g.es('No slide show found')
        return
    if not self.slideShowRoot:
        self.select(self.firstSlideShow)
        return
    p = c.p
    h = p.h.strip()
    if h.startswith('@slideshow'):
        p = p.threadBack()
    while p:
        h = p.h.strip()
        if self.ignored(p):
            p = p.threadBack()
        elif h.startswith('@slideshow'):
            self.select(p)
            return
        else:
            p = p.threadBack()
    self.select(self.firstSlideShow)
    g.es('At start of first slide show')
</t>
<t tx="ekr.20060901145257">def select(self, p):
    '''Make p the present slide, and set self.slide and maybe self.slideShowRoot.'''
    c = self.c; h = p.h.strip()
    w = c.frame.body.wrapper
    g.es('%s' % h)
    #c.expandAllAncestors(p)
    #c.selectPosition(p)
    c.redraw(p)
    w.see(0)
    if h.startswith('@slideshow'):
        self.slideShowRoot = p.copy()
    self.slide = p.copy()
</t>
<t tx="ekr.20060901182318">def findFirstSlideShow(self):
    c = self.c
    for p in c.all_positions():
        h = p.h.strip()
        if h.startswith('@slideshow'):
            self.firstSlideShow = p.copy()
            return p
        if g.match_word(h, 0, '@ignore'):
            p = p.nodeAfterTree()
    self.firstSlideShow = None
    return None
</t>
<t tx="ekr.20060904110319">def ignored(self, p):
    for p2 in p.self_and_parents():
        if g.match_word(p2.h, 0, '@ignore') or g.match_word(p2.h, 0, '@noslide'):
            return True
    return False
</t>
<t tx="ekr.20060928062431">@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
</t>
<t tx="ekr.20061031131434.100">def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars(self):
    """Set ivars for special keystrokes from previously-existing bindings."""
    c, k = self.c, self
    warn = c.config.getBool('warn-about-missing-settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for bi in aList:
                if bi.pane == pane:
                    setattr(k, ivar, bi.stroke)
                    found = True; break
        if not found and warn:
            g.trace(f"no setting for {commandName}")
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict(self):
    """Add bindings for all entries in c.commandsDict."""
    c, k = self.c, self
    d = c.commandsDict
    #
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bi with bi.stroke == stroke.
    d2 = g.TypedDict(  # was TypedDictOfLists.
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for bi in aList:
            # Important: bi.stroke is already canonicalized.
            stroke = bi.stroke
            bi.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add_to_list(stroke, bi)
    #
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for bi in aList2:
            commandName = bi.commandName
            command = c.commandsDict.get(commandName)
            tag = bi.kind
            pane = bi.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.108">def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) &lt; 32 or ord(ch) &gt; 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
</t>
<t tx="ekr.20061031131434.111">@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state &gt; 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.119">@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '&lt;no hash&gt;'
            data.append((s1, s2, s3, s4),)
    # Print keys by type.
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
</t>
<t tx="ekr.20061031131434.121">@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
</t>
<t tx="ekr.20061031131434.123">@cmd('set-command-state')
def setCommandState(self, event):
    """Enter the 'command' editing state."""
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    """Enter the 'insert' editing state."""
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    """Enter the 'overwrite' editing state."""
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName(self, w, commandName):
    """
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    """
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), (commandName, stroke.__class__.__name__)
    shortcut = stroke.s
    shortcut = g.checkUnicode(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = f"no shortcut for {commandName}"
        if g.app.unitTesting:
            raise AttributeError(message)
        g.error(message)
</t>
<t tx="ekr.20061031131434.127">def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20061031131434.130">@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
</t>
<t tx="ekr.20061031131434.131">def registerCommand(self, commandName, func,
    allowBinding=False,
    pane='all',
    shortcut=None,  # Must be None unless allowBindings is True.
    ** kwargs
):
    """
    Make the function available as a minibuffer command.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.
    
    Ignore the 'shortcut' arg unless 'allowBinding' is True.
    
    Only k.bindOpenWith and the mod_scripting.py plugin should set
    allowBinding.
    """
    c, k = self.c, self
    if not func:
        g.es_print('Null func passed to k.registerCommand\n', commandName)
        return
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '-&gt;', func)
    c.commandsDict[commandName] = func
    # Warn about deprecated arguments.
    if shortcut and not allowBinding:
        g.es_print('The "shortcut" keyword arg to k.registerCommand will be ignored')
        g.es_print('Called from', g.callers())
        shortcut = None
    for arg, val in kwargs.items():
        if val is not None:
            g.es_print(f'The "{arg}" keyword arg to k.registerCommand is deprecated')
            g.es_print('Called from', g.callers())
    # Make requested bindings, even if a warning has been given.
    # This maintains strict compatibility with existing plugins and scripts.
    k.registerCommandShortcut(
        commandName=commandName,
        func=func,
        pane=pane,
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.133">def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
</t>
<t tx="ekr.20061031131434.135"># def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k = self.c, self
    # Setup...
    if trace:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    # Handle the character given by event *without*
    # executing any command that might be bound to it.
    c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
</t>
<t tx="ekr.20061031131434.158">def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode&lt;{modeName}&gt;",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
</t>
<t tx="ekr.20061031131434.160">def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.163">def initMode(self, event, modeName):

    k = self; c = k.c
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    k.modeBindingsDict = d
    bi = d.get('*command-prompt*')
    prompt = bi.kind if bi else modeName
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for bi in aList:
            commandName = bi.commandName
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
</t>
<t tx="ekr.20061031131434.165">@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for bi in aList:
            shortcutList = k.bindingsDict.get(bi.commandName, [])
                # Bug fix: 2017/03/26.
            bi_list = k.bindingsDict.get(
                stroke, g.BindingInfo(kind='dummy', pane='all'))
                # Important: only bi.pane is required below.
            for bi in bi_list:
                pane = f"{bi.pane}:"
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[bi.commandName] = shortcutList
    return d
</t>
<t tx="ekr.20061031131434.179">def getStrokeForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke, aList in k.bindingsDict.items():
            for bi in aList:
                if bi.commandName == commandName:
                    return stroke
    return None
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey(self, stroke):
    """Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key."""
    if not stroke:
        return False
    if not g.isStroke(stroke):
        # Happens during unit tests.
        stroke = g.KeyStroke(stroke)
    #
    # altgr combos (Alt+Ctrl) are always plain keys
    # g.KeyStroke does not handle this, because it has no "c" ivar.
    #
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return True
    return stroke.isPlainKey()
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState(self):
    """Clear the key handler state."""
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler(self):
    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind(self):
    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
</t>
<t tx="ekr.20061031131434.199">def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.74">class KeyHandlerClass:
    """
    A class to support emacs-style commands.
    c.k is an instance of this class.
    """
    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__(self, c):
    """Create a key handler for c."""
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.killedBindings = []
        # A list of commands whose bindings have been set to None in the local file.
    self.replace_meta_with_alt = False
        # True: (Mac only) swap Meta and Alt keys.
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.reloadSettings()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None  # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
</t>
<t tx="ekr.20061031131434.78">def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
</t>
<t tx="ekr.20061031131434.79">def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
</t>
<t tx="ekr.20061031131434.80">def finishCreate(self):
    """
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    """
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
        # Important: This must be called this now,
        # even though LM.laod calls g.app.makeAllBindings later.
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
</t>
<t tx="ekr.20061031131434.92">def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.95">def checkBindings(self):
    """
    Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course."""
    k = self; c = k.c
    if not c.config.getBool('warn-about-missing-settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace(f"No shortcut for abbrev {name} -&gt; {abbrev} = {key}")
            else:
                g.trace(f"No shortcut for {name} = {key}")
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget(self, w):
    """Make all a master gui binding for widget w."""
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings(self):
    """Make all key bindings in all of Leo's panes."""
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass  # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
</t>
<t tx="ekr.20061031170011.10">def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel(self, event):
    """
    Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.
    """
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
</t>
<t tx="ekr.20061031170011.7">def resetLabel(self):
    """Reset the minibuffer label."""
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label=f"{state.capitalize()} State")
</t>
<t tx="ekr.20061031170011.8">def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061101071425">def oops(self):

    g.trace('Should be defined in subclass:', g.callers(4))
</t>
<t tx="ekr.20061212084717">class LeoFind:
    """The base class for Leo's Find commands."""
    @others
</t>
<t tx="ekr.20070115135502">def writeScriptFile(self, script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script-file-path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = g.os_path_finalize_join(*allParts)  # #1431
    else:
        path = g.os_path_finalize_join(g.app.homeLeoDir, 'scriptFile.py')  # #1431
    #
    # Write the file.
    try:
        with open(path, encoding='utf-8', mode='w') as f:
            f.write(script)
    except Exception:
        g.es_exception()
        g.es(f"Failed to write script to {path}")
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script-file-path'))
        path = None
    return path
</t>
<t tx="ekr.20070117113133">def __init__(self, c):

    self.table = (
        ("Make ALL Buttons Here Permanent",None,self.permanentButton),
        ("Clear ALL Permanent Buttons Here",None,self.clearButton),
    )

    self.recent_moves = []  # recent move/copy/bookmark to commands for
                            # top level context menu entries

    self.imps = []  # implementations, (func,name,text)
    self.txts = {}  # get short from name, for permanent buttons
                    # filled in below

    # build callables for imp list

    for name, first_last, long, short in quickMove.flavors:

        self.txts[name] = short

        if first_last:
            todo = 'first child', 'last child', 'next sibling', 'prev sibling'
        else:
            todo = ['']

        for which in todo:

            def func(self=self, which=which, name=name, event=None):
                self.addButton(which=which, type_=name)
            fname = 'func_'+name+'_'+short+'_' +which
            if which:
                which = " "+which.title()
            self.imps.append((func, fname, long+" "+short+which+" Button"))
            cmdname = 'quickmove_'+long+" "+short+which
            cmdname = cmdname.strip().lower().replace(' ', '_')
            # tried to use g.command() but global commands all use the same c
            # so register only at the c level, not g level
            # g.command(cmdname)(func)
            c.k.registerCommand(cmdname, lambda e:func())

    # c.k.registerCommand('quickmove_keyboard_popup', lambda e:self.keyboard_popup())
    # c.k.registerCommand('quickmove_keyboard_action', lambda e:self.keyboard_action())

    self.keyboard_target = None

    self.c = c

    c.quickMove = self

    self.buttons = []

    buttons_todo = []  # get whole list for container buttons

    for nd in c.all_unique_nodes():
        if 'quickMove' in nd.u:
            if 'buttons' in nd.u['quickMove']:  # new dict based storage
                for rec in nd.u['quickMove']['buttons']:
                    buttons_todo.append(rec.copy())
                    buttons_todo[-1].update({'v':nd})
            else:  # read old list format and convert
                new_dicts = []
                for rec in nd.u['quickMove']:
                    if len(rec) != 2:
                        continue  # silently drop even older style permanent button
                    first,type_ = rec
                    buttons_todo.append({'type': type_, 'first': first})
                    new_dicts.append(buttons_todo[-1].copy())
                    buttons_todo[-1].update({'v':nd})
                nd.u['quickMove'] = {'buttons': new_dicts}

    # legacy stuff
    for b in buttons_todo:
        first = b.get('first', None)
        if first is True:
            b['first'] = 'first child'
        if first is False:
            b['first'] = 'last child'

    for i in [b for b in buttons_todo if 'parent' not in b]:
        self.addButton(i['first'], i['type'], v=i['v'])
    for i in reversed([b for b in buttons_todo if 'parent' in b]):
        self.addButton(i['first'], i['type'], v=i['v'], parent=i['parent'])

    # c.frame.menu.createNewMenu('Move', 'Outline')

    self.local_imps = []  # make table for createMenuItemsFromTable()
    for func, name, text in self.imps:
        self.local_imps.append((text, None, func))

    self.local_imps.extend(self.table)
    c.frame.menu.createMenuItemsFromTable('Move', self.table)

    if g.app.gui.guiName() == "qt":
        g.tree_popup_handlers.append(self.popup)
</t>
<t tx="ekr.20070117113133.2">def addButton (self, which, type_="move", v=None, parent=None):
    '''Add a button that creates a target for future moves.'''
    c = self.c
    p = c.p
    if v is None:
        v = p.v
    sc = scriptingController(c)
    mb = quickMoveButton(self,v,which,type_=type_)
    txt=self.txts[type_]

    if parent:  # find parent button
        for i in self.buttons:
            if i[0].target.gnx == parent:
                parent = i[1]
                break
        else:
            g.es('Move to button parent not found, placing at top level')
            parent = None

    header = v.anyAtFileNodeName() or v.h  # drop @auto etc.

    text = txt + ":" + header if txt else header
    # createButton truncates text.

    if parent and g.app.gui.guiName().startswith("qt"):
        pb = parent.button
        rc = QtWidgets.QAction(text, pb)
        rc.triggered.connect(mb.moveCurrentNodeToTarget)
        pb.insertAction(pb.actions()[0], rc) # insert at top
        b = None
        mb.has_parent = True
        # New code.
        t = c.config.getString('mod-scripting-subtext') or ''
        t2 = pb.text()
        if not t.endswith(t):
            pb.setText(t2+t)
    else:
        b = sc.createIconButton(
            args=None,
            text=text,
            command = mb.moveCurrentNodeToTarget,
            statusLine = '%s current node to %s child of %s' % (
                type_.title(), which, v.h),
            kind = "quick-move"
        )
        if g.app.gui.guiName() == "qt":

            def cb_goto_target(checked, c=c, v=v):
                p = c.vnode2position(v)
                c.selectPosition(p)
                c.redraw()

            def cb_set_parent(checked, c=c, v=v, first=which, type_=type_):
                c.quickMove.set_parent(v, first, type_)

            def cb_permanent(checked, c=c, v=v, type_=type_, first=which):
                c.quickMove.permanentButton(v=v, type_=type_, first=first)

            # def cb_clear(event=None, c=c, v=v):
            #     c.quickMove.clearButton(v)

            for cb, txt in [
                (cb_goto_target, 'Goto target'),
                (cb_permanent, 'Make permanent'),
                # (cb_clear, 'Clear permanent'),
                (cb_set_parent, 'Set parent'),
            ]:
                but = b.button
                rc = QtWidgets.QAction(txt, but)
                rc.triggered.connect(cb)
                but.insertAction(but.actions()[-1], rc)
                    # insert rc before Remove Button

    self.buttons.append((mb,b))
</t>
<t tx="ekr.20070117121326">def __init__(self, owner, target, which, type_):

    self.c = owner.c
    self.owner = owner
    self.target = target
    self.targetHeadString = target.h
    self.which = (which or '').strip().lower()
    # (which or '') - handle legacy cases
    self.type_ = type_
    self.has_parent = False
</t>
<t tx="ekr.20070117121326.1">def moveCurrentNodeToTarget(self, checked=False):

    '''Move the current position to the last child of self.target.'''

    c = self.c
    p = c.p

    vnodes = [i.v for i in c.getSelectedPositions()]

    needs_undo = self.type_ != "jump"

    if needs_undo:
        bunch = c.undoer.beforeMoveNode(p)

    for v in vnodes:

        p2 = c.vnode2position(self.target)
        p = c.vnode2position(v)

        if not c.positionExists(p2):
            g.error('Target no longer exists: %s' % self.targetHeadString)
            return

        if self.type_ in ('clone', 'move'):  # all others are always valid?
            if p.v == p2.v or not self.checkMove(p,p2):
                g.error('Invalid move: %s' % (self.targetHeadString))
                return
        if p2.isAncestorOf(p):  # not for sibling moves
            p2.expand()
        nxt = p.visNext(c) or p.visBack(c)
        nxt = nxt.v
        # store a VNode instead of position as positions are too easily lost

        if self.type_ != 'jump':
            p.setDirty()  # before move to dirty current parent
            p2.setDirty()
            c.setChanged()

        if self.type_ == 'clone':
            p = p.clone()

        if self.type_ in ('move', 'clone'):
            if self.which == 'first child':
                p.moveToFirstChildOf(p2)
            elif self.which == 'last child':
                p.moveToLastChildOf(p2)
            elif self.which in ('next sibling', 'prev sibling'):
                if not p2.parent():
                    raise Exception("Not implemented for top-level nodes") #FIXME
                if self.which == 'next sibling':
                    p.moveToNthChildOf(p2.parent(), p2._childIndex)
                elif self.which == 'prev sibling':
                    p.moveToNthChildOf(p2.parent(), p2._childIndex-1)
            else:
                raise Exception("Unknown move type "+self.which)

        elif self.type_ == 'bkmk':
            unl = self.computeUNL(p)  # before tree changes
            if self.which == 'first child':
                nd = p2.insertAsNthChild(0)
            elif self.which == 'last child':
                nd = p2.insertAsLastChild()
            elif self.which == 'next sibling':
                nd = p2.insertAfter()
            elif self.which == 'prev sibling':
                nd = p2.insertBefore()
            else:
                raise Exception("Unknown move type "+self.which)
            h = p.anyAtFileNodeName() or p.h
            while h and h[0] == '@':
                h = h[1:]
            nd.h = h
            nd.b = unl

        elif self.type_ == 'copy':

            if self.which == 'first child':
                nd = p2.insertAsNthChild(0)
                quickMove.copy_recursively(p, nd)
                # unlike p.copyTreeFromSelfTo, deepcopys p.v.u
            elif self.which == 'last child':
                nd = p2.insertAsLastChild()
                quickMove.copy_recursively(p, nd)
            elif self.which == 'next sibling':
                nd = p2.insertAfter()
                quickMove.copy_recursively(p, nd)
            elif self.which == 'prev sibling':
                nd = p2.insertBefore()
                quickMove.copy_recursively(p, nd)
            else:
                raise Exception("Unknown move type "+self.which)

        elif self.type_ in ('linkTo', 'linkFrom'):
            blc = getattr(c, 'backlinkController', None)
            if blc is None:
                g.es("Linking requires backlink.py plugin")
                return
            if self.type_ == 'linkTo':
                blc.vlink(p.v, p2.v)
            else:
                blc.vlink(p2.v, p.v)

        if self.type_ in ('bkmk', 'clone', 'copy', 'move'):
            nxt = c.vnode2position(nxt)
        elif self.type_ == 'jump':
            nxt = c.vnode2position(self.target)
        else:
            nxt = None  # linkTo / linkFrom don't move

        if nxt is not None and c.positionExists(nxt):
            c.selectPosition(nxt)

    if needs_undo:
        c.undoer.afterMoveNode(p,'Quick Move', bunch)
        c.setChanged()

    c.redraw()
</t>
<t tx="ekr.20070123061606">def checkMove (self,p,p2):

    c = self.c

    for z in p2.parents():
        if z == p:
            return False

    return (
        c.checkMoveWithParentWithWarning (p,p2,warningFlag=False) and
        c.checkMoveWithParentWithWarning (p2,p,warningFlag=False)
    )
</t>
<t tx="ekr.20070130115927.6">@frame_cmd('cut-text')
def cutText(self, event=None):
    """Invoked from the mini-buffer and from shortcuts."""
    f = self; c = f.c; w = event and event.widget
    if not w or not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i, j = w.getSelectionRange()
    # Update the widget and set the clipboard text.
    s = w.get(i, j)
    if i != j:
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    else:
        ins = w.getInsertPoint()
        i, j = g.getLine(oldText, ins)
        s = w.get(i, j)
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut', oldSel=oldSel)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        # 2011/11/14: Not used at present.
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070130115927.7">@frame_cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    """
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    """
    c = self.c
    w = event and event.widget
    wname = c.widget_name(w)
    if not w or not g.isTextWrapper(w):
        return
    if self.cursorStay and wname.startswith('body'):
        tCurPosition = w.getInsertPoint()
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    if middleButton and c.k.previousSelection is not None:
        start, end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = g.app.gui.getTextFromClipboard()
    s = g.checkUnicode(s)
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
    # Save the horizontal scroll position.
    if hasattr(w, 'getXScrollPosition'):
        x_pos = w.getXScrollPosition()
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    w.see(i + len(s) + 2)
    if wname.startswith('body'):
        if self.cursorStay:
            if tCurPosition == j:
                offset = len(s) - (j - i)
            else:
                offset = 0
            newCurPosition = tCurPosition + offset
            w.setSelectionRange(i=newCurPosition, j=newCurPosition)
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif singleLine:
        s = w.getAllText()
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else:
        pass
    # Never scroll horizontally.
    if hasattr(w, 'getXScrollPosition'):
        w.setXScrollPosition(x_pos)

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict(self):
    """Dump k.masterBindingsDict."""
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            bi = d2.get(key2)
            g.pr(f"{key2:20} {bi.commandName}")
</t>
<t tx="ekr.20070613133500">def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
</t>
<t tx="ekr.20070713075352">def scanUnknownFileType(self, s, p, ext):
    """Scan the text of an unknown file type."""
    body = ''
    if ext in ('.html', '.htm'): body += '@language html\n'
    elif ext in ('.txt', '.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += f"@language {language}\n"
    self.setBodyString(p, body + self.rootLine + s)
    for p in p.self_and_subtree():
        p.clearDirty()
    g.app.unitTestDict = {'result': True}
    return True
</t>
<t tx="ekr.20070806105859">@cmd('write-at-auto-nodes')
def writeAtAutoNodes(self, event=None):
    '''Write all @auto nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)
    c.raise_error_dialogs(kind='write')

@cmd('write-dirty-at-auto-nodes')
def writeDirtyAtAutoNodes(self, event=None):
    '''Write all dirty @auto nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20070806141607">def writeOneAtAutoNode(self, p):
    '''
    Write p, an @auto node.
    File indices *must* have already been assigned.
    Return True if the node was written successfully.
    '''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        if not p.atAutoNodeName():
            return False
        fileName = at.initWriteIvars(root, p.atAutoNodeName(),
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        if c.persistenceController:
            c.persistenceController.update_before_write_foreign_file(root)
        contents = at.writeAtAutoContents(fileName, root)
        if contents is None:
            g.es("not written:", fileName)
            at.addToOrphanList(root)
            return False
        at.replaceFile(contents, at.encoding, fileName, root,
            ignoreBlankLines=root.isAtAutoRstNode())
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 &amp; #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20070919133659">@cmd('check-external-file')
def checkExternalFile(self, event=None):
    """Make sure an external file written by Leo may be read properly."""
    c, p = self.c, self.c.p
    if not p.isAtFileNode() and not p.isAtThinFileNode():
        g.red('Please select an @thin or @file node')
        return
    fn = g.fullPath(c, p)  # #1910.
    if not g.os_path_exists(fn):
        g.red(f"file not found: {fn}")
        return
    s, e = g.readFileIntoString(fn)
    if s is None:
        g.red(f"empty file: {fn}")
        return
    #
    # Create a dummy, unconnected, VNode as the root.
    root_v = leoNodes.VNode(context=c)
    root = leoNodes.Position(root_v)
    FastAtRead(c, gnx2vnode={}).read_into_root(s, fn, root)
</t>
<t tx="ekr.20071105164407">def deleteUnvisitedNodes(self, root, redraw=True):
    """
    Delete unvisited nodes in root's subtree, not including root.

    Before Leo 5.6: Move unvisited node to be children of the 'Resurrected
    Nodes'.
    """
    at = self
    # Find the unvisited nodes.
    aList = [z for z in root.subtree() if not z.isVisited()]
    if aList:
        # new-read: Never create resurrected nodes.
            # r = at.createResurrectedNodesNode()
            # callback = at.defineResurrectedNodeCallback(r, root)
            # # Move the nodes using the callback.
            # at.c.deletePositionsInList(aList, callback)
        at.c.deletePositionsInList(aList, redraw=redraw)
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071212104050">def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            bi = d2.get(key2)
            if bi.commandName == commandName:
                bi.func = func
                d2[key2] = bi
</t>
<t tx="ekr.20080408060320.790">def selectAll(self):
    """Select all the user-editable text of the minibuffer."""
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
</t>
<t tx="ekr.20080408060320.791">def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home',  # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',  # 2011/06/07
        'set-find-node-only',  # 2011/06/07
        'set-find-suboutline-only',  # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510153327.2">def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    k.setInputState(state)
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines &amp; its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080711063656.3">def unlink(self, filename, silent=False):
    """Unlink filename from the file system.
    Give an error on failure."""
    x = self
    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error(f"can not delete {filename}", silent=silent)
    return ok
</t>
<t tx="ekr.20080711093251.3">@cmd('write-at-shadow-nodes')
def writeAtShadowNodes(self, event=None):
    '''Write all @shadow nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    val = at.writeAtShadowNodesHelper(writeDirtyOnly=False)
    c.raise_error_dialogs(kind='write')
    return val

@cmd('write-dirty-at-shadow-nodes')
def writeDirtyAtShadowNodes(self, event=None):
    '''Write all dirty @shadow nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    val = at.writeAtShadowNodesHelper(writeDirtyOnly=True)
    c.raise_error_dialogs(kind='write')
    return val
</t>
<t tx="ekr.20080711093251.5">def writeOneAtShadowNode(self, p, testing=False):
    '''
    Write p, an @shadow node.
    File indices *must* have already been assigned.
    
    testing: set by unit tests to suppress the call to at.precheck.
    '''
    at, c = self, self.c
    root = p.copy()
    x = c.shadowController
    try:
        c.endEditing()  # Capture the current headline.
        fn = p.atShadowFileNodeName()
        assert fn, p.h
        self.adjustTargetLanguage(fn)
            # A hack to support unknown extensions. May set c.target_language.
        full_path = g.fullPath(c, p)
        at.initWriteIvars(root, None,
            atShadow=True,
            defaultDirectory=g.os_path_dirname(full_path),
            forcePythonSentinels=True,
                # Force python sentinels to suppress an error message.
                # The actual sentinels will be set below.
        )
        at.default_directory = g.os_path_dirname(full_path)
            # Override.
        # Make sure we can compute the shadow directory.
        private_fn = x.shadowPathName(full_path)
        if not private_fn:
            return False
        if not testing and not at.precheck(full_path, root):
            return False
        #
        # Bug fix: Leo 4.5.1:
        # use x.markerFromFileName to force the delim to match
        # what is used in x.propegate changes.
        marker = x.markerFromFileName(full_path)
        at.startSentinelComment, at.endSentinelComment = marker.getDelims()
        if g.app.unitTesting:
            ivars_dict = g.getIvarsDict(at)
        #
        # Write the public and private files to strings.

        def put(sentinels):
            at.outputList = []
            at.sentinels = sentinels
            at.putFile(root, sentinels=sentinels)
            return '' if at.errors else ''.join(at.outputList)

        at.public_s = put(False)
        at.private_s = put(True)
        at.warnAboutOrphandAndIgnoredNodes()
        if g.app.unitTesting:
            exceptions = ('public_s', 'private_s', 'sentinels', 'outputList')
            assert g.checkUnchangedIvars(at, ivars_dict, exceptions), 'writeOneAtShadowNode'
        if not at.errors:
            # Write the public and private files.
            x.makeShadowDirectory(full_path)
                # makeShadowDirectory takes a *public* file name.
            x.replaceFileWithString(at.encoding, private_fn, at.private_s)
            x.replaceFileWithString(at.encoding, full_path, at.public_s)
        at.checkPythonCode(contents=at.private_s, fileName=full_path, root=root,)
        if at.errors:
            g.error("not written:", full_path)
            at.addToOrphanList(root)
        else:
            root.clearDirty()
        return not at.errors
    except Exception:
        at.writeException(full_path, root)
        return False
</t>
<t tx="ekr.20080711093251.7">def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        at.error(
            f"can not happen: fn: {fn} != atShadowNodeName: "
            f"{p.atShadowFileNodeName()}")
        return
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    # #889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
</t>
<t tx="ekr.20080712080505.1">def importAtShadowNode(self, fn, p):
    at = self; c = at.c; ic = c.importCommands
    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()
    # Import the outline, exactly as @auto does.
    ic.createOutline(fn, parent=p.copy(), atShadow=True)
    if ic.errors:
        g.error('errors inhibited read @shadow', fn)
    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
    # else: g.doHook('after-shadow', p = p)
    return ic.errors == 0
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080811174246.1">def languageForExtension(self, ext):
    """Return the language corresponding to the extension ext."""
    unknown = 'unknown_language'
    if ext.startswith('.'): ext = ext[1:]
    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None, 'none', 'None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None, 'none', 'None'):
            language = unknown
    else:
        language = unknown
    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20080819075811.13">def adjustTargetLanguage(self, fn):
    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""
    at = self
    c = at.c
    junk, ext = g.os_path_splitext(fn)
    if ext:
        if ext.startswith('.'): ext = ext[1:]
        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            # Use the default language, **not** 'unknown_language'
            pass
</t>
<t tx="ekr.20080827175609.39">@nobeautify

def scanAllDirectives(self,p=None):
    """
    Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.
    """
    c = self
    p = p or c.p
    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body-pane-wraps")
    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')
    d = {
        "delims":       lang_dict.get('delims'),
        "encoding":     d.get('encoding'),
        "language":     lang_dict.get('language'),
        "lineending":   d.get('lineending'),
        "pagewidth":    d.get('pagewidth'),
        "path":         d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth":     d.get('tabwidth'),
        "pluginsList":  [], # No longer used.
        "wrap":         d.get('wrap'),
    }
    return d
</t>
<t tx="ekr.20080828103146.12"># No longer used. Was called only by scanLanguageDirectives.

def scanAtRootDirectives(self, aList):
    """Scan aList for @root-code and @root-doc directives."""
    c = self
    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config, tag) and getattr(c.config, tag)
    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        if 'root-doc' in d:
            return 'doc'
        if 'root' in d:
            return 'doc' if start_in_doc else 'code'
    return None
</t>
<t tx="ekr.20080923070954.13">if forcePythonSentinels:
    # Force Python language.
    delim1, delim2, delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1, delim2, delim3 = delims
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = ""  # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:  # Emergency!
    #
    # Issue an error only if at.language has been set.
    # This suppresses a message from the markdown importer.
    if not g.app.unitTesting and at.language:
        g.trace(repr(at.language), g.callers())
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:", c.target_language)
    at.startSentinelComment = "#"  # This should never happen!
    at.endSentinelComment = ""
</t>
<t tx="ekr.20080923070954.14">at.page_width = c.page_width
at.tab_width = c.tab_width
at.default_directory = None  # 8/2: will be set later.
if c.target_language:
    c.target_language = c.target_language.lower()
delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language
at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=c)  # Init from config settings.
</t>
<t tx="ekr.20080923070954.4">def scanAllDirectives(self,
    p,
    forcePythonSentinels=False,
    importing=False,
    issuePathWarning=False,
    reading=False,
):
    '''
    Scan p and p's ancestors looking for directives,
    setting corresponding AtFile ivars.
    '''
    at, c = self, self.c
    g.app.atPathInBodyWarning = None
    &lt;&lt; set ivars &gt;&gt;
    lang_dict = {'language': at.language, 'delims': delims,}
    table = (
        ('encoding', at.encoding, g.scanAtEncodingDirectives),
        # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
        ('lineending', None, g.scanAtLineendingDirectives),
        ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
        ('path', None, c.scanAtPathDirectives),
        ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key, default, func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process.
    lineending = d.get('lineending')
    lang_dict = d.get('lang-dict')
    if lang_dict:
        delims = lang_dict.get('delims')
        at.language = lang_dict.get('language')
    else:
        # No language directive.  Look for @&lt;file&gt; nodes.
        language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
        delims = g.set_delims_from_language(language)
    at.encoding = d.get('encoding')
    at.explicitLineEnding = bool(lineending)
    at.output_newline = lineending or g.getOutputNewline(c=c)
    at.page_width = d.get('pagewidth')
    at.default_directory = d.get('path')
    at.tab_width = d.get('tabwidth')
    if not importing and not reading:
        # Don't override comment delims when reading!
        &lt;&lt; set comment strings from delims &gt;&gt;
    # For unit testing.
    d = {
        "all": all,
        "encoding": at.encoding,
        "language": at.language,
        "lineending": at.output_newline,
        "pagewidth": at.page_width,
        "path": at.default_directory,
        "tabwidth": at.tab_width,
    }
    return d
</t>
<t tx="ekr.20081001062423.9">def setDefaultDirectory(c, p, importing=False):
    """ Return a default directory by scanning @path directives."""
    if p:
        name = p.anyAtFileNodeName()
        if name:
            # An absolute path overrides everything.
            d = g.os_path_dirname(name)
            if d and g.os_path_isabs(d):
                return d
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
            # Returns g.getBaseDirectory(c) by default.
            # However, g.getBaseDirectory can return ''
    else:
        path = None
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory, g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''
    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")
    return path
</t>
<t tx="ekr.20081006100835.1"># Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
</t>
<t tx="ekr.20090110073010.1">@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090130114732.6">def __get_u(self):
    v = self
    # Wrong: return getattr(v, 'unknownAttributes', {})
    # It is does not set v.unknownAttributes, which can cause problems.
    if not hasattr(v, 'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self, val):
    v = self
    if val is None:
        if hasattr(v, 'unknownAttributes'):
            delattr(v, 'unknownAttributes')
    elif isinstance(val, dict):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc="VNode u property")
</t>
<t tx="ekr.20090214075058.9"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

def get_directives_dict(p, root=None):
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    if root:
        root_node = root[0]
    d = {}
    #
    # #1688:    legacy: Always compute the pattern.
    #           g.directives_pat is updated whenever loading a plugin.
    #
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = g.directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j &lt; len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            if word in ('root-doc', 'root-code'):
                d['root'] = val  # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0  # value not immportant
            else:
                g.es(f'{g.angleBrackets("*")} may only occur in a topmost node (i.e., without a parent)')
            break
    return d
</t>
<t tx="ekr.20090225080846.3">def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    # #1521
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors='True')
    g.doHook('after-edit', p=p)
</t>
<t tx="ekr.20090225080846.5">def writeOneAtEditNode(self, p):
    '''Write one @edit node.'''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        c.init_error_dialogs()
        if not p.atEditNodeName():
            return False
        if p.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(root, p.atEditNodeName(),
            atEdit=True,
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        contents = ''.join([s for s in g.splitLines(p.b)
            if at.directiveKind4(s, 0) == at.noDirective])
        at.replaceFile(contents, at.encoding, fileName, root)
        c.raise_error_dialogs(kind='write')
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"&lt;node: {p.h}&gt;"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090518072506.8494">def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert isinstance(stroke, str) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090616105756.3942">class backlinkController:
    """Display and edit links in leo trees"""
    @others
</t>
<t tx="ekr.20090616105756.3943">def __init__ (self,c):
    '''Ctor for backlinkController class.'''
    self.c = c
    self.c.backlinkController = self
    self.initIvars()
    self.reloadSettings()
    self.fixIDs(c)
    if Tk:
        self.ui = backlinkTkUI(self)
    elif Qt:
        self.ui = backlinkQtUI(self)
    else:
        # Fix part of #509. Ignore missing attributes.
        self.ui = g.NullObject()
    g.registerHandler('select3', self.updateTab)
    g.registerHandler('open2', self.loadLinks)
    # already missed initial 'open2' because of after-create-leo-frame, so
    self.loadLinksInt()
    self.updateTabInt()
    
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.name_levels = c.config.getInt('backlink-name-levels') or 0
</t>
<t tx="ekr.20090616105756.3944">def deleteLink(self, on, to, type_):
    """delete a link from 'on' to 'to' of type 'type_'"""

    vid = on.gnx #X unknownAttributes['_bklnk']['id']
    links = on.unknownAttributes['_bklnk']['links']

    for n,link in enumerate(links):

        on.setDirty()
        self.c.setChanged()

        if type_ == link[0] and to == link[1]:
            del links[n]
            v = self.vnode[to]
            links = v.unknownAttributes['_bklnk']['links']
            if type_ == 'S':
                type_ = 'D'
            elif type_ == 'D':
                type_ = 'S'
            for n,link in enumerate(links):
                if type_ == link[0] and link[1] == vid:
                    del links[n]
                    break
            else:
                self.showMessage("Couldn't find other side of link")
            break
    else:
        self.showMessage("Error: no such link")

    self.updateTabInt()

    # gcc = getattr(self.c, 'graphcanvasController')
    try:
        gcc = self.c.graphcanvasController
        if gcc: gcc.do_update()
    except AttributeError:
        pass
</t>
<t tx="ekr.20090616105756.3945">def deleteSet(self, enabled):
    """UI informing us that delete mode has been set to value of 'enabled'"""

    self.deleteMode = enabled
    if enabled:
        self.showMessage('Click a link to DELETE it', color='red')
    else:
        self.showMessage('Click a link to follow it')
</t>
<t tx="ekr.20090616105756.3946">def initBacklink(self, v):
    """set up a vnode to support links"""

    if '_bklnk' not in v.u:
        v.u['_bklnk'] = {}
    for entry in 'links', 'urls':
        if entry not in v.u['_bklnk']:
            v.u['_bklnk'][entry] = []

    self.vnode[v.gnx] = v
</t>
<t tx="ekr.20090616105756.3947">def initIvars(self):
    """initialize, called by __init__ and loadLinks(Int)"""

    self.linkDestination = None
    self.linkSource = None
    self.linkMark = None
    self.vnode = {}
    self.messageUsed = False
</t>
<t tx="ekr.20090616105756.3948">def linkAction(self, dir_, newChild=False):
    """link to/from current position from/to mark node"""

    if dir_ == 'url':
        self.linkUrl()
    
    elif not self.linkMark or not self.c.positionExists(self.linkMark):
        self.showMessage('Link mark not specified or no longer valid', color='red')
        return

    else: # dir_ in ['from', 'to', 'undirected']
        p = self.linkMark
        
        if newChild:
            p = self.linkMark.insertAsLastChild()
            p.h = self.c.p.h

        if dir_ == 'from':
            self.link(self.c.p, p)
        elif dir_ == 'to':
            self.link(p, self.c.p)
        else:
            self.link(p, self.c.p, 'undirected')

    self.updateTabInt()
    self.c.redraw()
</t>
<t tx="ekr.20090616105756.3949">def link(self, from_, to, type_='directed'):
    """make a link"""

    self.vlink(from_.v, to.v, type_=type_)
    from_.setDirty()
    to.setDirty()
    self.c.setChanged()

</t>
<t tx="ekr.20090616105756.3950">def vlink(self, v0, v1, type_='directed'):
    self.initBacklink(v0)
    self.initBacklink(v1)

    linkType = 'U'

    if type_ == 'directed':
        linkType = 'S'

    v0.u['_bklnk']['links'].append( (linkType, v1.gnx) )

    if type_ == 'directed':
        linkType = 'D'

    v1.u['_bklnk']['links'].append( (linkType, v0.gnx) )

    self.updateTabInt()

    # gcc = getattr(self.c, 'graphcanvasController')
    try:
        gcc = self.c.graphcanvasController
        if gcc: gcc.do_update()
    except AttributeError:
        pass

</t>
<t tx="ekr.20090616105756.3951">def linkClicked(self, selected):
    """UI informs us that link number 'selected' (zero based) was clicked"""

    if selected &gt;= len(self.dests):  # URL link
        url = self.c.p.v.u['_bklnk']['urls'][selected-len(self.dests)]
        if self.deleteMode:
            self.c.p.v.u['_bklnk']['urls'].remove(url)
            self.updateTabInt()
        else:
            self.handleURL(url.rsplit('##', 1)[0])
        return
    if self.deleteMode:
        self.deleteLink(
            self.c.p.v,
            self.dests[selected][1].v.gnx,
            self.dests[selected][0]
        )
        self.updateTabInt()
        return
    assert self.c.positionExists(self.dests[selected][1])
    self.c.selectPosition(self.dests[selected][1])
</t>
<t tx="ekr.20090616105756.3952">def linkDst(self):
    """link from current position to dest. node"""
    if not self.linkDestination or not self.c.positionExists(self.linkDestination):
        self.showMessage('Link destination not specified or no longer valid', color='red')
        return

    self.link(self.c.p, self.linkDestination)

    self.updateTabInt()
</t>
<t tx="ekr.20090616105756.3953">def linksFrom(self, v, type_='S'):
    ans = []
    if not (v.u and '_bklnk' in v.u and 'links' in v.u['_bklnk']):
        return ans

    for i in v.u['_bklnk']['links']:
        linkType, other = i
        if linkType == type_:
            ans.append(self.vnode[other])

    return ans

</t>
<t tx="ekr.20090616105756.3954">def linksTo(self, v):
    return self.linksFrom(v, type_='D')
</t>
<t tx="ekr.20090616105756.3955">def linkSrc(self):
    """link from current position to source node"""

    if not self.linkSource or not self.c.positionExists(self.linkSource):
        self.showMessage('Link source not specified or no longer valid', color='red')
        return

    self.link(self.linkSource, self.c.p)

    self.updateTabInt()
</t>
<t tx="ekr.20090616105756.3956">def linkUnd(self):
    """undirected link from current position to source node, use dest.
    if source not set."""

    source = None
    if self.linkSource and self.c.positionExists(self.linkSource):
        source = self.linkSource
    elif not self.linkDestination or not self.c.positionExists(self.linkDestination):
        self.showMessage('Link source/dest. not specified or no longer valid', color='red')
        return
    else:
        source = self.linkDestination

    self.link(source, self.c.p, type_='undirected')

    self.updateTabInt()
</t>
<t tx="ekr.20090616105756.3957">def loadLinks(self, tag, keywords):
    """load links after file opened"""
    if self.c != keywords['c']:
        return  # not our problem

    self.loadLinksInt()
</t>
<t tx="ekr.20090616105756.3958">def loadLinksInt(self):
    """load links after file opened or reload on request from UI"""

    c = self.c  # checked in loadLinks()

    self.initIvars()  # clears self.vnode

    idsSeen = set()  # just the vnodes with link info.

    # make map from linked node's ids to their vnodes
    for p in c.all_positions():
        v = p.v
        self.vnode[v.gnx] = v
        if v.u and '_bklnk' in v.u:
            idsSeen.add(v.gnx)

    for vnode in idsSeen:  # just the vnodes with link info.
        if 'links' not in self.vnode[vnode].u['_bklnk']:
            g.trace(self.vnode[vnode].u)
            # graphcanvas.py will only init x and y keys
            self.vnode[vnode].u['_bklnk']['links'] = []
        links = self.vnode[vnode].u['_bklnk']['links']
        newlinks = []  # start with empty list and include only good links
        for link in links:

            if link[1] not in self.vnode:
                # other end if missing
                lt = ('to', 'from')
                if link[0] == 'S':
                    lt = ('from', 'to')
                # use g.es rather than showMessage here
                g.error('backlink: link %s %s %s ??? lost' % (
                    lt[0], self.vnode[vnode].h, lt[1]))
                continue

            # check other end has link
            other = self.vnode[link[1]]
            if '_bklnk' not in other.u or 'links' not in other.u['_bklnk']:
                self.initBacklink(other)
            if not [
                i for i in other.u['_bklnk']['links']
                    if i[1] == vnode
            ]:
                # we are not in the other's list
                direc = {'U':'U', 'S':'D', 'D':'S'}[link[0]]
                other.u['_bklnk']['links'].append((direc, vnode))

            newlinks.append((link[0], link[1]))

        self.vnode[vnode].u['_bklnk']['links'] = newlinks

    self.showMessage('Link info. loaded on %d nodes' % len(idsSeen))
</t>
<t tx="ekr.20090616105756.3959">def mark(self):
    """Mark current position as 'mark' (called by UI)"""
    self.linkMark = self.c.p.copy()
    self.showMessage('Marked')
</t>
<t tx="ekr.20090616105756.3960">def markDst(self):
    """Mark current position as 'destination' (called by UI)"""
    self.linkDestination = self.c.p.copy()
    self.showMessage('Dest. marked')
</t>
<t tx="ekr.20090616105756.3961">def markSrc(self):
    """Mark current position as 'source' (called by UI)"""
    self.linkSource = self.c.p.copy()
    self.showMessage('Source marked')
</t>
<t tx="ekr.20090616105756.3962">def positionExistsSomewhere(self,p,root=None):
    """A local copy of c.positionExists so that when the
    failure to check p._childIndex bug is fixed, that fixing
    doesn't make backlink.py search more of the tree than it
    needs to"""

    # used by vnodePosition, not needed node there's c.vnode2position

    c = self.c ; p = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        if p == root:
            return True
        if p.hasParent():
            v = p.v
            p.moveToParent()
            # Major bug fix: 2009/1/2
            if v not in p.v.children:
                return False
        else:
            p.moveToBack()  # ???

    return False
</t>
<t tx="ekr.20090616105756.3963">def showLinksLog(self,tag,k):

    # deprecated

    if k['c'] != self.c: return  # not our problem

    p = k['new_p']
    v = p.v

    if hasattr(v, 'unknownAttributes') and '_bklnk' in v.unknownAttributes:
        i = 0
        links = v.unknownAttributes['_bklnk']['links']
        dests = []
        while i &lt; len(links):
            linkType, other = links[i]

            if other not in self.vnode:
                return
                # called before load hook?

            otherV = self.vnode[other]
            otherP = self.vnodePosition(otherV)
            if not self.c.positionExists(otherP):
                g.es('Deleting lost link')
                del links[i]
            else:
                i += 1
                dests.append((linkType, otherP))
        if dests:
            g.es("- link info -")
            for i in dests:
                g.es("%s %s" %({'S':'-&gt;','D':'&lt;-','U':'--'}[i[0]],
                    i[1].h))
</t>
<t tx="ekr.20090616105756.3964">def showMenu(self,tag,k):

    if k['c'] != self.c:
        return # not our problem
    p = k['p']
    self.c.selectPosition(p)
    v = p.v
    c = self.c

    # Create the menu.
    menu = Tk.Menu(None,tearoff=0,takefocus=0)

    commands = [
        (True, 'Mark as link source', self.markSrc),
        (True, 'Mark as link dest.', self.markDst),
        (True, 'Link to source', self.linkSrc),
        (True, 'Link to dest.', self.linkDst),
        (True, 'Undirected link', self.linkUnd),
        (True, 'Rescan links', self.loadLinksInt),
    ]
    if hasattr(v, 'unknownAttributes') and '_bklnk' in v.unknownAttributes:
        i = 0
        links = v.unknownAttributes['_bklnk']['links']
        dests = []
        while i &lt; len(links):
            linkType, other = links[i]
            otherV = self.vnode[other]
            otherP = self.vnodePosition(otherV)
            if not self.c.positionExists(otherP):
                g.es('Deleting lost link')
                del links[i]
            else:
                i += 1
                dests.append((linkType, otherP))
        if dests:
            smenu = Tk.Menu(menu,tearoff=0,takefocus=1)
            for i in dests:
                def goThere(where = i[1]): c.selectPosition(where)
                c.add_command(menu,
                    label={'S':'-&gt;','D':'&lt;-','U':'--'}[i[0]] + i[1].h,
                    underline=0,command=goThere)
                def delLink(on=v,
                    to=i[1].v.unknownAttributes['_bklnk']['id'],
                    type_=i[0]): self.deleteLink(on,to,type_)
                c.add_command(smenu,
                    label={'S':'-&gt;','D':'&lt;-','U':'--'}[i[0]] + i[1].h,
                    underline=0,command=delLink)
            menu.add_cascade(label='Delete link', menu=smenu,underline=1)
            menu.add_separator()

    for command in commands:
        available, text, com = command
        if not available:
            continue
        c.add_command(menu,label=text,
            underline=0,command=com)
    #
    # Show the menu.
    event = k['event']
    g.app.gui.postPopupMenu(self.c, menu, event.x_root,event.y_root)
</t>
<t tx="ekr.20090616105756.3965">def showMessage(self, msg, optional=False, color='black'):
    """Show the message, but don't overwrite earlier important
    message if this message is optional"""

    if self.messageUsed and optional:
        return
    if not self.messageUsed and not optional:
        self.messageUsed = True
    self.ui.showMessage(msg, color=color)
</t>
<t tx="ekr.20090616105756.3966">def swap(self):
    """Swap current pos. w. mark"""
    if not self.linkMark or not self.c.positionExists(self.linkMark):
        self.showMessage('Link mark not specified or no longer valid', color='red')
        return
    p = self.linkMark
    self.linkMark = self.c.p.copy()
    self.c.selectPosition(p)
</t>
<t tx="ekr.20090616105756.3967">def updateTab(self,tag,k):
    """called by leo select position hook"""
    if k['c'] != self.c: return  # not our problem

    self.updateTabInt()
</t>
<t tx="ekr.20090616105756.3968">def updateTabInt(self):
    """called on new position (leo hook) and when links added / deleted"""
    c = self.c
    p = c.p
    v = p.v
    self.messageUsed = False
    self.ui.enableDelete(False)
    self.deleteMode = False
    self.showMessage('', optional=True)
    try:
        if v.u['_bklnk']['urls']:
            self.ui.enableDelete(True)
    except KeyError:
        pass
    texts = []
    if (v.u and '_bklnk' in v.u and 'links' in v.u['_bklnk']):
        links = v.u['_bklnk']['links']
        dests = []
        self.dests = dests
        for data in links[:]: # Must use a copy.
            linkType, other = data
            try:
                otherV = self.vnode[other]
                otherP = self.vnodePosition(otherV)
                dests.append((linkType, otherP))
            except KeyError:
                self.showMessage('Lost link(s) deleted', other, color='red')
                links.remove(data)
            except Exception:
                g.es_exception()
        if dests:
            self.ui.enableDelete(True)
            self.showMessage('Click a link to follow it', optional=True)
            # pylint: disable=cell-var-from-loop
            for i in dests:

                if i[1] is None: # destination node is deleted
                    continue

                def goThere(where = i[1]):
                    c.selectPosition(where)

                name = i[1].h
                # add self.name_levels worth of ancestor names on left or right
                nl = self.name_levels
                nl_src = i[1]
                while nl != 0:
                    nl_src = nl_src.parent()
                    if not nl_src:
                        break
                    nl_txt = nl_src.h
                    if nl &lt; 0:
                        nl += 1
                        name = nl_txt + ' &gt; ' + name
                    else:
                        nl -= 1
                        name += ' &lt; ' + nl_txt
                txt = {'S':'-&gt;','D':'&lt;-','U':'--'}[i[0]] + ' ' + name
                texts.append(txt)
        urls = []
        for url in v.u['_bklnk'].get('urls', []):
            url = url.rsplit('##', 1)
            if len(url) &gt; 1:
                url, description = url
            else:
                url, description = url[0], ''
            if description.strip():
                description = "%s %s" % (description, url)
            else:
                description = url
            url = url.replace('--&gt;', ' &gt; ')
            urls.append((description, url))
        texts.extend(urls)
    self.ui.loadList(texts)

</t>
<t tx="ekr.20090616105756.3969">def vnodePosition(self,v):
    """Return a position for vnode v, if there is one"""
    return self.c.vnode2position(v)
</t>
<t tx="ekr.20090712050729.6017">def promptForDangerousWrite(self, fileName, message=None):
    """Raise a dialog asking the user whether to overwrite an existing file."""
    at, c, root = self, self.c, self.root
    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None, True)
    if at.cancelFlag:
        assert at.canCancelFlag
        return False
    if at.yesToAll:
        assert at.canCancelFlag
        return True
    if root and root.h.startswith('@auto-rst'):
        # Fix bug 50: body text lost switching @file to @auto-rst
        # Refuse to convert any @&lt;file&gt; node to @auto-rst.
        d = root.v.at_read if hasattr(root.v, 'at_read') else {}
        aList = sorted(d.get(fileName, []))
        for h in aList:
            if not h.startswith('@auto-rst'):
                g.es('can not convert @file to @auto-rst!', color='red')
                g.es('reverting to:', h)
                root.h = h
                c.redraw()
                return False
    if message is None:
        message = (
            f"{g.splitLongFileName(fileName)}\n"
            f"{g.tr('already exists.')}\n"
            f"{g.tr('Overwrite this file?')}")
    result = g.app.gui.runAskYesNoCancelDialog(c,
        title='Overwrite existing file?',
        yesToAllMessage="Yes To &amp;All",
        message=message,
        cancelMessage="&amp;Cancel (No To All)",
    )
    if at.canCancelFlag:
        # We are in the writeAll logic so these flags can be set.
        if result == 'cancel':
            at.cancelFlag = True
        elif result == 'yes-to-all':
            at.yesToAll = True
    return result in ('yes', 'yes-to-all')
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding(self, event):

    c, k, state = self.c, self, self.unboundKeyAction
    stroke, w = event.stroke, event.w
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    #
    # #1757: Always insert plain keys in the body.
    #        Valid because mode bindings have already been handled.
    if (
        k.isPlainKey(stroke)
        and w == c.frame.body.widget
        and state in ('insert', 'overwrite')
    ):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        bi = k.getBindingHelper(key, name, stroke, w)
        if bi:
            return bi
    return None
</t>
<t tx="ekr.20091230094319.6244">def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    #
    # #1757: Leo's default vim bindings make heavy use of modes.
    #        Retain these traces!
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        if trace: g.trace(state, 'k.handleInputShortcut', stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            if trace: g.trace(state, 'k.handleMiniBindings', stroke)
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, 'k.isPlain: getArg', stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, f"{stroke.s!r}: getArg", stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        if trace: g.trace(state, 'k.getFileName', stroke)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        if val != 'do-standard-keys':
            handler = k.state.handler and k.state.handler.__name__ or '&lt;no handler&gt;'
            if trace: g.trace(state, 'k.callStateFunction:', handler, stroke)
            return True
        return False
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            if trace: g.trace(state, 'k.generalModeHandler', stroke)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    if trace:
        handler_name = handler and handler.__name__ or '&lt;no handler&gt;'
        g.trace(state, 'handler:', handler_name, stroke)
    return True
</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20100103100944.5396">class notetextedit(QTextEdit):

    (Bold, Italic, Pre, List, Remove,
     Plain, Code, H1, H2, H3, Anchor,Save) = range(12)

    @others
</t>
<t tx="ekr.20100103100944.5397">def __init__(self, get_markdown, save, parent=None):
    super().__init__(parent)
    self.save = save
    self.setLineWrapMode(QTextEdit.WidgetWidth)
    self.setTabChangesFocus(True)
    self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
    self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    self.setMinimumWidth(300)
    self.setMouseTracking(True)
    font = QFont()
    font.setPointSize(10)
    font.setFamily("helvetica")
    document = self.document()
    document.setDefaultFont(font)
    self.font = font
    document.setDefaultStyleSheet(
        "pre{margin-top:0px; margin-bottom:0px} li{margin-top:0px; margin-bottom:0px}")
    QTimer.singleShot(0, get_markdown)
</t>
<t tx="ekr.20100103100944.5398">def focusOutEvent__(self, event):
    #print "focus out"
    self.focusout()

</t>
<t tx="ekr.20100103100944.5399">def focusInEvent__(self, event):
    self.focusin()

</t>
<t tx="ekr.20100103100944.5400">def toggleItalic(self):
    if self.which_header():
        return
    #self.setFontItalic(not self.fontItalic())
    italic = self.fontItalic()
    cursor = self.textCursor()
    char_format = QTextCharFormat()
    char_format.setFont(self.font)
    char_format.setFontItalic(not italic)
    cursor.setCharFormat(char_format)

</t>
<t tx="ekr.20100103100944.5401">def toggleUnderline(self):
    #not in use, markdown doesn't support
    self.setFontUnderline(not self.fontUnderline())

</t>
<t tx="ekr.20100103100944.5402">def make_plain_text(self):
    cursor = self.textCursor()

    char_format = QTextCharFormat()
    char_format.setFont(self.font)

    cursor.setCharFormat(char_format)

    block_format = QTextBlockFormat()
    block_format.setNonBreakableLines(False)
    cursor.setBlockFormat(block_format)

</t>
<t tx="ekr.20100103100944.5403">def make_pre_block(self):
    cursor = self.textCursor()
    block_format = cursor.blockFormat()
    if block_format.nonBreakableLines():
        block_format.setNonBreakableLines(False)
        cursor.setBlockFormat(block_format)
        char_format = QTextCharFormat()
        char_format.setFontFixedPitch(False)
        cursor.setCharFormat(char_format)
    else:
        block_format.setNonBreakableLines(True)
        cursor.setBlockFormat(block_format)

        char_format = QTextCharFormat()
        char_format.setFontFixedPitch(True)
        cursor.setCharFormat(char_format)

</t>
<t tx="ekr.20100103100944.5404">def toggleBold(self):
    #self.setFontWeight(QFont.Normal if self.fontWeight() &gt; QFont.Normal else QFont.Bold)
    if self.which_header():
        return
    bold = self.fontWeight() &gt; QFont.Normal
    cursor = self.textCursor()
    char_format = QTextCharFormat()
    char_format.setFont(self.font)
    char_format.setFontWeight(QFont.Normal if bold else QFont.Bold)
    cursor.setCharFormat(char_format)

</t>
<t tx="ekr.20100103100944.5405">def toggleCode(self):
    if self.which_header():
        return
    cursor = self.textCursor()
    #if not cursor.hasSelection():
    #    return

    char_format = cursor.charFormat()

    if char_format.fontFixedPitch():
        # didn't do exhaustive testing but appear to need both statements
        char_format.setFontFixedPitch(False)
        char_format.setFontFamily("helvetica")
    else:
        char_format.setFontFixedPitch(True)
        char_format.setFontFamily("courier")

    char_format.setFontItalic(False)
    char_format.setFontWeight(QFont.Normal)

    cursor.setCharFormat(char_format)

</t>
<t tx="ekr.20100103100944.5406">def create_anchor(self):
    cursor = self.textCursor()
    if not cursor.hasSelection():
        return
    text = cursor.selectedText()
    if text.startswith('http://'):
        text = '&lt;a href="{0}"&gt;{1}&lt;/a&gt; '.format(text, text[7:])
    else:
        text = '&lt;a href="http://{0}"&gt;{0}&lt;/a&gt; '.format(text)
    #
    # The below works but doesn't pick up highlighting of an anchor
    # would have to do the underlining and blue color
        #format = QTextCharFormat()
        #format.setAnchor(True)
        #format.setAnchorHref(text)
        #cursor.setCharFormat(format)
        #self.setTextCursor(cursor)
    #
    # This also works and generates highlighting
    cursor.deleteChar()
    cursor.insertHtml(text) # also self.insertHtml should work

</t>
<t tx="ekr.20100103100944.5407">def create_list(self):
    cursor = self.textCursor()
    if not cursor.hasSelection():
        return
    cursor.createList(QTextListFormat.ListDecimal)

</t>
<t tx="ekr.20100103100944.5408">def make_heading(self, heading):
    # not finished
    cursor = self.textCursor()
    cursor.select(QTextCursor.BlockUnderCursor) #QTextCursor.LineUnderCursor

    char_format = QTextCharFormat()
    #font = self.font this is a problem  because it changes self.font gets changed below
    font = QFont()
    font.setFamily("helvetica")
    font.setPointSize({1:20, 2:15, 3:12}[heading])
    font.setBold(True)
    char_format.setFont(font)

    cursor.setCharFormat(char_format)

</t>
<t tx="ekr.20100103100944.5409">def sizeHint(self): # this makes the text box taller when launched than if I don't have it
    return QSize(self.document().idealWidth() + 5, self.maximumHeight())

</t>
<t tx="ekr.20100103100944.5410">def contextMenuEvent(self, event): # this catches the context menu right click
    self.textEffectMenu()

</t>
<t tx="ekr.20100103100944.5411">def keyPressEvent__(self, event):
    # needed because text edit is not going to recognize short cuts because will do something with control key
    # not needed if have global shortcuts
    if event.modifiers() &amp; Qt.ControlModifier:
        handled = False
        if event.key() == Qt.Key_A:
            self.create_anchor()
            handled = True
        elif event.key() == Qt.Key_B:
            self.toggleBold()
            handled = True
        elif event.key() == Qt.Key_I:
            self.toggleItalic()
            handled = True
        #elif event.key() == Qt.Key_K:
            #self.colorMenu()
            #handled = True
        elif event.key() == Qt.Key_M:
            self.textEffectMenu()
            handled = True
        elif event.key() == Qt.Key_P:
            self.make_plain_text()
            handled = True
        elif event.key() == Qt.Key_Z:
            self.make_pre_block()
            handled = True
        elif event.key() == Qt.Key_U:
            self.toggleUnderline()
            handled = True
        if handled:
            event.accept()
            return

    QTextEdit.keyPressEvent(self, event)

</t>
<t tx="ekr.20100103100944.5412">def fontFixedPitch(self):
    cursor = self.textCursor()
    format = cursor.charFormat()
    return format.fontFixedPitch()

</t>
<t tx="ekr.20100103100944.5413">def which_header(self):
    cursor = self.textCursor()
    char_format = cursor.charFormat()
    ps = char_format.font().pointSize()
    return {20:'H1', 15:'H2', 12:'H3'}.get(ps)


</t>
<t tx="ekr.20100103100944.5414">def textEffectMenu(self):
    # format = self.currentCharFormat()
    # cursor = self.textCursor()
    # blockformat = cursor.blockFormat()
    menu = QMenu("Text Effect")
    for text, shortcut, data, checked in (
            ("&amp;Bold", "Ctrl+B", notetextedit.Bold,
             self.fontWeight() &gt; QFont.Normal),
            ("&amp;Italic", "Ctrl+I", notetextedit.Italic,
             self.fontItalic()),
            ("&amp;Monospaced", None, notetextedit.Code,
             self.fontFixedPitch())
            ):

        action = menu.addAction(text, self.setTextEffect)
        #if shortcut is not None:
            #action.setShortcut(QKeySequence(shortcut)) # becau
        action.setData(QVariant(data))
        action.setCheckable(True)
        action.setChecked(checked)

    menu.addSeparator()

    action = menu.addAction("Anchor", self.setTextEffect)
    action.setData(notetextedit.Anchor)

    action = menu.addAction("Code Block", self.setTextEffect)
    action.setData(notetextedit.Pre)

    action = menu.addAction("Numbered List", self.setTextEffect)
    action.setData(notetextedit.List)

    header_menu = QMenu("Header")
    action = header_menu.addAction('H1', self.setTextEffect)
    action.setData(notetextedit.H1)
    action.setCheckable(True)
    action.setChecked(self.which_header()=='H1')

    action = header_menu.addAction('H2', self.setTextEffect)
    action.setData(notetextedit.H2)
    action.setCheckable(True)
    action.setChecked(self.which_header()=='H2')

    action = header_menu.addAction('H3', self.setTextEffect)
    action.setData(notetextedit.H3)
    action.setCheckable(True)
    action.setChecked(self.which_header()=='H3')

    action = menu.addAction("Remove All Formatting", self.setTextEffect)
    action.setData(notetextedit.Remove)

    menu.addMenu(header_menu)

    menu.addSeparator()

    action = menu.addAction("Save", self.setTextEffect)
    action.setData(notetextedit.Save)

    self.ensureCursorVisible()
    menu.exec_(self.viewport().mapToGlobal(self.cursorRect().center()))

</t>
<t tx="ekr.20100103100944.5415">def setTextEffect(self):
    action = self.sender()
    if action is not None and isinstance(action, QAction):
        what = action.data().toInt()[0]
        if what == notetextedit.Bold:
            self.toggleBold()

        elif what == notetextedit.Italic:
            self.toggleItalic()

        elif what == notetextedit.Code:
            self.toggleCode()

        elif what == notetextedit.Anchor:
            self.create_anchor()

        elif what == notetextedit.Pre:
            self.make_pre_block()

        elif what == notetextedit.Remove:
            self.make_plain_text()

        elif what == notetextedit.List:
            self.create_list()

        elif what == notetextedit.H1:
            self.make_heading(1)

        elif what == notetextedit.H2:
            self.make_heading(2)

        elif what == notetextedit.H3:
            self.make_heading(3)

        elif what == notetextedit.Save:
            self.save()

</t>
<t tx="ekr.20100103100944.5416">def mouseMoveEvent(self, event):
    #print "mouseMoveEvent"
    pos = event.pos()
    anch = self.anchorAt(pos)
    self.viewport().setCursor(
        Qt.PointingHandCursor if anch else Qt.IBeamCursor)
    QTextEdit.mouseMoveEvent(self, event) #? recursion

</t>
<t tx="ekr.20100103100944.5417">def mouseReleaseEvent(self, event):
    #print("mouseReleaseEvent")
    pos = event.pos()
    url = self.anchorAt(pos)
    if url:
        if not url.startswith('http://'): #linux seems to need this
            url = 'http://{0}'.format(url)
        webbrowser.open(url, new=2, autoraise=True)
    else:
        QTextEdit.mouseReleaseEvent(self,event)
</t>
<t tx="ekr.20100103100944.5418">def insertFromMimeData(self, source):
    # not sure really necessary since it actually appears to paste URLs correctly
    # I am stripping the http
    print("Paste")
    text = source.text()
    if len(text.split())==1 and (text.startswith('http://') or 'www' in text or '.com' in text or '.html' in text):
        if text.startswith('http://'):
            text = '&lt;a href="{0}"&gt;{1}&lt;/a&gt; '.format(text, text[7:])
        else:
            text = '&lt;a href="http://{0}"&gt;{0}&lt;/a&gt; '.format(text)
        self.insertHtml(text)
    else:
        QTextEdit.insertFromMimeData(self, source)

</t>
<t tx="ekr.20100103100944.5419">def toMarkdown(self):
    references = ''
    i = 1
    doc = ''
    block = self.document().begin() # block is like a para; text fragment is sequence of same char format
    while block.isValid():
        #print "block=",block.text()
        if block.blockFormat().nonBreakableLines():
            doc += '    '+block.text()+'\n'
        #elif block.textList():
            #textList = block.textList()
            #print block.textList().count()
            #print block.textList().itemText(block)
            #print block.textList().itemNumber(block)
            #print block.textList().item(block.textList().itemNumber(block)).text()
            #doc += textList.itemText(block) + ' ' + textList.item(textList.itemNumber(block)).text() + '\n\n'
        else:
            if block.textList():
                doc += '  '+block.textList().itemText(block) + ' '
            # para = QString()
            para = ''
            iterator = block.begin()
            while iterator != block.end():
                fragment = iterator.fragment()
                if fragment.isValid():
                    char_format = fragment.charFormat()
                    # pylint: disable=no-member
                    # EKR: I'm not sure whether this warning is valid.
                    # I'm going to kill it because this is an experimental plugin.
                    text = Qt.escape(fragment.text())
                        # turns chars like &lt; into entities &amp;lt;
                    font_size = char_format.font().pointSize()
                    # a fragment can only be an anchor, italics or bold
                    if char_format.isAnchor():
                        ref = text if text.startswith('http://') else 'http://{0}'.format(text)
                        # too lazy right now to check if URL has already been referenced but should
                        references += "  [{0}]: {1}\n".format(i,ref)
                        text = "[{0}][{1}]".format(text,i)
                        i+=1
                    elif font_size &gt; 10:
                        if font_size &gt; 15:
                            text = '#{0}'.format(text)
                        elif font_size &gt; 12:
                            text = '##{0}'.format(text)
                        else:
                            text = '###{0}'.format(text)
                    elif char_format.fontFixedPitch(): #or format.fontFamily=='courier':
                        text = QString("`%1`").arg(text)
                    elif char_format.fontItalic():
                        text = QString("*%1*").arg(text)
                    elif char_format.fontWeight() &gt; QFont.Normal:
                        #font-weight:600; same as for an H1;
                        #H1 font-size:xx-large; H1 20; H2 15 H3 12
                        text = QString("**%1**").arg(text)

                    para += text
                iterator += 1
            doc += para+'\n\n'
        block = block.next()
    return doc+references

</t>
<t tx="ekr.20100122130101.6174">def deleteTnodeList(self, p):  # AtFile method.
    """Remove p's tnodeList."""
    v = p.v
    if hasattr(v, "tnodeList"):
        if False:  # Not an error, but a useful trace.
            g.blue("deleting tnodeList for " + repr(v))
        delattr(v, "tnodeList")
        v._p_changed = True
</t>
<t tx="ekr.20100203050306.5937">def create_temp_file(self, c, ext, p):
    """
    Create the file used by open-with if necessary.
    Add the corresponding ExternalFile instance to self.files
    """
    path = self.compute_temp_file_path(c, p, ext)
    exists = g.os_path_exists(path)
    # Compute encoding and s.
    d2 = c.scanAllDirectives(p)
    encoding = d2.get('encoding', None)
    if encoding is None:
        encoding = c.config.default_derived_file_encoding
    s = g.toEncodedString(p.b, encoding, reportErrors=True)
    # Write the file *only* if it doesn't exist.
    # No need to read the file: recomputing s above suffices.
    if not exists:
        try:
            with open(path, 'wb') as f:
                f.write(s)
                f.flush()
        except IOError:
            g.error(f"exception creating temp file: {path}")
            g.es_exception()
            return None
    # Add or update the external file entry.
    time = self.get_mtime(path)
    self.files = [z for z in self.files if z.path != path]
    self.files.append(ExternalFile(c, ext, p, path, time))
    return path
</t>
<t tx="ekr.20100224050618.11547">def isFileLike(self, s):
    """Return True if s has file-like sentinels."""
    at = self; tag = "@+leo"
    s = g.checkUnicode(s)
    i = s.find(tag)
    if i == -1:
        return True  # Don't use the cache.
    j, k = g.getLine(s, i)
    line = s[j:k]
    valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
    return not isThin
</t>
<t tx="ekr.20100507084415.5760">def scanAtRootDirectives(aList):
    """Scan aList for @root directives."""
    for d in aList:
        s = d.get('root')
        if s is not None:
            i, mode = g.scanAtRootOptions(s, 0)
            return mode
    return None
</t>
<t tx="ekr.20100803073751.5817">def createResurrectedNodesNode(self):
    """Create a 'Resurrected Nodes' node as the last top-level node."""
    at = self; c = at.c; tag = 'Resurrected Nodes'
    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()
    # Create the node after last if it doesn't exist.
    if last.h == tag:
        p = last
    else:
        p = last.insertAfter()
        p.setHeadString(tag)
    p.expand()
    return p
</t>
<t tx="ekr.20100803073751.5818">def defineResurrectedNodeCallback(self, r, root):
    """Define a callback that moves node p as r's last child."""

    def callback(p, r=r.copy(), root=root):
        """The resurrected nodes callback."""
        child = r.insertAsLastChild()
        child.h = f"From {root.h}"
        v = p.v
        # new code: based on vnodes.
        for parent_v in v.parents:
            assert isinstance(parent_v, leoNodes.VNode), parent_v
            if v in parent_v.children:
                childIndex = parent_v.children.index(v)
                v._cutLink(childIndex, parent_v)
                v._addLink(len(child.v.children), child.v)
            else:
                # This would be surprising.
                g.trace('**already deleted**', parent_v, v)
        if not g.unitTesting:
            g.error('resurrected node:', v.h)
            g.blue('in file:', root.h)

    return callback
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101022124309.6132">def checkOpenDirectory(c):
    if c.openDirectory != c.frame.openDirectory:
        g.error(
            f"Error: c.openDirectory != c.frame.openDirectory\n"
            f"c.openDirectory: {c.openDirectory}\n"
            f"c.frame.openDirectory: {c.frame.openDirectory}")
    if not g.os_path_isabs(c.openDirectory):
        g.error(f"Error: relative c.openDirectory: {c.openDirectory}")
</t>
<t tx="ekr.20101110092416.5700">class node_with_parent:

    @others
</t>
<t tx="ekr.20101110092416.5702">def set_parent(self, node):
    self.mparent = node
</t>
<t tx="ekr.20101110092416.5704">def parent(self):
    return self.mparent
</t>
<t tx="ekr.20101110092416.5722">class leo_file(LeoNode):
    """Leo specific class representing a file."""

    @others
</t>
<t tx="ekr.20101110092416.5724">def headString(self):
    return "[[This is the file root]]"
</t>
<t tx="ekr.20101110092416.5726">def parent(self):
    return None
</t>
<t tx="ekr.20101110092416.5728">def empty(self, file):
    pass
</t>
<t tx="ekr.20101110092416.5730">def find_panel_settings(self, file):
    self.mark(file, "find_string", self.empty, newline=False)
    self.mark(file, "change_string", self.empty, newline=False)
</t>
<t tx="ekr.20101110092416.5732">def gen(self, file):
    global error_count
    error_count = 0
    file.write('&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n')
    self.mark(file, "leo_file", self.gen1)
</t>
<t tx="ekr.20101110092416.5734">def gen1(self, file):
    self.header(file)

    # This is a shortcut.
    file.write("""&lt;globals body_outline_ratio="0.5"&gt;
&lt;global_window_position top="0" left="2" height="400" width="700"/&gt;
&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
    """)
    self.mark(file, "preferences", self.preferences)
    self.mark(file, "find_panel_settings", self.find_panel_settings)
    if debug:
        global vnode_count
        vnode_count = 0
    self.mark(file, "vnodes", self.gen_vnodes)
    self.mark(file, "tnodes", self.gen_tnodes)
</t>
<t tx="ekr.20101110092416.5736">def gen_tnodes(self, file):
    for child in self.children:
        child.gen_tnodes(file)
</t>
<t tx="ekr.20101110092416.5738">def gen_vnodes(self, file):
    if debug:
        global allvnodes, vnode_stack
        allvnodes = {file:None}
        vnode_stack = []
    for child in self.children:
        child.gen_vnodes(file)
</t>
<t tx="ekr.20101110092416.5740">def header(self, file):
    self.mark_with_attributes_short(file, "leo_header",
                              (("file_format", "1"),
                               ("tnodes", repr(self.nr_tnodes())),
                               ("max_tnode_index", repr(self.max_tnode_index())),
                               ("clone_windows", "0")))
</t>
<t tx="ekr.20101110092416.5742">def max_tnode_index(self):
    return leo_node.count
</t>
<t tx="ekr.20101110092416.5744">def nr_tnodes(self):
    return leo_node.count
</t>
<t tx="ekr.20101110092416.5746">def preferences(self, file):
    pass
</t>
<t tx="ekr.20101110092416.5748">def sss(self, file):
    file.write("sss")
</t>
<t tx="ekr.20101110092416.5749">class leo_node(LeoNode, node_with_parent):
    """
    Leo specific class representing a node.

    These nodes correspond to tnodes in LEO.
    They have a headline and a body.

    They also represent the (only) vnode in an outline without clones.

    """
    __super_leo_node = LeoNode
    count = 0
    @others
</t>
<t tx="ekr.20101110092416.5751">def __init__(self, headline='', body=''):
    super().__init__()
    leo_node.count += 1
    self.nr = leo_node.count
    self.headline =  headline
    self.body = body
</t>
<t tx="ekr.20101110092416.5753">def bodyString(self, body):
    return self.body
</t>
<t tx="ekr.20101110092416.5755">def gen_tnodes(self, file):
    self.mark_with_attributes(file, "t", (
        ("tx", "T" + repr(self.nr)),
        ), self.gen_tnodes1, newline=False)
    for child in self.children:
        child.gen_tnodes(file)
</t>
<t tx="ekr.20101110092416.5757">def gen_tnodes1(self, file):
    self.write_body_escaped(file)
</t>
<t tx="ekr.20101110092416.5759">def gen_vnodes(self, file):
    attributes = [("t", "T" + repr(self.nr))]
    if debug:
        # For debugging, make sure that we are not getting
        # cyclic references.
        # Also number all nodes for easier error hunting.
        vnode_stack.append(self)
        if self in allvnodes:
            print("Fix this; This is an endless recursive call in leo_interface.leo_node.gen_vnodes")
            x = vnode_stack[:]
            x.reverse()
            for i in x:
                print(i.headline)
            import pdb; pdb.set_trace()
            return
        global vnode_count
        attributes.append(('model_node_number', repr(vnode_count)))
        vnode_count += 1
        allvnodes[self]=None
    self.mark_with_attributes(file, "v", attributes, self.gen_vnodes1)
    if debug:
        del allvnodes[self]
        vnode_stack.pop()
</t>
<t tx="ekr.20101110092416.5761">def gen_vnodes1(self, file):
    self.mark(file, "vh", self.write_headline_escaped, newline=False)
    for child in self.children:
        child.gen_vnodes(file)
</t>
<t tx="ekr.20101110092416.5763">def headString(self):
    return self.headline
</t>
<t tx="ekr.20101110092416.5765">def set_body(self, body):
    self.body = body
</t>
<t tx="ekr.20101110092416.5767">def set_headline(self, headline):
    self.headline = headline
</t>
<t tx="ekr.20101110092416.5769">def write_body_escaped(self, file):
    file.write(escape(self.body.encode("UTF-8")))

</t>
<t tx="ekr.20101110092416.5771">def write_headline(self, file):
    file.write(self.headline)
</t>
<t tx="ekr.20101110092416.5773">def write_headline_escaped(self, file):
    file.write(escape(self.headline.encode("UTF-8")))
</t>
<t tx="ekr.20101110092416.5774">class leo_clone(node_with_parent):
    """
    Class representing a clone.

    The (only) data of a clone is the reference to a leo_node.

    When you encounter the first clone of a set of clones, generate
    a leo_node. The second clone should then reference this leo_node,
    and contain no other data.

    Since clones are indistinguishable, there is really not much to do in
    this class.
    """

    @others
</t>
<t tx="ekr.20101110092416.5776">def __init__(self, orig):
    self.orig = orig
    self.mparent = None
</t>
<t tx="ekr.20101110092416.5778">def gen_vnodes(self, file):
    self.orig.gen_vnodes(file)
    # There is nothing new to do here;
    # just repeat what we did when we encountered
    # the first clone.
</t>
<t tx="ekr.20101110092416.5780">def gen_tnodes(self, file):
    pass
    # the tnodes are generated by the Leo_node

</t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20110110105526.5469">class pluginController:

    @others
</t>
<t tx="ekr.20110110105526.5470">def __init__ (self,c):
    self.c = c
    ib_w = self.c.frame.iconBar.w
    action = QAction('Upload', ib_w)
    self.c.frame.iconBar.add(qaction = action, command = self.upload)


</t>
<t tx="ekr.20110110105526.5471">def upload (self,event=None):
    c = self.c ; p = c.p

    g.es("upload started")
    p = g.findTopLevelNode(c, '@data ftp')
    if p:
        files = json.loads(p.b)

        # credentials - array of (host, pass) of server,
        # to while the files must be uploaded I suggest that the locations must be the same.
        credentials = files[0]

        for element in credentials:

            g.es(element[0])
            ftp = FTP(element[0])
            ftp.login(element[1], element[2])
            &lt;&lt;upload all the modified files&gt;&gt;

            ftp.quit()
            p.b = json.dumps(files)

        g.es("Upload complete")
</t>
<t tx="ekr.20110110105526.5472">@c
for i in range(1, len(files)):

    file = files[i]

    n = len(file)
    if n &lt; 3:
        file.append(-1)

    time = os.path.getmtime(file[0])
    if time != file[2]:
        files[i][2] = time
        g.es(files[i][0])
        FH = open(files[i][0],"rb")
        ftp.storbinary('STOR ' + files[i][1], FH)
        FH.close()
</t>
<t tx="ekr.20110202111105.15439">def showStateCursor(self, state, w):
    pass
</t>
<t tx="ekr.20110209093958.15411">def setEditingState(self):
    k = self; state = k.defaultEditingAction
    k.setInputState(state)
</t>
<t tx="ekr.20110209093958.15413">def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default-editing-state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace(f"ignoring default_editing_state: {action}")
        action = 'insert'
    self.defaultEditingAction = action
</t>
<t tx="ekr.20110512212836.14469">def exit(self):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    if trace: g.trace('(AutoCompleterClass)')
    c, p, u = self.c, self.c.p, self.c.undoer
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    newText = w.getAllText()
    if p.b == newText:
        return
    bunch = u.beforeChangeBody(p)
    p.v.b = newText  # p.b would cause a redraw.
    u.afterChangeBody(p, 'auto-completer', bunch)

finish = exit
abort = exit
</t>
<t tx="ekr.20110605040658.17005">def check_event(self, event):
    """Check an event object."""
    # c = self
    from leo.core import leoGui

    if not event:
        return
    stroke = event.stroke
    got = event.char
    if g.unitTesting:
        return
    if stroke and (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1):
        expected = event.char
            # Alas, Alt and Ctrl bindings must *retain* the char field,
            # so there is no way to know what char field to expect.
    else:
        expected = event.char
            # disable the test.
            # We will use the (weird) key value for, say, Ctrl-s,
            # if there is no binding for Ctrl-s.
    if not isinstance(event, leoGui.LeoKeyEvent):
        if g.app.gui.guiName() not in ('browser', 'console', 'curses'):  # #1839.
            g.trace(f"not leo event: {event!r}, callers: {g.callers(8)}")
    if expected != got:
        g.trace(f"stroke: {stroke!r}, expected char: {expected!r}, got: {got!r}")
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17875" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d32397103752e">def drawNode(self, p, parent_item):
    """Draw the node p."""
    c = self.c
    v = p.v
    # Allocate the QTreeWidgetItem.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy()  # was item
    self.item2vnodeDict[itemHash] = v  # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    # #1310: Add a tool tip.
    item.setToolTip(0, p.h)
    if self.use_declutter:
        icon = self.declutter_node(c, p, item)
        if icon:
            item.setIcon(0, icon)
        return item
    # Draw the icon.
    v.iconVal = v.computeIcon()
    icon = self.getCompositeIconImage(p, v.iconVal)
        # **Slow**, but allows per-vnode icons.
    if icon:
        item.setIcon(0, icon)
    return item
</t>
<t tx="ekr.20110605121601.17883">def redraw_after_icons_changed(self):

    if self.busy:
        return
    self.redrawCount += 1  # To keep a unit test happy.
    c = self.c
    try:
        self.busy = True
            # Suppress call to setHeadString in onItemChanged!
        self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings(copy=False):
            # Updates icons in p and all visible descendants of p.
            self.updateVisibleIcons(p)
    finally:
        self.busy = False
</t>
<t tx="ekr.20110605121601.17950">def setItemIcon(self, item, icon):

    valid = item and self.isValidItem(item)
    if icon and valid:
        # Important: do not set lockouts here.
        # This will generate changed events,
        # but there is no itemChanged event handler.
        item.setIcon(0, icon)

</t>
<t tx="ekr.20110605121601.17951">def updateIcon(self, p):
    """Update p's icon."""
    if not p:
        return
    val = p.v.computeIcon()
    if p.v.iconVal != val:
        self.nodeIconsDict.pop(p.gnx, None)
        self.getIcon(p)  # sets p.v.iconVal
            
def updateAllIcons(self, p):
    if not p:
        return
    self.nodeIconsDict.pop(p.gnx, None)
    icon = self.getIcon(p)  # sets p.v.iconVal
    # Update all cloned items.
    items = self.vnode2items(p.v)
    for item in items:
        self.setItemIcon(item, icon)
</t>
<t tx="ekr.20110605121601.17952">def updateVisibleIcons(self, p):
    """Update the icon for p and the icons
    for all visible descendants of p."""
    self.updateAllIcons(p)
    if p.hasChildren() and p.isExpanded():
        for child in p.children():
            self.updateVisibleIcons(child)
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    """
    Called when user selects an item in the QListWidget.
    """
    c = self.leo_c
    p = c.p
    w = c.k.autoCompleter.w or c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.undoer.doTyping(p, 'Typing', oldText,
            newText=w.getAllText(),
            newInsert=w.getInsertPoint(),
            newSel=w.getSelectionRange(),
            oldSel=oldSel,
        )
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
</t>
<t tx="ekr.20110605121601.18135">def openUrlOnClick(event, url=None):
    """Open the URL under the cursor.  Return it for unit testing."""
    # This can be called outside Leo's command logic, so catch all exceptions.
    try:
        return openUrlHelper(event, url)
    except Exception:
        g.es_exception()
        return None
</t>
<t tx="ekr.20110605121601.18409"></t>
<t tx="ekr.20110605121601.18410">def drawIcon(self, p):
    """Redraw the icon at p."""
    return self.updateIcon(p)
    # the following code is wrong. It constructs a new item
    # and assignes the icon to it. However this item is never
    # added to the treeWidget so it is soon garbage collected
        # w = self.treeWidget
        # itemOrTree = self.position2item(p) or w
        # item = QtWidgets.QTreeWidgetItem(itemOrTree)
        # icon = self.getIcon(p)
        # self.setItemIcon(item, icon)
</t>
<t tx="ekr.20110605121601.18411">def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


</t>
<t tx="ekr.20110605121601.18412">def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ekr.20110605121601.18514"></t>
<t tx="ekr.20110605121601.18515">def attachLeoIcon(self, window):
    """Attach a Leo icon to the window."""
    #icon = self.getIconImage('leoApp.ico')
    if self.appIcon:
        window.setWindowIcon(self.appIcon)
</t>
<t tx="ekr.20110605121601.18516">def getIconImage(self, name):
    """Load the icon and return it."""
    # Return the image from the cache if possible.
    if name in self.iconimages:
        image = self.iconimages.get(name)
        return image
    try:
        iconsDir = g.os_path_join(g.app.loadDir, "..", "Icons")
        homeIconsDir = g.os_path_join(g.app.homeLeoDir, "Icons")
        for theDir in (homeIconsDir, iconsDir):
            fullname = g.os_path_finalize_join(theDir, name)
            if g.os_path_exists(fullname):
                if 0:  # Not needed: use QTreeWidget.setIconsize.
                    pixmap = QtGui.QPixmap()
                    pixmap.load(fullname)
                    image = QtGui.QIcon(pixmap)
                else:
                    image = QtGui.QIcon(fullname)
                self.iconimages[name] = image
                return image
        # No image found.
        return None
    except Exception:
        g.es_print("exception loading:", fullname)
        g.es_exception()
        return None
</t>
<t tx="ekr.20110605121601.18517">@functools.lru_cache(maxsize=128)
def getImageImage(self, name):
    """Load the image in file named `name` and return it."""
    fullname = self.getImageFinder(name)
    try:
        pixmap = QtGui.QPixmap()
        pixmap.load(fullname)
        return pixmap
    except Exception:
        g.es("exception loading:", name)
        g.es_exception()
        return None
</t>
<t tx="ekr.20110605121601.18518">@functools.lru_cache(maxsize=128)
def getTreeImage(self, c, path):
    image = QtGui.QPixmap(path)
    if image.height() &gt; 0 and image.width() &gt; 0:
        return image, image.height()
    return None, None
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    """Remain in this state until 'end' is seen."""
    self.matcher_name = 'restart:' + self.matcher_name.replace('restart:','')
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else:  # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j  # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    """
    Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.
    """
    trace = 'coloring' in g.app.debug and not g.unitTesting
        # setTag does most tracing.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    self.delegate_name = delegate
    if delegate:
        if trace:
            if len(repr(s[i:j])) &lt;= 20:
                s2 = repr(s[i:j])
            else:
                s2 = repr(s[i : i + 17 - 2] + '...')
            kind_s = f"{delegate}:{tag}"
            print(
                f"\ncolorRangeWithTag: {kind_s:25} {i:3} {j:3} "
                f"{s2:&gt;20} {self.matcher_name}\n")
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    self.matcher_name = f.__name__
                    i += n
                    break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh':  # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">tot_time = 0.0

def mainLoop(self, n, s):
    """Colorize a *single* line s, starting in state n."""
    trace = 'coloring' in g.app.debug
    t1 = time.process_time()
    f = self.restartDict.get(n)
    if trace:
        p = self.c and self.c.p
        if p and p.v != self.last_v:
            self.last_v = p.v
            f_name = f.__name__ if f else 'None'
            print('')
            g.trace(f"NEW NODE: state {n} = {f_name} {p.h}\n")
    i = f(s) if f else 0
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0:  # Success. The match has already been colored.
                self.matcher_name = f.__name__  # For traces.
                i += n
                break
            elif n &lt; 0:  # Total failure.
                i += -n
                break
            else:  # Partial failure: Do not break or change i!
                pass
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about changing state here.
    self.tot_time += time.process_time() - t1
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    """
    jEdit.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    """
    p = self.c.p
    self.recolorCount += 1
    block_n = self.currentBlockNumber()
    n = self.prevState()
    if p.v == self.old_v:
        new_language = self.n2languageDict.get(n)
        if new_language != self.language:
            self.language = new_language
            self.init(p)
    else:
        self.updateSyntaxColorer(p)  # Force a full recolor
        assert self.language
        self.init_all_state(p.v)
        self.init(p)
    if block_n == 0:
        n = self.initBlock0()
    n = self.setState(n)  # Required.
    # Always color the line, even if colorizing is disabled.
    if s:
        self.mainLoop(n, s)
</t>
<t tx="ekr.20110605121601.18641">last_v = None

def setTag(self, tag, s, i, j):
    """Set the tag in the highlighter."""
    trace = 'coloring' in g.app.debug and not g.unitTesting
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper  # A QTextEditWrapper
    if not tag.strip():
        return
    tag = tag.lower().strip()
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots') :]
    colorName = wrapper.configDict.get(tag)
        # This color name should already be valid.
    if not colorName:
        return
    #
    # New in Leo 5.8.1: allow symbolic color names here.
    # This now works because all keys in leo_color_database are normalized.
    colorName = colorName.replace(
        ' ', '').replace('-', '').replace('_', '').lower().strip()
    colorName = leo_color_database.get(colorName, colorName)
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            g.trace('unknown color name', colorName, g.callers())
            return
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    if trace:
        # A superb trace.
        ###
            # p = self.c and self.c.p
            # if p and p.v != self.last_v:
                # print(f'\nsetTag: NEW NODE: {p.h}\n')
                # self.last_v = p.v
        if len(repr(s[i:j])) &lt;= 20:
            s2 = repr(s[i:j])
        else:
            s2 = repr(s[i : i + 17 - 2] + '...')
        kind_s = f"{self.language}.{tag}"
        kind_s2 = f"{self.delegate_name}:" if self.delegate_name else ''
        print(
            f"setTag: {kind_s:25} {i:3} {j:3} {s2:&gt;20} "
            f"{self.rulesetName}:{kind_s2}{self.matcher_name}"
        )
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20110606004638.16929">def stroke2char(self, stroke):
    """
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    """
    if not stroke:
        return ''
    if not g.isStroke(stroke):
        # vim commands pass a plain key.
        stroke = g.KeyStroke(stroke)
    return stroke.toInsertableChar()
</t>
<t tx="ekr.20110609161752.16459">def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) &gt; 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @&lt;file&gt; node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120130074511.10227">def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
</t>
<t tx="ekr.20120130074511.10228">def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) &gt; -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
</t>
<t tx="ekr.20120208064440.10179">def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20120208064440.10190"></t>
<t tx="ekr.20120208064440.10199">def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
</t>
<t tx="ekr.20120217070122.10479">def reloadSettings(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable-autocompleter-initially')
    self.enable_calltips = getBool('enable-calltips-initially')
    self.ignore_unbound_non_ascii_keys = getBool('ignore-unbound-non-ascii-keys')
    self.minibuffer_background_color = getColor(
        'minibuffer-background-color') or 'lightblue'
    self.minibuffer_foreground_color = getColor(
        'minibuffer-foreground-color') or 'black'
    self.minibuffer_warning_color = getColor(
        'minibuffer-warning-color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer-error-color') or 'red'
    self.replace_meta_with_alt = getBool('replace-meta-with-alt')
    self.warn_about_redefined_shortcuts = getBool('warn-about-redefined-shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable-alt-ctrl-bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body-text-background-color') or 'white'
    fg = c.config.getColor('body-text-foreground-color') or 'black'
    self.command_mode_bg_color = getColor('command-mode-bg-color') or bg
    self.command_mode_fg_color = getColor('command-mode-fg-color') or fg
    self.insert_mode_bg_color = getColor('insert-mode-bg-color') or bg
    self.insert_mode_fg_color = getColor('insert-mode-fg-color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite-mode-bg-color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite-mode-fg-color') or fg
    self.unselected_body_bg_color = getColor('unselected-body-bg-color') or bg
    self.unselected_body_fg_color = getColor('unselected-body-fg-color') or bg
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120311151914.9916">unl_regex = re.compile(r'\bunl:.*$')

kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(fr"""{kinds}://[^\s'"]+[\w=/]""")
</t>
<t tx="ekr.20120311151914.9917">def getUrlFromNode(p):
    """
    Get an url from node p:
    1. Use the headline if it contains a valid url.
    2. Otherwise, look *only* at the first line of the body.
    """
    if not p: return None
    c = p.v.context
    assert c
    table = [p.h, g.splitLines(p.b)[0] if p.b else '']
    table = [s[4:] if g.match_word(s, 0, '@url') else s for s in table]
    table = [s.strip() for s in table if s.strip()]
    # First, check for url's with an explicit scheme.
    for s in table:
        if g.isValidUrl(s):
            return s
    # Next check for existing file and add a file:// scheme.
    for s in table:
        tag = 'file://'
        url = computeFileUrl(s, c=c, p=p)
        if url.startswith(tag):
            fn = url[len(tag) :].lstrip()
            fn = fn.split('#', 1)[0]
            if g.os_path_isfile(fn):
                # Return the *original* url, with a file:// scheme.
                # g.handleUrl will call computeFileUrl again.
                return 'file://' + s
    # Finally, check for local url's.
    for s in table:
        if s.startswith("#"):
            return s
    return None
</t>
<t tx="ekr.20120311151914.9918">def isValidUrl(url):
    """Return true if url *looks* like a valid url."""
    table = (
        'file', 'ftp', 'gopher', 'hdl', 'http', 'https', 'imap',
        'mailto', 'mms', 'news', 'nntp', 'prospero', 'rsync', 'rtsp', 'rtspu',
        'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
    )
    if url.lower().startswith('unl:' + '//') or url.startswith('#'):
        # All Leo UNL's.
        return True
    if url.startswith('@'):
        return False
    parsed = urlparse.urlparse(url)
    scheme = parsed.scheme
    for s in table:
        if scheme.startswith(s):
            return True
    return False
</t>
<t tx="ekr.20120315062642.9744">def openUrl(p):
    """
    Open the url of node p.
    Use the headline if it contains a valid url.
    Otherwise, look *only* at the first line of the body.
    """
    if p:
        url = g.getUrlFromNode(p)
        if url:
            c = p.v.context
            if not g.doHook("@url1", c=c, p=p, url=url):
                g.handleUrl(url, c=c, p=p)
            g.doHook("@url2", c=c, p=p, url=url)
</t>
<t tx="ekr.20120320053907.9776">def computeFileUrl(fn, c=None, p=None):
    """
    Compute finalized url for filename fn.
    """
    # First, replace special characters (especially %20, by their equivalent).
    url = urllib.parse.unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i &gt; -1:
        # Expand '~'.
        path = url[i:]
        path = g.os_path_expanduser(path)
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        path = g.os_path_finalize(path)
        url = url[:i] + path
    else:
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2) :].lstrip()
        elif url.startswith(tag):
            path = url[len(tag) :].lstrip()
        else:
            path = url
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.os_path_finalize_join(c.openDirectory, base, path)
        else:
            path = g.os_path_finalize(path)
        url = f"{tag}{path}"
    return url
</t>
<t tx="ekr.20120427064024.10064">def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []  # A list of normalized file names.
    if any(os.path.exists(z) and os.path.samefile(z, fn) for z in aList):
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        fn = os.path.normpath(fn)
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
</t>
<t tx="ekr.20120427064024.10065">def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(os.path.normpath(fn))
        d[tag] = aList
</t>
<t tx="ekr.20120427064024.10066">def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    fn = os.path.normpath(fn)
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
</t>
<t tx="ekr.20120427064024.10068"></t>
<t tx="ekr.20120520174745.9867">@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons &amp;&amp; @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
</t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130911110233.11284">def readFileToUnicode(self, fileName):
    '''
    Carefully sets at.encoding, then uses at.encoding to convert the file
    to a unicode string.

    Sets at.encoding as follows:
    1. Use the BOM, if present. This unambiguously determines the encoding.
    2. Use the -encoding= field in the @+leo header, if present and valid.
    3. Otherwise, uses existing value of at.encoding, which comes from:
        A. An @encoding directive, found by at.scanAllDirectives.
        B. The value of c.config.default_derived_file_encoding.

    Returns the string, or None on failure.
    '''
    at = self
    s = at.openFileHelper(fileName)
        # Catches all exceptions.
    # #1798.
    if s is None:
        return None
    e, s = g.stripBOM(s)
    if e:
        # The BOM determines the encoding unambiguously.
        s = g.toUnicode(s, encoding=e)
    else:
        # Get the encoding from the header, or the default encoding.
        s_temp = g.toUnicode(s, 'ascii', reportErrors=False)
        e = at.getEncodingFromHeader(fileName, s_temp)
        s = g.toUnicode(s, encoding=e)
    s = s.replace('\r\n', '\n')
    at.encoding = e
    at.initReadLine(s)
    return s
</t>
<t tx="ekr.20130911110233.11285">def openFileHelper(self, fileName):
    """Open a file, reporting all exceptions."""
    at = self
    # #1798: return None as a flag on any error.
    s = None 
    try:
        with open(fileName, 'rb') as f:
            s = f.read()
    except IOError:
        at.error(f"can not open {fileName}")
    except Exception:
        at.error(f"Exception reading {fileName}")
        g.es_exception()
    return s
</t>
<t tx="ekr.20130911110233.11287">def getEncodingFromHeader(self, fileName, s):
    """
    Return the encoding given in the @+leo sentinel, if the sentinel is
    present, or the previous value of at.encoding otherwise.
    """
    at = self
    if at.errors:
        g.trace('can not happen: at.errors &gt; 0', g.callers())
        e = at.encoding
        if g.unitTesting: assert False, g.callers()
            # This can happen when the showTree command in a unit test is left on.
            # A @file/@clean node is created which refers to a non-existent file.
            # It's surprisingly difficult to set at.error=0 safely elsewhere.
            # Otoh, I'm not sure why this test here is ever really useful.
    else:
        at.initReadLine(s)
        old_encoding = at.encoding
        assert old_encoding
        at.encoding = None
        # Execute scanHeader merely to set at.encoding.
        at.scanHeader(fileName, giveErrors=False)
        e = at.encoding or old_encoding
    assert e
    return e
</t>
<t tx="ekr.20130924035029.12741">def initOneAbbrev(self, commandName, key):
    """Enter key as an abbreviation for commandName in c.commandsDict."""
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
</t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20131016084446.16724">def setComplexCommand(self, commandName):
    """Make commandName the command to be executed by repeat-complex-command."""
    c = self
    c.k.mb_history.insert(0, commandName)
</t>
<t tx="ekr.20131017100903.16689">def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
</t>
<t tx="ekr.20131017174814.17480">def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131117164142.16916">@cmd('find-tab-open')
def open_find_tab(self, event=None, show=True):  # pragma: no cover (cmd)
    """Open the Find tab in the log pane."""
    c = self.c
    if c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
</t>
<t tx="ekr.20131117164142.16919">@cmd('toggle-find-collapses-nodes')
def toggle_find_collapes_nodes(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Collapse Nodes' checkbox in the find tab."""
    c = self.c
    c.sparse_find = not c.sparse_find
    if not g.unitTesting:
        g.es('sparse_find', c.sparse_find)

@cmd('toggle-find-ignore-case-option')
def toggle_ignore_case_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Ignore Case' checkbox in the Find tab."""
    return self.toggle_option('ignore_case')

@cmd('toggle-find-mark-changes-option')
def toggle_mark_changes_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Mark Changes' checkbox in the Find tab."""
    return self.toggle_option('mark_changes')

@cmd('toggle-find-mark-finds-option')
def toggle_mark_finds_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Mark Finds' checkbox in the Find tab."""
    return self.toggle_option('mark_finds')

@cmd('toggle-find-regex-option')
def toggle_regex_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Regexp' checkbox in the Find tab."""
    return self.toggle_option('pattern_match')

@cmd('toggle-find-in-body-option')
def toggle_search_body_option(self, event):  # pragma: no cover (cmd)
    """Set the 'Search Body' checkbox in the Find tab."""
    return self.toggle_option('search_body')

@cmd('toggle-find-in-headline-option')
def toggle_search_headline_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Search Headline' checkbox in the Find tab."""
    return self.toggle_option('search_headline')

@cmd('toggle-find-word-option')
def toggle_whole_word_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Whole Word' checkbox in the Find tab."""
    return self.toggle_option('whole_word')

# @cmd('toggle-find-wrap-around-option')
# def toggleWrapSearchOption(self, event):
    # """Toggle the 'Wrap Around' checkbox in the Find tab."""
    # return self.toggle_option('wrap')

def toggle_option(self, checkbox_name):  # pragma: no cover (cmd)
    c, fc = self.c, self.c.findCommands
    self.ftm.toggle_checkbox(checkbox_name)
    options = fc.compute_find_options_in_status_area()
    c.frame.statusLine.put(options)
</t>
<t tx="ekr.20131117164142.16939"></t>
<t tx="ekr.20131117164142.16941">@cmd('isearch-forward')
def isearch_forward(self, event):  # pragma: no cover (cmd)
    """
    Begin a forward incremental search.

    - Plain characters extend the search.
    - !&lt;isearch-forward&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-forward',
        forward=True, ignoreCase=False, regexp=False)
</t>
<t tx="ekr.20131117164142.16942">@cmd('isearch-backward')
def isearch_backward(self, event):  # pragma: no cover (cmd)
    """
    Begin a backward incremental search.

    - Plain characters extend the search backward.
    - !&lt;isearch-forward&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-backward',
        forward=False, ignoreCase=False, regexp=False)
</t>
<t tx="ekr.20131117164142.16943">@cmd('isearch-forward-regexp')
def isearch_forward_regexp(self, event):  # pragma: no cover (cmd)
    """
    Begin a forward incremental regexp search.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-forward-regexp',
        forward=True, ignoreCase=False, regexp=True)
</t>
<t tx="ekr.20131117164142.16944">@cmd('isearch-backward-regexp')
def isearch_backward_regexp(self, event):  # pragma: no cover (cmd)
    """
    Begin a backward incremental regexp search.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-backward-regexp',
        forward=False, ignoreCase=False, regexp=True)
</t>
<t tx="ekr.20131117164142.16945">@cmd('isearch-with-present-options')
def isearch_with_present_options(self, event):  # pragma: no cover (cmd)
    """
    Begin an incremental search using find panel options.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-with-present-options',
        forward=None, ignoreCase=None, regexp=None)
</t>
<t tx="ekr.20131117164142.16946"></t>
<t tx="ekr.20131117164142.16947">def abort_search(self):  # pragma: no cover (cmd)
    """Restore the original position and selection."""
    c, k = self.c, self.k
    w = c.frame.body.wrapper
    k.clearState()
    k.resetLabel()
    p, i, j, in_headline = self.stack[0]
    self.in_headline = in_headline
    c.selectPosition(p)
    c.redraw_after_select(p)
    c.bodyWantsFocus()
    w.setSelectionRange(i, j)
</t>
<t tx="ekr.20131117164142.16948">def end_search(self):  # pragma: no cover (cmd)
    c, k = self.c, self.k
    k.clearState()
    k.resetLabel()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20131117164142.16949">def iSearch_helper(self, again=False):  # pragma: no cover (cmd)
    """Handle the actual incremental search."""
    c, k, p = self.c, self.k, self.c.p
    reverse = not self.isearch_forward_flag
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        self.abort_search()
        return
    # Settings...
    self.find_text = self.ftm.get_find_text()
    self.change_text = self.ftm.get_change_text()
    # Save
    oldPattern = self.find_text
    oldRegexp = self.pattern_match
    oldWord = self.whole_word
    # Override
    self.pattern_match = self.isearch_regexp
    self.reverse = reverse
    self.find_text = pattern
    self.whole_word = False  # Word option can't be used!
    # Prepare the search.
    if len(self.stack) &lt;= 1:
        self.in_headline = False
    # Init the work widget from the gui widget.
    gui_w = self.set_widget()
    s = gui_w.getAllText()
    i, j = gui_w.getSelectionRange()
    if again:
        ins = i if reverse else j + len(pattern)
    else:
        ins = j + len(pattern) if reverse else i
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    # Do the search!
    p, pos, newpos = self.find_next_match(p)
    # Restore.
    self.find_text = oldPattern
    self.pattern_match = oldRegexp
    self.reverse = False
    self.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None:  # success.
        w = self.show_success(p, pos, newpos, showState=False)
        if w:
            i, j = w.getSelectionRange(sort=False)
        if not again:
            self.push(c.p, i, j, self.in_headline)
    else:
        g.es(f"not found: {pattern}")
        if not again:
            event = g.app.gui.create_key_event(
                c, binding='BackSpace', char='\b', w=w)
            k.updateLabel(event)
</t>
<t tx="ekr.20131117164142.16950">def isearch_state_handler(self, event):  # pragma: no cover (cmd)
    """The state manager when the state is 'isearch"""
    # c = self.c
    k = self.k
    stroke = event.stroke if event else None
    s = stroke.s if stroke else ''
    # No need to recognize ctrl-z.
    if s in ('Escape', '\n', 'Return'):
        self.end_search()
    elif stroke in self.iSearchStrokes:
        self.iSearch_helper(again=True)
    elif s in ('\b', 'BackSpace'):
        k.updateLabel(event)
        self.isearch_backspace()
    elif (
        s.startswith('Ctrl+') or
        s.startswith('Alt+') or
        k.isFKey(s)  # 2011/06/13.
    ):
        # End the search.
        self.end_search()
        k.masterKeyHandler(event)
    # Fix bug 1267921: isearch-forward accepts non-alphanumeric keys as input.
    elif k.isPlainKey(stroke):
        k.updateLabel(event)
        self.iSearch_helper()
</t>
<t tx="ekr.20131117164142.16951">def isearch_backspace(self):  # pragma: no cover (cmd)

    c = self.c
    if len(self.stack) &lt;= 1:
        self.abort_search()
        return
    # Reduce the stack by net 1.
    self.pop()
    p, i, j, in_headline = self.pop()
    self.push(p, i, j, in_headline)
    if in_headline:
        # Like self.show_success.
        selection = i, j, i
        c.redrawAndEdit(p, selectAll=False,
            selection=selection,
            keepMinibuffer=True)
    else:
        c.selectPosition(p)
        w = c.frame.body.wrapper
        c.bodyWantsFocus()
        if i &gt; j: i, j = j, i
        w.setSelectionRange(i, j)
    if len(self.stack) &lt;= 1:
        self.abort_search()
</t>
<t tx="ekr.20131117164142.16952">def get_strokes(self, commandName):  # pragma: no cover (cmd)
    aList = self.inverseBindingDict.get(commandName, [])
    return [key for pane, key in aList]
</t>
<t tx="ekr.20131117164142.16953">def push(self, p, i, j, in_headline):  # pragma: no cover (cmd)
    data = p.copy(), i, j, in_headline
    self.stack.append(data)

def pop(self):  # pragma: no cover (cmd)
    data = self.stack.pop()
    p, i, j, in_headline = data
    return p, i, j, in_headline
</t>
<t tx="ekr.20131117164142.16954">def set_widget(self):  # pragma: no cover (cmd)
    c = self.c; p = c.currentPosition()
    wrapper = c.frame.body.wrapper
    if self.in_headline:
        w = c.edit_widget(p)
        if not w:
            # Selecting the minibuffer can kill the edit widget.
            selection = 0, 0, 0
            c.redrawAndEdit(p, selectAll=False,
                selection=selection, keepMinibuffer=True)
            w = c.edit_widget(p)
        if not w:  # Should never happen.
            g.trace('**** no edit widget!')
            self.in_headline = False; w = wrapper
    else:
        w = wrapper
    if w == wrapper:
        c.bodyWantsFocus()
    return w
</t>
<t tx="ekr.20131117164142.16955">def start_incremental(self, event, commandName, forward, ignoreCase, regexp):  # pragma: no cover (cmd)
    c, k = self.c, self.k
    # None is a signal to get the option from the find tab.
    self.event = event
    self.isearch_forward_flag = not self.reverse if forward is None else forward
    self.isearch_ignore_case = self.ignore_case if ignoreCase is None else ignoreCase
    self.isearch_regexp = self.pattern_match if regexp is None else regexp
    # Note: the word option can't be used with isearches!
    w = c.frame.body.wrapper
    self.p1 = c.p
    self.sel1 = w.getSelectionRange(sort=False)
    i, j = self.sel1
    self.push(c.p, i, j, self.in_headline)
    self.inverseBindingDict = k.computeInverseBindingDict()
    self.iSearchStrokes = self.get_strokes(commandName)
    k.setLabelBlue(
        "Isearch"
        f"{' Backward' if not self.isearch_forward_flag else ''}"
        f"{' Regexp' if self.isearch_regexp else ''}"
        f"{' NoCase' if self.isearch_ignore_case else ''}"
        ": "
    )
    k.setState('isearch', 1, handler=self.isearch_state_handler)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20131117164142.16989">@cmd('show-find-options')
def show_find_options(self, event=None):  # pragma: no cover (cmd)
    """
    Show the present find options in the status line.
    This is useful for commands like search-forward that do not show the Find Panel.
    """
    frame = self.c.frame
    frame.clearStatusLine()
    part1, part2 = self.compute_find_options()
    frame.putStatusLine(part1, bg='blue')
    frame.putStatusLine(part2)
</t>
<t tx="ekr.20131117164142.16992">def add_change_string_to_label(self):  # pragma: no cover (cmd)
    """Add an unprotected change string to the minibuffer label."""
    c = self.c
    s = self.ftm.get_change_text()
    c.minibufferWantsFocus()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    c.k.extendLabel(s, select=True, protect=False)
</t>
<t tx="ekr.20131117164142.16993">def add_find_string_to_label(self, protect=True):  # pragma: no cover (cmd)
    c, k = self.c, self.c.k
    ftm = c.findCommands.ftm
    s = ftm.get_find_text()
    c.minibufferWantsFocus()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    k.extendLabel(s, select=True, protect=protect)
</t>
<t tx="ekr.20131117164142.16994">@cmd('change-all')
@cmd('replace-all')
def interactive_change_all(self, event=None):  # pragma: no cover (interactive)
    """Replace all instances of the search string with the replacement string."""
    self.ftm.clear_focus()
    self.ftm.set_entry_focus()
    prompt = 'Replace Regex: ' if self.pattern_match else 'Replace: '
    self.start_state_machine(event, prompt,
        handler=self.interactive_replace_all1,
        # Allow either '\t' or '\n' to switch to the change text.
        escape_handler=self.interactive_replace_all1,
    )

def interactive_replace_all1(self, event):  # pragma: no cover (interactive)
    k = self.k
    find_pattern = k.arg
    self._sString = k.arg
    self.update_find_list(k.arg)
    regex = ' Regex' if self.pattern_match else ''
    prompt = f"Replace{regex}: {find_pattern} With: "
    k.setLabelBlue(prompt)
    self.add_change_string_to_label()
    k.getNextArg(self.interactive_replace_all2)

def interactive_replace_all2(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper

    # Update settings data.
    find_pattern = self._sString
    change_pattern = k.arg
    self.init_vim_search(find_pattern)
    self.update_change_list(change_pattern)
    # Compute settings...
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    # Do the command!
    self.do_change_all(settings)
</t>
<t tx="ekr.20131117164142.16996">@cmd('clone-find-all-flattened')
# @cmd('find-clone-all-flattened')
@cmd('cff')
def interactive_cff(
    self, event=None, preloaded=None):  # pragma: no cover (interactive)
    """
    clone-find-all-flattened (aka find-clone-all-flattened and cff).

    Create an organizer node whose direct children are clones of all nodes
    matching the search string, except @nosearch trees.

    The list is flattened: every cloned node appears as a direct child
    of the organizer node, even if the clone also is a descendant of
    another cloned node.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    if not preloaded:
        self.preload_find_pattern(w)
    self.start_state_machine(event,
        prefix='Clone Find All Flattened: ',
        handler=self.interactive_cff1)

def interactive_cff1(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    pattern = k.arg
    self.ftm.set_find_text(pattern)
    self.init_vim_search(pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    count = self.do_clone_find_all(settings)
    if count:
        c.redraw()
        c.treeWantsFocus()
    return count
</t>
<t tx="ekr.20131117164142.16998">@cmd('find-all')
def interactive_find_all(self, event=None):  # pragma: no cover (interactive)
    """
    Create a summary node containing descriptions of all matches of the
    search string.
    
    Typing tab converts this to the change-all command.
    """
    self.ftm.clear_focus()
    self.ftm.set_entry_focus()
    self.start_state_machine(event, 'Search: ',
        handler=self.interactive_find_all1,
        escape_handler=self.find_all_escape_handler,
    )

def interactive_find_all1(self, event=None):  # pragma: no cover (interactive)
    k = self.k
    # Settings.
    find_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    ##self.init_in_headline()
    settings = self.ftm.get_settings()
    self.find_text = find_pattern
    self.change_text = self.ftm.get_change_text()
    self.update_find_list(find_pattern)
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_find_all(settings)

def find_all_escape_handler(self, event):  # pragma: no cover (interactive)
    k = self.k
    prompt = 'Replace ' + ('Regex' if self.pattern_match else 'String')
    find_pattern = k.arg
    self._sString = k.arg
    self.update_find_list(k.arg)
    s = f"{prompt}: {find_pattern} With: "
    k.setLabelBlue(s)
    self.add_change_string_to_label()
    k.getNextArg(self.find_all_escape_handler2)

def find_all_escape_handler2(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    find_pattern = self._sString
    change_pattern = k.arg
    self.update_change_list(change_pattern)
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_change_all(settings)
</t>
<t tx="ekr.20131117164142.17003">@cmd('re-search')
@cmd('re-search-forward')
def interactive_re_search_forward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, with regex."""
    # Set flag for show_find_options.
    self.pattern_match = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_pattern_match = True
    # Go.
    self.start_state_machine(event,
        prefix='Regexp Search: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17004">@cmd('search-backward')
def interactive_search_backward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, but in reverse."""
    # Set flag for show_find_options.
    self.reverse = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_reverse = True
    # Go.
    self.start_state_machine(event,
        prefix='Search Backward: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17007">def start_state_machine(self, event, prefix, handler, escape_handler=None):  # pragma: no cover (cmd)
    """
    Initialize and start the state machine used to get user arguments.
    """
    c, k = self.c, self.k
    w = c.frame.body.wrapper
    if not w:
        return
    # Gui...
    k.setLabelBlue(prefix)
    # New in Leo 5.2: minibuffer modes shows options in status area.
    if self.minibuffer_mode:
        self.show_find_options_in_status_area()
    elif c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
    self.add_find_string_to_label(protect=False)
    k.getArgEscapes = ['\t'] if escape_handler else []
    self.handler = handler
    self.escape_handler = escape_handler
    # Start the state maching!
    k.get1Arg(event, handler=self.state0, tabList=self.findTextList, completion=True)

def state0(self, event):  # pragma: no cover (cmd)
    """Dispatch the next handler."""
    k = self.k
    if k.getArgEscapeFlag:
        k.getArgEscapeFlag = False
        self.escape_handler(event)
    else:
        self.handler(event)
</t>
<t tx="ekr.20131117164142.17008">def update_change_list(self, s):  # pragma: no cover (cmd)
    if s not in self.changeTextList:
        self.changeTextList.append(s)

def update_find_list(self, s):  # pragma: no cover (cmd)
    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20131117164142.17009">@cmd('word-search-backward')
def word_search_backward(self, event):  # pragma: no cover (interactive)
    # Set flags for show_find_options.
    self.reverse = True
    self.whole_world = True
    self.show_find_options()
    # Set flags for do_find_next().
    self.request_reverse = True
    self.request_whole_world = True
    # Go
    self.start_state_machine(event,
        prefix='Word Search Backward: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17011">@cmd('clone-find-all')
@cmd('find-clone-all')
@cmd('cfa')
def interactive_clone_find_all(
    self, event=None, preloaded=None):  # pragma: no cover (interactive)
    """
    clone-find-all ( aka find-clone-all and cfa).

    Create an organizer node whose descendants contain clones of all nodes
    matching the search string, except @nosearch trees.

    The list is *not* flattened: clones appear only once in the
    descendants of the organizer node.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    if not preloaded:
        self.preload_find_pattern(w)
    self.start_state_machine(event,
        prefix='Clone Find All: ',
        handler=self.interactive_clone_find_all1)

def interactive_clone_find_all1(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    pattern = k.arg
    self.ftm.set_find_text(pattern)
    self.init_vim_search(pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    count = self.do_clone_find_all(settings)
    if count:
        c.redraw()
        c.treeWantsFocus()
    return count
</t>
<t tx="ekr.20131117164142.17013"></t>
<t tx="ekr.20131117164142.17015">@cmd('find-tab-hide')
def hide_find_tab(self, event=None):  # pragma: no cover (cmd)
    """Hide the Find tab."""
    c = self.c
    if self.minibuffer_mode:
        c.k.keyboardQuit()
    else:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20131117164142.17016">def do_change_all(self, settings):
    c = self.c
    # Settings...
    self.init_ivars_from_settings(settings)
    if not self.check_args('change-all'):
        return 0
    n = self._change_all_helper(settings)
    #
    # Bugs #947, #880 and #722:
    # Set ancestor @&lt;file&gt; nodes by brute force.
    for p in c.all_positions():  # pragma: no cover
        if (
            p.anyAtFileNodeName()
            and not p.v.isDirty()
            and any(p2.v.isDirty() for p2 in p.subtree())
        ):
            p.setDirty()
    c.redraw()
    return n
</t>
<t tx="ekr.20131117164142.17019">@cmd('set-find-everywhere')
def set_find_scope_every_where(self, event=None):  # pragma: no cover (cmd)
    """Set the 'Entire Outline' radio button in the Find tab."""
    return self.set_find_scope('entire-outline')

@cmd('set-find-node-only')
def set_find_scope_node_only(self, event=None):  # pragma: no cover (cmd)
    """Set the 'Node Only' radio button in the Find tab."""
    return self.set_find_scope('node-only')

@cmd('set-find-suboutline-only')
def set_find_scope_suboutline_only(self, event=None):
    """Set the 'Suboutline Only' radio button in the Find tab."""
    return self.set_find_scope('suboutline-only')

def set_find_scope(self, where):
    """Set the radio buttons to the given scope"""
    c, fc = self.c, self.c.findCommands
    self.ftm.set_radio_button(where)
    options = fc.compute_find_options_in_status_area()
    c.frame.statusLine.put(options)
</t>
<t tx="ekr.20131117164142.17021"></t>
<t tx="ekr.20131117164142.17022">def finishCreate(self):
    # New in 4.11.1.
    # Must be called when config settings are valid.
    c = self.c
    self.reload_settings()
    # now that configuration settings are valid,
    # we can finish creating the Find pane.
    dw = c.frame.top
    if dw: dw.finishCreateLogPane()
</t>
<t tx="ekr.20131119060731.22452">@cmd('start-search')
@cmd('search-forward')  # Compatibility.
def start_search(self, event):  # pragma: no cover (interactive)
    """
    The default binding of Ctrl-F.
    
    Also contains default state-machine entries for find/change commands.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    self.preload_find_pattern(w)
    # #1840: headline-only one-shot
    #        Do this first, so the user can override.
    self.ftm.set_body_and_headline_checkbox()
    if self.minibuffer_mode:
        # Set up the state machine.
        self.ftm.clear_focus()
        self.changeAllFlag = False
        self.findAllUniqueFlag = False
        self.ftm.set_entry_focus()
        self.start_state_machine(event,
            prefix='Search: ',
            handler=self.start_search1,
            escape_handler=self.start_search_escape1,
        )
    else:
        self.open_find_tab(event)
        self.ftm.init_focus()
        return

startSearch = start_search  # Compatibility. Do not delete.
</t>
<t tx="ekr.20131119204029.16479">def help_for_find_commands(self, event=None):  # pragma: no cover (cmd)
    """Called from Find panel.  Redirect."""
    self.c.helpCommands.help_for_find_commands(event)
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131123071505.16465">def _fail_outside_range(self, p):  # pragma: no cover
    """
    Return True if the search is about to go outside its range, assuming
    both the headline and body text of the present node have been searched.
    """
    c = self.c
    if not p:
        return True
    if self.node_only:
        return True
    if self.suboutline_only:
        if self.root and p != self.root and not self.root.isAncestorOf(p):
            return True
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.trace('outside hoist', p.h)
            g.warning('found match outside of hoisted outline')
            return True
    return False  # Within range.
</t>
<t tx="ekr.20131123071505.16467">def precompile_pattern(self):
    """Precompile the regexp pattern if necessary."""
    try:  # Precompile the regexp.
        # pylint: disable=no-member
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        # Escape the search text.
        # Ignore the whole_word option.
        s = self.find_text
        # A bad idea: insert \b automatically.
            # b, s = '\\b', self.find_text
            # if self.whole_word:
                # if not s.startswith(b): s = b + s
                # if not s.endswith(b): s = s + b
        self.re_obj = re.compile(s, flags)
        return True
    except Exception:
        if not g.unitTesting:
            g.warning('invalid regular expression:', self.find_text)
        return False
</t>
<t tx="ekr.20131123132043.16476">def _fnm_next_after_fail(self, p):
    """Return the next node after a failed search or None."""
    # Move to the next position.
    p = p.threadBack() if self.reverse else p.threadNext()
    # Check it.
    if p and self._fail_outside_range(p):  # pragma: no cover
        return None
    if not p:  # pragma: no cover
        return None
    return p
</t>
<t tx="ekr.20131124060912.16472">def _fnm_should_stay_in_node(self, p):
    """Return True if the find should simply switch panes."""
    # Errors here cause the find command to fail badly.
    # Switch only if:
    #   a) searching both panes and,
    #   b) this is the first pane of the pair.
    # There is *no way* this can ever change.
    # So simple in retrospect, so difficult to see.
    return (
        self.search_headline and self.search_body and (
        (self.reverse and not self.in_headline) or
        (not self.reverse and self.in_headline)))
</t>
<t tx="ekr.20131124060912.16473">def _fnm_first_search_pane(self):
    """
    Set return the value of self.in_headline
    indicating which pane to search first.
    """
    if self.search_headline and self.search_body:
        # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
        if self.reverse:
            return False  # Search the body pane first.
        return True  # Search the headline pane first.
    if self.search_headline or self.search_body:
        # Search the only enabled pane.
        return self.search_headline
    g.trace('can not happen: no search enabled')
    return False  # pragma: no cover (now search the body)
</t>
<t tx="ekr.20131126085250.16651">def focus_in_tree(self):
    """
    Return True is the focus widget w is anywhere in the tree pane.

    Note: the focus may be in the find pane.
    """
    c = self.c
    ftm = self.ftm
    w = ftm and ftm.entry_focus or g.app.gui.get_focus(raw=True)
    if ftm:
        ftm.entry_focus = None  # Only use this focus widget once!
    w_name = c.widget_name(w)
    if w == c.frame.body.wrapper:
        val = False
    elif w == c.frame.tree.treeWidget:  # pragma: no cover
        val = True
    else:
        val = w_name.startswith('head')  # pragma: no cover
    return val
</t>
<t tx="ekr.20131222112420.16371">def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self) -&gt; bool:
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20131224085853.16443">def findReference(self, name, p):
    """Find a reference to name.  Raise an error if not found."""
    at = self
    ref = g.findReference(name, p)
    if not ref and not hasattr(at, 'allow_undefined_refs'):
        # Do give this error even if unit testing.
        at.writeError(
            f"undefined section: {g.truncate(name, 60)}\n"
            f"  referenced from: {g.truncate(p.h, 60)}")
    return ref
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140717074441.17772"># refresh_pattern = re.compile(r'^(@[\w-]+)')

@g.commander_command('refresh-from-disk')
def refreshFromDisk(self, event=None):
    """Refresh an @&lt;file&gt; node from disk."""
    c, p, u = self, self.p, self.undoer
    c.nodeConflictList = []
    fn = p.anyAtFileNodeName()
    shouldDelete = c.sqlite_connection is None
    if not fn:
        g.warning(f"not an @&lt;file&gt; node: {p.h!r}")
        return
    # #1603.
    if os.path.isdir(fn):
        g.warning(f"not a file: {fn!r}")
        return
    b = u.beforeChangeTree(p)
    redraw_flag = True
    at = c.atFileCommands
    c.recreateGnxDict()
        # Fix bug 1090950 refresh from disk: cut node ressurection.
    i = g.skip_id(p.h, 0, chars='@')
    word = p.h[0:i]
    if word == '@auto':
        # This includes @auto-*
        if shouldDelete: p.v._deleteAllChildren()
        # Fix #451: refresh-from-disk selects wrong node.
        p = at.readOneAtAutoNode(fn, p)
    elif word in ('@thin', '@file'):
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True)
    elif word == '@clean':
        # Wishlist 148: use @auto parser if the node is empty.
        if p.b.strip() or p.hasChildren():
            at.readOneAtCleanNode(p)
        else:
            # Fix #451: refresh-from-disk selects wrong node.
            p = at.readOneAtAutoNode(fn, p)
    elif word == '@shadow':
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True, atShadow=True)
    elif word == '@edit':
        at.readOneAtEditNode(fn, p)
            # Always deletes children.
    elif word == '@asis':
        # Fix #1067.
        at.readOneAtAsisNode(fn, p)
            # Always deletes children.
    else:
        g.es_print(f"can not refresh from disk\n{p.h!r}")
        redraw_flag = False
    if redraw_flag:
        # Fix #451: refresh-from-disk selects wrong node.
        c.selectPosition(p)
        u.afterChangeTree(p, command='refresh-from-disk', bunch=b)
        # Create the 'Recovered Nodes' tree.
        c.fileCommands.handleNodeConflicts()
        c.redraw()
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140724064952.18038">def dispatch(self, ext, p):
    """Return the correct scanner function for p, an @auto node."""
    # Match the @auto type first, then the file extension.
    c = self.c
    return g.app.scanner_for_at_auto(c, p) or g.app.scanner_for_ext(c, ext)
</t>
<t tx="ekr.20140724073946.18050">def get_import_filename(self, fileName, parent):
    """Return the absolute path of the file and set .default_directory."""
    c = self.c
    self.default_directory = g.setDefaultDirectory(c, parent, importing=False)
    fileName = g.os_path_finalize_join(self.default_directory, fileName)  # 1341
    fileName = fileName.replace('\\', '/')  # 2011/11/25
    return fileName
</t>
<t tx="ekr.20140724175458.18052">def init_import(self, atShadow, ext, fileName, s):
    """
    Init ivars imports and read the file into s.
    Return ext, s.
    """
    junk, self.fileName = g.os_path_split(fileName)
    self.methodName, self.fileType = g.os_path_splitext(self.fileName)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        # Set the kind for error messages in readFileIntoString.
        s, e = g.readFileIntoString(
            fileName,
            encoding=self.encoding,
            kind='@shadow ' if atShadow else '@auto ',
        )
            # Kind is used only for messages.
        if s is None:
            return None, None
        if e: self.encoding = e
    if self.treeType == '@root':
        self.rootLine = "@root-code " + self.fileName + '\n'
    else:
        self.rootLine = ''
    return ext, s
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins contain the write code for all kinds of special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140727075002.18108">def saveOutlineIfPossible(self):
    '''Save the outline if only persistence data nodes are dirty.'''
    c = self.c
    changed_positions = [p for p in c.all_unique_positions() if p.v.isDirty()]
    at_persistence = (
        c.persistenceController and
        c.persistenceController.has_at_persistence_node()
    )
    if at_persistence:
        changed_positions = [p for p in changed_positions
            if not at_persistence.isAncestorOf(p)]
    if not changed_positions:
        # g.warning('auto-saving @persistence tree.')
        c.clearChanged()  # Clears all dirty bits.
        c.redraw()
</t>
<t tx="ekr.20140728040812.17993">def dispatch(self, ext, p):
    """Return the correct writer function for p, an @auto node."""
    at = self
    # Match @auto type before matching extension.
    return at.writer_for_at_auto(p) or at.writer_for_ext(ext)
</t>
<t tx="ekr.20140728040812.17995">def writer_for_at_auto(self, root):
    """A factory returning a writer function for the given kind of @auto directive."""
    at = self
    d = g.app.atAutoWritersDict
    for key in d:
        aClass = d.get(key)
        if aClass and g.match_word(root.h, 0, key):

            def writer_for_at_auto_cb(root):
                # pylint: disable=cell-var-from-loop
                try:
                    writer = aClass(at.c)
                    s = writer.write(root)
                    return s
                except Exception:
                    g.es_exception()
                    return None

            return writer_for_at_auto_cb
    return None
</t>
<t tx="ekr.20140728040812.17997">def writer_for_ext(self, ext):
    """A factory returning a writer function for the given file extension."""
    at = self
    d = g.app.writersDispatchDict
    aClass = d.get(ext)
    if aClass:

        def writer_for_ext_cb(root):
            try:
                return aClass(at.c).write(root)
            except Exception:
                g.es_exception()
                return None

        return writer_for_ext_cb

    return None
</t>
<t tx="ekr.20140802120757.18001">def save_body(self):
    """Undoably preserve any changes to body text."""
    c = self.c
    w = self.command_w or self.w
    name = c.widget_name(w)
    if w and name.startswith('body'):
        # Similar to selfInsertCommand.
        oldSel = self.old_sel or w.getSelectionRange()
        newText = w.getAllText()
        if c.p.b != newText:
            # To do: set undoType to the command spelling?
            # undoType = ''.join(self.command_list) or 'Typing'
            c.frame.body.onBodyChanged(undoType='vc-save-body', oldSel=oldSel)
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140810053602.18074">"""
A module to allow careful, uniform imports from PyQt4 or PyQt5.
The isQt5 constant is True only if all important PyQt5 modules were imported.
Optional modules may fail to load without affecting the isQt5 constant.

Callers are expected to use the *PyQt5* spellings of modules:
- Use QtWidgets, not QtGui, for all widget classes.
- Use QtGui, not QtWidgets, for all other classes in the *PyQt4* QtGui module.
- Similarly, use QtWebKitWidgets rather than QtWebKit.
"""
# pylint: disable=unused-import,no-member,ungrouped-imports,wrong-import-order

# Define...
    # Qt, QtConst, QtCore, QtGui, QtWidgets, QUrl
    # QtDeclarative, QtMultimedia, Qsci, QString, QtSvg,
    # QtWebKit, QtWebKitWidgets
    # printsupport, Signal
from leo.core import leoGlobals as g
strict = False
trace = False
fail = g.in_bridge
    # #1274: Do *not* allow Qt imports when in the bridge!
try:
    isQt5 = True
    from PyQt5 import Qt
except ImportError:
    isQt5 = False
    try:
        from PyQt4 import Qt
        assert Qt  # for pyflakes
    except ImportError:
        fail = True
        if strict:
            print('leoQt.py: can not import either PyQt4 or PyQt5.')
            g.es_exception()  # #339.
            print('')
            raise
# Complete the imports.
if fail:
    isQt5 = False
    QString = g.u
    Qt = QtConst = QtCore = QtGui = QtWidgets = QUrl = None
    QtDeclarative = Qsci = QtSvg = QtMultimedia = QtWebKit = QtWebKitWidgets = None
    phonon = uic = None
    QtMultimedia = None  # Replacement for phonon.
    qt_version = '&lt;no version&gt;'
    printsupport = Signal = None
elif isQt5:
    try:
        from PyQt5 import QtCore
        from PyQt5 import QtGui
        from PyQt5 import QtWidgets
        from PyQt5.QtCore import QUrl
        from PyQt5.QtCore import pyqtSignal as Signal
        QtConst = QtCore.Qt
        printsupport = Qt
    except ImportError:
        print('leoQt.py: can not fully import PyQt5.')
        g.es_exception()  # PR #339.
        print('')
else:
    try:
        from PyQt4 import QtCore
        from PyQt4 import QtGui
        from PyQt4.QtCore import QUrl
        from PyQt4.QtCore import pyqtSignal as Signal
        assert QUrl  # for pyflakes.
        assert Signal  # for pyflakes.
        QtConst = QtCore.Qt
        QtWidgets = QtGui
        printsupport = QtWidgets
    except ImportError:
        print('leoQt.py: can not fully import PyQt4.')
        g.es_exception()  # PR #339.
        print('')
# Define qt_version
if fail:
    pass
else:
    qt_version = QtCore.QT_VERSION_STR
# Define phonon,Qsci,QtSvg,QtWebKit,QtWebKitWidgets,uic.
# These imports may fail without affecting the isQt5 constant.
if fail:
    pass
elif isQt5:
    try:
        QString = QtCore.QString
    except Exception:
        QString = g.u  # Use default
    try:
        import PyQt5.QtDeclarative as QtDeclarative
    except ImportError:
        QtDeclarative = None
    try:
        import PyQt5.phonon as phonon
        phonon = phonon.Phonon
    except ImportError:
        phonon = None
    try:
        from PyQt5 import QtMultimedia
    except ImportError:
        QtMultimedia = None
    try:
        from PyQt5 import Qsci
    except ImportError:
        Qsci = None
    try:
        import PyQt5.QtSvg as QtSvg
    except ImportError:
        QtSvg = None
    try:
        from PyQt5 import uic
    except ImportError:
        uic = None
    try:
        from PyQt5 import QtWebKit
    except ImportError:
        # 2016/07/13: Reinhard: Support pyqt 5.6...
        try:
            from PyQt5 import QtWebEngineCore as QtWebKit
        except ImportError:
            QtWebKit = None
    try:
        import PyQt5.QtWebKitWidgets as QtWebKitWidgets
    except ImportError:
        try:
            # https://groups.google.com/d/msg/leo-editor/J_wVIzqQzXg/KmXMxJSAAQAJ
            # Reinhard: Support pyqt 5.6...
            # used by viewrendered(2|3).py, bigdash.py, richtext.py.
            import PyQt5.QtWebEngineWidgets as QtWebKitWidgets
            QtWebKitWidgets.QWebView = QtWebKitWidgets.QWebEngineView
            QtWebKit.QWebSettings = QtWebKitWidgets.QWebEngineSettings
            QtWebKitWidgets.QWebPage = QtWebKitWidgets.QWebEnginePage
        except ImportError:
            QtWebKitWidgets = None
else:
    try:
        QString = QtCore.QString
    except Exception:
        QString = g.u
    try:
        import PyQt4.QtDeclarative as QtDeclarative
    except ImportError:
        QtDeclarative = None
    QtMultimedia = None
        # Does not exist on Qt4.
    try:
        import PyQt4.phonon as phonon
        phonon = phonon.Phonon
    except ImportError:
        phonon = None
    try:
        from PyQt4 import Qsci
    except ImportError:
        Qsci = None
    try:
        import PyQt4.QtSvg as QtSvg
    except ImportError:
        QtSvg = None
    try:
        from PyQt4 import uic
    except ImportError:
        uic = None
    try:
        from PyQt4 import QtWebKit
    except ImportError:
        QtWebKit = None
    try:
        import PyQt4.QtWebKit as QtWebKitWidgets  # Name change.
    except ImportError:
        QtWebKitWidgets = None
</t>
<t tx="ekr.20140813052702.18203">def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
</t>
<t tx="ekr.20140816165728.18968"># New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    &lt;&lt; docstring for k.get1arg &gt;&gt;
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
</t>
<t tx="ekr.20140822051549.18298">def setStatusLabel(self, s):
    """
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    """
    k = self
    k.setLabel(s, protect=False)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20141113094129.6">@cmd('focus-to-find')
def focus_to_find(self, event=None):  # pragma: no cover (cmd)
    c = self.c
    if c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
</t>
<t tx="ekr.20150107090324.10">def createRootWindow(self):
    pass # N/A
</t>
<t tx="ekr.20150107090324.11">def destroySelf(self):
    self.killed = True
</t>
<t tx="ekr.20150107090324.12">def finishCreate(self):
    pass
</t>
<t tx="ekr.20150107090324.13">def isTextWidget(self, w):
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    return w and isinstance(w, leoFrame.StringTextWrapper)
</t>
<t tx="ekr.20150107090324.14">def oops(self):
    g.pr("textGui oops", g.callers(), "should be implemented")
</t>
<t tx="ekr.20150107090324.15">def runMainLoop(self):
    self.text_run()
</t>
<t tx="ekr.20150107090324.16">def runOpenFileDialog(self, c, title, filetypes, defaultextension, multiple=False, startpath=None):
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    ret = get_input("Open which %s file (from %s?) &gt; " % (repr(filetypes), initialdir))
    if multiple:
        return [ret,]
    return ret
</t>
<t tx="ekr.20150107090324.17">def get_focus(self, c):
    pass

def set_focus(self, c, w):
    pass
</t>
<t tx="ekr.20150107090324.18">def text_run(self):
    frame_idx = 0
    while not self.killed:
        # Frames can come and go.
        if frame_idx &gt; len(self.frames) - 1:
            frame_idx = 0
        f = self.frames[frame_idx]
        g.pr(f.getTitle())
        s = get_input('Do what? (menu,key,body,frames,tree,quit) &gt; ')
        try:
            self.doChoice(f, s)
        except Exception:
            g.es_exception()
</t>
<t tx="ekr.20150107090324.19">def doChoice(self, f, s):
    if s in ('m', 'menu'):
        f.menu.show_menu()
    elif s in ('k', 'key'):
        f.text_key()
    elif s in ('b', 'body'):
        f.body.text_show()
    elif s in ('f', 'frames'):
        for i, f in enumerate(self.frames):
            g.pr(i, ')', f.getTitle())
        s = get_input('Operate on which frame? &gt; ')
        try:
            s = int(s)
        except ValueError:
            s = -1
        # if s &gt;= 0 and s &lt;= len(self.frames) - 1:
        #    frame_idx = s
    elif s in ('t', 'tree'):
        f.tree.text_draw_tree()
    elif s in ('q', 'quit'):
        self.killed = True
</t>
<t tx="ekr.20150107090324.20">def widget_name(self, w):
    if isinstance(w, textBodyCtrl):
        return 'body'
    return leoGui.LeoGui.widget_name(self, w)
</t>
<t tx="ekr.20150107090324.31">class textBody(leoFrame.LeoBody):
    @others
</t>
<t tx="ekr.20150107090324.32">def __init__(self, frame, parentFrame):
    super().__init__(frame, parentFrame)
    c = frame.c
    name = 'body'
    self.bodyCtrl = textBodyCtrl(c, name)
    self.colorizer = leoFrame.NullColorizer(self.c)
</t>
<t tx="ekr.20150107090324.33"># undoc: newLeoCommanderAndFrame -&gt; c.finishCreate -&gt; k.finishCreate -&gt;
# k.completeAllBindings -&gt; k.makeMasterGuiBinding -&gt; 2156 w.bind ; nullBody

def bind(self, bindStroke, callback):
    pass
</t>
<t tx="ekr.20150107090324.34"># TODO Tkinter onBodyChanged undo call and many others. =(

def setEditorColors(self, bg, fg): pass # N/A

def createBindings(self, w=None): pass
</t>
<t tx="ekr.20150107090324.35">def text_show(self):
    w = self.bodyCtrl
    g.pr('--- body ---')
    g.pr('ins', w.ins, 'sel', w.sel)
    g.pr(w.s)
</t>
<t tx="ekr.20150107090324.36">class textBodyCtrl(leoFrame.StringTextWrapper):
    pass
</t>
<t tx="ekr.20150107090324.37">class textMenuCascade:
    @others
</t>
<t tx="ekr.20150107090324.38">def __init__(self, menu, label, underline):
    self.menu = menu
    self.label = label
    self.underline = underline
</t>
<t tx="ekr.20150107090324.39">def display(self):
    ret = underline(self.label, self.underline)
    if not self.menu.entries:
        ret += ' [Submenu with no entries]'
    return ret
</t>
<t tx="ekr.20150107090324.40">class textMenuEntry:
    @others
</t>
<t tx="ekr.20150107090324.41">def __init__(self, label, underline, accel, callback):
    self.label = label
    self.underline = underline
    self.accel = accel
    self.callback = callback
</t>
<t tx="ekr.20150107090324.42">def display(self):
    return "%s %s" % (underline(self.label, self.underline), self.accel,)
</t>
<t tx="ekr.20150107090324.43">class textMenuSep:
    @others
</t>
<t tx="ekr.20150107090324.44">def display(self):
    return '-' * 5
</t>
<t tx="ekr.20150107090324.45">class textLeoMenu(leoMenu.LeoMenu):
    @others
</t>
<t tx="ekr.20150107090324.46">def __init__(self, frame):
    self.entries = []
    self.c = frame.c
    super().__init__(frame)
</t>
<t tx="ekr.20150107090324.47">def createMenuBar(self, frame):
    g.trace(frame.c)
    self._top_menu = textLeoMenu(frame)
    self.createMenusFromTables()
</t>
<t tx="ekr.20150107090324.48">def new_menu(self, parent, tearoff=0, label=''):
    if tearoff:
        raise NotImplementedError(repr(tearoff))
    menu = textLeoMenu(parent or self.frame)
    menu.entries = []
    return menu
</t>
<t tx="ekr.20150107090324.49">def add_cascade(self, parent, label, menu, underline):
    if parent is None:
        parent = self._top_menu
    parent.entries.append(textMenuCascade(menu, label, underline,))
</t>
<t tx="ekr.20150107090324.50">def add_command(self, **keys):
    # ?
    # underline - Offset into label. For those who memorised Alt, F, X rather than Alt+F4.
    # accelerator - For display only; these are implemented by Leo's key handling.
    menu = self

    def doNothingCallback():
        pass

    label = keys.get('label') or 'no label'
    underline = keys.get('underline') or 0
    accelerator = keys.get('accelerator') or ''
    command = keys.get('command') or doNothingCallback
    entry = textMenuEntry(label, underline, accelerator, command)
    menu.entries.append(entry)
</t>
<t tx="ekr.20150107090324.51">def add_separator(self, menu):
    menu.entries.append(textMenuSep())
</t>
<t tx="ekr.20150107090324.52">def delete_range(self, *args, **keys):
    pass
</t>
<t tx="ekr.20150107090324.53">def show_menu(self):
    last_menu = self._top_menu
    while True:
        entries = last_menu.entries
        for i, entry in enumerate(entries):
            g.pr(i, ')', entry.display())
        g.pr(len(last_menu.entries), ')', '[Prev]')
        which = get_input('Which menu entry? &gt; ')
        which = which.strip()
        if not which: continue
        try:
            n = int(which)
        except ValueError:
            # Look for accelerator character.
            ch = which[0].lower()
            for n, z in enumerate(entries):
                if hasattr(z, 'underline') and ch == z.label[z.underline].lower():
                    break
            else: continue
        if n == len(entries):
            return
        if n &lt; 0 or n &gt; len(entries) - 1:
            continue
        menu = entries[n]
        if isinstance(menu, textMenuEntry):
            menu.callback()
            return
        if isinstance(menu, textMenuCascade):
            last_menu = menu.menu
        else:
            pass
</t>
<t tx="ekr.20150107090324.54">class textLog(leoFrame.LeoLog):
    @others
</t>
<t tx="ekr.20150107090324.55">def setTabBindings(self, tabName):
    pass
</t>
<t tx="ekr.20150107090324.56">def put(self, s, color=None, tabName='Log', from_redirect=False):
    g.pr(s, newline=False)
</t>
<t tx="ekr.20150107090324.57">def putnl(self, tabName='log'):
    g.pr('')
</t>
<t tx="ekr.20150107090324.58"># &lt; &lt; HACK Quiet, oops. &gt;&gt;

def createControl(self, parentFrame): pass

def setFontFromConfig(self): pass # N/A
</t>
<t tx="ekr.20150107090324.59">def setColorFromConfig(self): pass
</t>
<t tx="ekr.20150107090324.6">class textGui(leoGui.LeoGui):
    @others
</t>
<t tx="ekr.20150107090324.60">class textTree(leoFrame.LeoTree):
    # undoc: k.makeAllBindings ; nullTree
    @others
</t>
<t tx="ekr.20150107090324.61">def setBindings(self):
    pass
</t>
<t tx="ekr.20150107090324.62">def redraw(self, p=None, scroll=True, forceDraw=False):
    self.text_draw_tree()
    
redraw_now = redraw

# def redraw_now(self, p=None, scroll=True, forceDraw=False):
    # if forceDraw:
        # self.redraw()
</t>
<t tx="ekr.20150107090324.63"></t>
<t tx="ekr.20150107090324.64">def __init__(self, frame):
    # undoc: openWithFileName -&gt; treeWantsFocus -&gt; c.frame.tree.canvas
    self.c = frame.c
    self.canvas = None
    super().__init__(frame)
</t>
<t tx="ekr.20150107090324.65">def select(self, p, scroll=True):
    # TODO Much more here: there's four hooks and all sorts of other things called in the TK version.
    c = self.c
    w = c.frame.body.bodyCtrl
    c.setCurrentPosition(p)
    # This is also where the body-text control is given the text of the selected node...
    # Always do this.    Otherwise there can be problems with trailing hewlines.
    w.setAllText(p.b)
    # and something to do with undo?
</t>
<t tx="ekr.20150107090324.66">def editLabel(self, v, selectAll=False, selection=None):
    pass # N/A?

def edit_widget(self, p):
    return None
</t>
<t tx="ekr.20150107090324.67">def text_draw_tree(self):

    g.pr('--- tree ---')
    self.draw_tree_helper(self.c.rootPosition(), indent=0)

def draw_tree_helper(self, p, indent):
    for p in p.self_and_siblings():
        if p.hasChildren():
            box = '+' if p.isExpanded() else '-'
        else:
            box = ' '
        icons = '%s%s%s%s' % (
            'b' if p.b else ' ',
            'm' if p.isMarked() else ' ',
            '@' if p.isCloned() else ' ',
            '*' if p.isDirty() else ' ')
        g.pr(" " * indent * 2, icons, box, p.h)
        if p.isExpanded() and p.hasChildren():
            self.draw_tree_helper(p.firstChild(), indent + 1)
</t>
<t tx="ekr.20150107090324.68">def finishCreate(self):
    pass
</t>
<t tx="ekr.20150107090324.69">def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    return 'yes'
</t>
<t tx="ekr.20150107090324.7">def __init__(self):
    super().__init__("text")
    self.frames = []
    self.killed = False
    # TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
</t>
<t tx="ekr.20150107090324.8">def createKeyHandlerClass(self, c):

    return leoKeys.KeyHandlerClass(c)
</t>
<t tx="ekr.20150107090324.9">def createLeoFrame(self, c, title=None):
    gui = self
    ret = TextFrame(c, gui)
    self.frames.append(ret)
    return ret
</t>
<t tx="ekr.20150204165040.4">def openAtShadowFileForReading(self, fn):
    """Open an @shadow for reading and return shadow_fn."""
    at = self
    x = at.c.shadowController
    # readOneAtShadowNode should already have checked these.
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = (g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn))
    if not shadow_exists:
        g.trace('can not happen: no private file',
            shadow_fn, g.callers())
        at.error(f"can not happen: private file does not exist: {shadow_fn}")
        return None
    # This method is the gateway to the shadow algorithm.
    x.updatePublicAndPrivateFiles(at.root, fn, shadow_fn)
    return shadow_fn
</t>
<t tx="ekr.20150204165040.5">def readOneAtCleanNode(self, root):
    '''Update the @clean/@nosent node at root.'''
    at, c, x = self, self.c, self.c.shadowController
    fileName = g.fullPath(c, root)
    if not g.os_path_exists(fileName):
        g.es_print(
            f"not found: {fileName}",
            color='red',
            nodeLink=root.get_UNL(with_proto=True))
        return False
    at.rememberReadPath(fileName, root)
    at.initReadIvars(root, fileName)
        # Must be called before at.scanAllDirectives.
    at.scanAllDirectives(root)
        # Sets at.startSentinelComment/endSentinelComment.
    new_public_lines = at.read_at_clean_lines(fileName)
    old_private_lines = self.write_at_clean_sentinels(root)
    marker = x.markerFromFileLines(old_private_lines, fileName)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    if old_public_lines:
        new_private_lines = x.propagate_changed_lines(
            new_public_lines, old_private_lines, marker, p=root)
    else:
        new_private_lines = []
        root.b = ''.join(new_public_lines)
        return True
    if new_private_lines == old_private_lines:
        return True
    if not g.unitTesting:
        g.es("updating:", root.h)
    root.clearVisitedInTree()
    gnx2vnode = at.fileCommands.gnxDict
    contents = ''.join(new_private_lines)
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    return True  # Errors not detected.
</t>
<t tx="ekr.20150204165040.7">def dump(self, lines, tag):
    """Dump all lines."""
    print(f"***** {tag} lines...\n")
    for s in lines:
        print(s.rstrip())
</t>
<t tx="ekr.20150204165040.8">def read_at_clean_lines(self, fn):
    '''Return all lines of the @clean/@nosent file at fn.'''
    at = self
    s = at.openFileHelper(fn)
        # Use the standard helper. Better error reporting.
        # Important: uses 'rb' to open the file.
    # #1798.
    if s is None:
        s = ''
    else:
        s = g.toUnicode(s, encoding=at.encoding)
        s = s.replace('\r\n', '\n')
            # Suppress meaningless "node changed" messages.
    return g.splitLines(s)
</t>
<t tx="ekr.20150204165040.9">def write_at_clean_sentinels(self, root):
    '''
    Return all lines of the @clean tree as if it were
    written as an @file node.
    '''
    at = self.c.atFileCommands
    result = at.atFileToString(root, sentinels=True)
    s = g.toUnicode(result, encoding=at.encoding)
    return g.splitLines(s)
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
</t>
<t tx="ekr.20150207044400.9">"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
from leo.core import leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()

</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    """
    Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule.
    """
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)

</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    """Create an entry in d for a string keyword."""
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return None
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)  # Don't require ending word.

    return forth_string_word_rule

</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList

</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    # #1821.
    def forth_rule20(colorer, s, i):
        return 0
        # return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            # at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.

properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {}  # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}


</t>
<t tx="ekr.20150326145530.4">class extendForth:
    """A helper class to extend the mode tables from @data forth-x settings."""

    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None  # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = []  # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False  # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    """Set our ivars from settings."""
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for (ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for (ivar, setting) in table2:
        self.splitList(ivar, setting)

</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    """Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2."""
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)

</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True)  # Require word.

    return forth_bracket_rule

</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2",  # defining word
            word=word,
            kind2="keyword3",  # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule

</t>
<t tx="ekr.20150326180928.1">def open_file(self, root):
    '''Open the the file in vim using c.openWith.'''
    c = self.c
    efc = g.app.externalFilesController
    # Common arguments.
    tab_arg = "-tab" if self.uses_tab else ""
    remote_arg = "--remote" + tab_arg + "-silent"
    args = [self.vim_exe, "--servername", "LEO", remote_arg] # No cursor arg.
    if self.entire_file:
        # vim-open-file
        args.append('+0') # Go to first line of the file. This is an Ex command.
        assert root.isAnyAtFileNode(), root
        dir_ = g.setDefaultDirectory(c, root)
        fn = c.expand_path_expression(root.anyAtFileNodeName()) # #1341.
        fn = c.os_path_finalize_join(dir_, fn)
    else:
        # vim-open-node
        args.append(self.get_cursor_arg())
            # Set the cursor position to the current line in the node.
        ext = 'txt'
        fn = efc.create_temp_file(c, ext, c.p)
    c_arg = '%s %s' % (' '.join(args), fn)
    command = 'subprocess.Popen(%s,shell=True)' % c_arg
    try:
        subprocess.Popen(c_arg, shell=True)
    except OSError:
        g.es_print(command)
        g.es_exception()
</t>
<t tx="ekr.20150402111403.1"></t>
<t tx="ekr.20150402111413.1">def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
</t>
<t tx="ekr.20150402111935.1">def sortCommandHistory(self):
    """Sort the command history."""
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
</t>
<t tx="ekr.20150402165918.1">def commandHistoryFwd(self):
    """
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) - 1:
            # fall off the bottom
            i = None
        elif i is not None:
            # move to next down in list
            i += 1
            commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150402171131.1">def commandHistoryBackwd(self):
    """
    Return the previous entry in the Command History - stay at the top
    if we are there
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i is None:
            # first time in - set to last entry
            i = len(h) - 1
        elif i &gt; 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150403094706.9">def __init__(self, c, e, *args):
    """Ctor for LineTextWidget."""
    super().__init__(*args)
    self.c = c
    self.setFrameStyle(self.StyledPanel | self.Sunken)
    self.edit = e  # A QTextEdit
    e.setFrameStyle(self.NoFrame)
    # e.setAcceptRichText(False)
    self.number_bar = NumberBar(c, e)
    hbox = QtWidgets.QHBoxLayout(self)
    hbox.setSpacing(0)
    hbox.setContentsMargins(0, 0, 0, 0)
    hbox.addWidget(self.number_bar)
    hbox.addWidget(e)
    e.installEventFilter(self)
    e.viewport().installEventFilter(self)
</t>
<t tx="ekr.20150404082344.1">def open_with(self, c, d):
    """
    Called by c.openWith to handle items in the Open With... menu.

    'd' a dict created from an @openwith settings node with these keys:

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
        'name':     menu label (used only by the menu code).
        'p':        the nearest @&lt;file&gt; node, or None.
        'shortcut': menu shortcut (used only by the menu code).
    """
    try:
        ext = d.get('ext')
        if not g.doHook('openwith1', c=c, p=c.p, v=c.p.v, d=d):
            root = d.get('p')
            if root:
                # Open the external file itself.
                directory = g.setDefaultDirectory(c, root)
                fn = c.expand_path_expression(root.anyAtFileNodeName())  # 1341
                path = g.os_path_finalize_join(directory, fn)  # 1341
                self.open_file_in_external_editor(c, d, path)
            else:
                # Open a temp file containing just the node.
                p = c.p
                ext = self.compute_ext(c, p, ext)
                path = self.compute_temp_file_path(c, p, ext)
                if path:
                    self.remove_temp_file(p, path)
                    self.create_temp_file(c, ext, p)
                    self.open_file_in_external_editor(c, d, path)
        g.doHook('openwith2', c=c, p=c.p, v=c.p.v, d=d)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()
</t>
<t tx="ekr.20150406055221.2">def clean_file_name(self, c, ext, p):
    """Compute the file name when subdirectories mirror the node's hierarchy in Leo."""
    use_extentions = c.config.getBool('open-with-uses-derived-file-extensions')
    ancestors, found = [], False
    for p2 in p.self_and_parents(copy=False):
        h = p2.anyAtFileNodeName()
        if not h:
            h = p2.h  # Not an @file node: use the entire header
        elif use_extentions and not found:
            # Found the nearest ancestor @&lt;file&gt; node.
            found = True
            base, ext2 = g.os_path_splitext(h)
            if p2 == p: h = base
            if ext2: ext = ext2
        ancestors.append(g.sanitize_filename(h))
    # The base directory is &lt;tempdir&gt;/Leo&lt;id(v)&gt;.
    ancestors.append("Leo" + str(id(p.v)))
    # Build temporary directories.
    td = os.path.abspath(tempfile.gettempdir())
    while len(ancestors) &gt; 1:
        td = os.path.join(td, ancestors.pop())
        if not os.path.exists(td):
            os.mkdir(td)
    # Compute the full path.
    name = ancestors.pop() + ext
    path = os.path.join(td, name)
    return path
</t>
<t tx="ekr.20150406055221.3">def legacy_file_name(self, c, ext, p):
    """Compute a legacy file name for unsupported operating systems."""
    try:
        leoTempDir = getpass.getuser() + "_" + "Leo"
    except Exception:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es(f"Temporary files will be stored in: {leoTempDir}")
    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)
    name = g.sanitize_filename(p.h) + '_' + str(id(p.v)) + ext
    path = os.path.join(td, name)
    return path
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425143043.1">def initCommandHistory(self):
    """Init command history from @data command-history nodes."""
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    """ reset the command history index to indicate that
        we are pointing 'past' the last entry
    """
    self.commandIndex = None
    #
</t>
<t tx="ekr.20150425145248.1">pylint
cov
moz
backup</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043714.3"></t>
<t tx="ekr.20150514043714.4">def beginCommand(self, w, undoType='Typing'):
    """Do the common processing at the start of each command."""
    c, p, u = self.c, self.c.p, self.c.undoer
    name = c.widget_name(w)
    if name.startswith('body'):
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch = ''
        b.name = name
        b.oldSel = w.getSelectionRange()
        b.oldText = p.b
        b.w = w
        b.undoType = undoType
        b.undoer_bunch = u.beforeChangeBody(p)  # #1733.
    else:
        self.undoData = None
    return w
</t>
<t tx="ekr.20150514043714.6">def endCommand(self, label=None, changed=True, setLabel=True):
    """
    Do the common processing at the end of each command.
    Handles undo only if we are in the body pane.
    """
    k, p, u= self.c.k, self.c.p, self.c.undoer
    w = self.editWidget(event=None)
    b = self.undoData
    if b and b.name.startswith('body') and changed:
        newText = w.getAllText()
        if b.undoType.capitalize() == 'Typing':
            u.doTyping(p, 'Typing', oldText=b.oldText, newText=newText, oldSel=b.oldSel)
        else:
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, b.undoType, b.undoer_bunch)
            
    self.undoData = None
    k.clearState()
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20150514043850.14">def find_place_holder(self, p, do_placeholder):
    """
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    """
    c = self.c
    # Do #438: Search for placeholder in headline.
    s = p.h
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is not None:
            p.h = new_s
            c.redraw(p)
            c.editHeadline()
            w = c.edit_widget(p)
            w.setSelectionRange(i, j, insert=j)
            return True
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='find-place-holder', oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        c.bodyWantsFocusNow()
        return True
    # #453: do nothing here.
        # c.frame.body.forceFullRecolor()
        # c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20150514043850.15">def make_script_substitutions(self, i, j, val):
    """Make scripting substitutions in node p."""
    c = self.c
    if not c.abbrev_subst_start:
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False
    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
        except Exception:
            g.es_print('exception evaluating', content)
            g.es_exception()
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None: x = ''
        val = f"{prefix}{x}{rest}"
        # Save the selection range.
        w = c.frame.body.wrapper
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        oldSel = i, j
        c.frame.body.onBodyChanged(undoType='make-script-substitution', oldSel=oldSel)
    return val, do_placeholder
</t>
<t tx="ekr.20150514043850.18">def replace_selection(self, w, i, j, s):
    """Replace w[i:j] by s."""
    w_name = g.app.gui.widget_name(w)
    c = self.c
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    if w_name.startswith('head'):
        pass  # Don't set p.h here!
    else:
        # Fix part of #438. Don't leave the headline.
        oldSel = j, j
        c.frame.body.onBodyChanged('Abbreviation', oldSel=oldSel)
    # Adjust self.save_sel &amp; self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
</t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150514063305.229">@
To do:
- Define standard icons in a subfolder of Icons folder?
- Tree control recomputes height of each line.
</t>
<t tx="ekr.20150514063305.230"></t>
<t tx="ekr.20150514063305.231">def appendImageDictToList(self, aList, path, xoffset, **kargs):
    c = self.c
    relPath = path  # for finding icon on load in different environment
    path = g.app.gui.getImageFinder(path)
    # pylint: disable=unpacking-non-sequence
    image, image_height = g.app.gui.getTreeImage(c, path)
    if not image:
        g.es('can not load image:', path)
        return xoffset
    if image_height is None:
        yoffset = 0
    else:
        yoffset = 0  # (c.frame.tree.line_height-image_height)/2
        # TNB: I suspect this is being done again in the drawing code
    newEntry = {
        'type': 'file',
        'file': path,
        'relPath': relPath,
        'where': 'beforeHeadline',
        'yoffset': yoffset, 'xoffset': xoffset, 'xpad': 1,  # -2,
        'on': 'VNode',
    }
    newEntry.update(kargs)  # may switch 'on' to 'VNode'
    aList.append(newEntry)
    xoffset += 2
    return xoffset
</t>
<t tx="ekr.20150514063305.232">def dHash(self, d):
    """Hash a dictionary"""
    return ''.join([f"{str(k)}{str(d[k])}" for k in sorted(d)])
</t>
<t tx="ekr.20150514063305.233">def getIconList(self, p):
    """Return list of icons for position p, call setIconList to apply changes"""
    fromVnode = []
    if hasattr(p.v, 'unknownAttributes'):
        fromVnode = [dict(i) for i in p.v.u.get('icons', [])]
        for i in fromVnode: i['on'] = 'VNode'
    return fromVnode
</t>
<t tx="ekr.20150514063305.234">def setIconList(self, p, l, setDirty=True):
    """Set list of icons for position p to l"""
    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return
    self._setIconListHelper(p, l, p.v, setDirty)
    if g.app.gui.guiName() == 'qt':
        self.c.frame.tree.updateAllIcons(p)
</t>
<t tx="ekr.20150514063305.235">def _setIconListHelper(self, p, subl, uaLoc, setDirty):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node
    """
    if subl:  # Update the uA.
        if not hasattr(uaLoc, 'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc._p_changed = 1
        if setDirty:
            p.setDirty()
    else:  # delete the uA.
        if hasattr(uaLoc, 'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc._p_changed = 1
                if setDirty:
                    p.setDirty()
</t>
<t tx="ekr.20150514063305.236">@cmd('delete-first-icon')
def deleteFirstIcon(self, event=None):
    """Delete the first icon in the selected node's icon list."""
    c = self.c
    aList = self.getIconList(c.p)
    if aList:
        self.setIconList(c.p, aList[1:])
        c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20150514063305.237">def deleteIconByName(self, t, name, relPath):  # t not used.
    """for use by the right-click remove icon callback"""
    c, p = self.c, self.c.p
    aList = self.getIconList(p)
    if not aList:
        return
    basePath = g.os_path_finalize_join(g.app.loadDir, "..", "Icons")  # #1341.
    absRelPath = g.os_path_finalize_join(basePath, relPath)  # #1341
    name = g.os_path_finalize(name)  # #1341
    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = g.os_path_finalize(name2)  # #1341
        name2rel = d.get('relPath')
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)
    if len(newList) != len(aList):
        self.setIconList(p, newList)
        c.setChanged()
        c.redraw_after_icons_changed()
    else:
        g.trace('not found', name)
</t>
<t tx="ekr.20150514063305.238">@cmd('delete-last-icon')
def deleteLastIcon(self, event=None):
    """Delete the first icon in the selected node's icon list."""
    c = self.c
    aList = self.getIconList(c.p)
    if aList:
        self.setIconList(c.p, aList[:-1])
        c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20150514063305.239">@cmd('delete-node-icons')
def deleteNodeIcons(self, event=None, p=None):
    """Delete all of the selected node's icons."""
    c = self.c
    p = p or c.p
    if p.u:
        p.v._p_changed = 1
        self.setIconList(p, [])
        p.setDirty()
        c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20150514063305.240">@cmd('insert-icon')
def insertIcon(self, event=None):
    """Prompt for an icon, and insert it into the node's icon list."""
    c, p = self.c, self.c.p
    iconDir = g.os_path_finalize_join(g.app.loadDir, "..", "Icons")
    os.chdir(iconDir)
    paths = g.app.gui.runOpenFileDialog(c,
        title='Get Icons',
        filetypes=[
            ('All files', '*'),
            ('Gif', '*.gif'),
            ('Bitmap', '*.bmp'),
            ('Icon', '*.ico'),
        ],
        defaultextension=None, multiple=True)
    if not paths: return
    aList = []
    xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList, path, xoffset)
    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged()
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20150514063305.241">def insertIconFromFile(self, path, p=None, pos=None, **kargs):
    c = self.c
    if not p: p = c.p
    aList = []
    xoffset = 2
    xoffset = self.appendImageDictToList(aList, path, xoffset, **kargs)
    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos, aList[0])
    self.setIconList(p, aList2)
    c.setChanged()
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20150514063305.244">@cmd('indent-relative')
def indentRelative(self, event):
    """
    The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.
    """
    c = self.c
    undoType = 'indent-relative'
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    # Find the previous non-blank line
    i, j = g.getLine(s, ins)
    while 1:
        if i &lt;= 0: return
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(w, undoType=undoType)
    try:
        k = g.skip_ws(s, i)
        ws = s[i:k]
        i2, j2 = g.getLine(s, ins)
        k = g.skip_ws(s, i2)
        line = ws + s[k:j2]
        w.delete(i2, j2)
        w.insert(i2, line)
        w.setInsertPoint(i2 + len(ws))
        c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
    finally:
        self.endCommand(changed=True, setLabel=True)
</t>
<t tx="ekr.20150514063305.278">@cmd('insert-file-name')
def insertFileName(self, event=None):
    """
    Prompt for a file name, then insert it at the cursor position.
    This operation is undoable if done in the body pane.

    The initial path is made by concatenating path_for_p() and the selected
    text, if there is any, or any path like text immediately preceding the
    cursor.
    """
    c, u, w = self.c, self.c.undoer, self.editWidget(event)
    if not w:
        return

    def callback(arg, w=w):
        i = w.getSelectionRange()[0]
        p = c.p
        w.deleteTextSelection()
        w.insert(i, arg)
        newText = w.getAllText()
        if g.app.gui.widget_name(w) == 'body' and p.b != newText:
            bunch = u.beforeChangeBody(p)
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, 'insert-file-name', bunch)

    # see if the widget already contains the start of a path

    start_text = w.getSelectedText()
    if not start_text:  # look at text preceeding insert point
        start_text = w.getAllText()[: w.getInsertPoint()]
        if start_text:
            # make non-path characters whitespace
            start_text = ''.join(i if i not in '\'"`()[]{}&lt;&gt;!|*,@#$&amp;' else ' '
                                 for i in start_text)
            if start_text[-1].isspace():  # use node path if nothing typed
                start_text = ''
            else:
                start_text = start_text.rsplit(None, 1)[-1]
                # set selection range so w.deleteTextSelection() works in the callback
                w.setSelectionRange(
                    w.getInsertPoint() - len(start_text), w.getInsertPoint())

    c.k.functionTail = g.os_path_finalize_join(
        self.path_for_p(c, c.p), start_text or '')
    c.k.getFileName(event, callback=callback)
</t>
<t tx="ekr.20150514063305.350">@cmd('show-all-uas')
def showAllUas(self, event=None):
    """Print all uA's in the outline."""
    g.es_print('Dump of uAs...')
    for v in self.c.all_unique_nodes():
        if v.u:
            self.showNodeUas(v=v)

@cmd('show-node-uas')
def showNodeUas(self, event=None, v=None):
    """Print the uA's in the selected node."""
    c = self.c
    if v:
        d, h = v.u, v.h
    else:
        d, h = c.p.v.u, c.p.h
    g.es_print(h)
    g.es_print(g.objToString(d))
</t>
<t tx="ekr.20150514063305.504">def change(self, event=None):
    """Make the selected change to the text"""
    if not self.loaded:
        return False
    c = self.c
    w = c.frame.body.wrapper
    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        i = getattr(self.tab, 'change_i', None)
        j = getattr(self.tab, 'change_j', None)
        if i is not None:
            start, end = i, j
            oldSel = start, end
        else:
            start, end = oldSel = w.getSelectionRange()
        if start is not None:
            if start &gt; end: start, end = end, start
            w.delete(start, end)
            w.insert(start, selection)
            w.setSelectionRange(start, start + len(selection))
            c.frame.body.onBodyChanged("Change", oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True
    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
</t>
<t tx="ekr.20150514125218.9">def get_fn(self, p):
    """
    Finalize p's file name.
    Return if p is not an @file node for a python file.
    """
    c = self.c
    if not p.isAnyAtFileNode():
        g.trace(f"not an @&lt;file&gt; node: {p.h!r}")
        return None
    # #67.
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    fn = p.anyAtFileNodeName()
    if not fn.endswith('.py'):
        g.trace(f"not a python file: {p.h!r}")
        return None
    return g.os_path_finalize_join(path, fn)
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150615174549.1">def show_find_options_in_status_area(self):  # pragma: no cover (cmd)
    """Show find options in the status area."""
    c = self.c
    s = self.compute_find_options_in_status_area()
    c.frame.putStatusLine(s)
</t>
<t tx="ekr.20150619070602.1">def show_status(self, found):
    """Show the find status the Find dialog, if present, and the status line."""
    c = self.c
    status = 'found' if found else 'not found'
    options = self.compute_result_status()
    s = f"{status}:{options} {self.find_text}"
    # Set colors.
    found_bg = c.config.getColor('find-found-bg') or 'blue'
    not_found_bg = c.config.getColor('find-not-found-bg') or 'red'
    found_fg = c.config.getColor('find-found-fg') or 'white'
    not_found_fg = c.config.getColor('find-not-found-fg') or 'white'
    bg = found_bg if found else not_found_bg
    fg = found_fg if found else not_found_fg
    if c.config.getBool("show-find-result-in-status") is not False:
        c.frame.putStatusLine(s, bg=bg, fg=fg)
</t>
<t tx="ekr.20150621062355.1">def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
</t>
<t tx="ekr.20150625123747.1">def get_delims(self, root):
    """Return the deliminters in effect at root."""
    c = self.c
    old_target_language = c.target_language
    try:
        c.target_language = g.getLanguageAtPosition(c, root)
        d = c.scanAllDirectives(root)
    finally:
        c.target_language = old_target_language
    delims1, delims2, delims3 = d.get('delims')
    if delims1:
        return delims1, None
    return delims2, delims3
</t>
<t tx="ekr.20150629072547.1">def preload_find_pattern(self, w):  # pragma: no cover (cmd)
    """Preload the find pattern from the selected text of widget w."""
    c, ftm = self.c, self.ftm
    if not c.config.getBool('preload-find-pattern', default=False):
        # Make *sure* we don't preload the find pattern if it is not wanted.
        return
    if not w:
        return
    #
    # #1436: Don't create a selection if there isn't one.
    #        Leave the search pattern alone!
    #
        # if not w.hasSelection():
        #     c.editCommands.extendToWord(event=None, select=True, w=w)
    #
    # #177:  Use selected text as the find string.
    # #1436: Make make sure there is a significant search pattern.
    s = w.getSelectedText()
    if s.strip():
        ftm.set_find_text(s)
        ftm.init_focus()
</t>
<t tx="ekr.20150629084204.1">@cmd('find-def')
def find_def(self, event=None, strict=False):  # pragma: no cover (cmd)
    """Find the def or class under the cursor."""
    ftm, p = self.ftm, self.c.p
    # Check.
    word = self._compute_find_def_word(event)
    if not word:
        return
    # Settings...
    prefix = 'class' if word[0].isupper() else 'def'
    find_pattern = prefix + ' ' + word
    ftm.set_find_text(find_pattern)
    self._save_before_find_def(p)  # Save previous settings.
    self.init_vim_search(find_pattern)
    self.update_change_list(self.change_text)  # Optional. An edge case.
    # Do the command!
    settings = self._compute_find_def_settings(find_pattern)
    self.do_find_def(settings, word, strict)

def find_def_strict(self, event=None):  #pragma: no cover (cmd)
    """Same as find_def, but don't call _switch_style."""
    self.find_def(event=event, strict=True)

def do_find_def(self, settings, word, strict):
    """A standalone helper for unit tests."""
    return self._fd_helper(settings, word, def_flag=True, strict=strict)

</t>
<t tx="ekr.20150629084611.1">def _compute_find_def_word(self, event):  # pragma: no cover (cmd)
    """Init the find-def command. Return the word to find or None."""
    c = self.c
    w = c.frame.body.wrapper
    # First get the word.
    c.bodyWantsFocusNow()
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    if keyword.iskeyword(word):
        return None
    # Return word, stripped of preceding class or def.
    for tag in ('class ', 'def '):
        found = word.startswith(tag) and len(word) &gt; len(tag)
        if found:
            return word[len(tag) :].strip()
    return word
</t>
<t tx="ekr.20150629095511.1">def _restore_after_find_def(self):
    """Restore find settings in effect before a find-def command."""
    b = self.find_def_data  # A g.Bunch
    if b:
        self.ignore_case = b.ignore_case
        self.pattern_match = b.pattern_match
        self.search_body = b.search_body
        self.search_headline = b.search_headline
        self.whole_word = b.whole_word
        self.find_def_data = None
</t>
<t tx="ekr.20150629095633.1">def _save_before_find_def(self, p):
    """Save the find settings in effect before a find-def command."""
    if not self.find_def_data:
        self.find_def_data = g.Bunch(
            ignore_case=self.ignore_case,
            p=p.copy(),
            pattern_match=self.pattern_match,
            search_body=self.search_body,
            search_headline=self.search_headline,
            whole_word=self.whole_word,
        )
</t>
<t tx="ekr.20150629125733.1">def _fd_helper(self, settings, word, def_flag, strict):
    """
    Find the definition of the class, def or var under the cursor.
    
    return p, pos, newpos for unit tests.
    """
    c, find, ftm = self.c, self, self.ftm
    #
    # Recompute find_text for unit tests.
    if def_flag:
        prefix = 'class' if word[0].isupper() else 'def'
        self.find_text = settings.find_text = prefix + ' ' + word
    else:
        self.find_text = settings.find_text = word + ' ='
    # g.printObj(settings, tag='_fd_helper: settings')
    #
    # Just search body text.
    self.search_headline = False
    self.search_body = True
    w = c.frame.body.wrapper
    # Check.
    if not w:  # pragma: no cover
        return None, None, None
    save_sel = w.getSelectionRange()
    ins = w.getInsertPoint()
    # Always start in the root position.
    old_p = c.p
    p = c.rootPosition()
    # Required.
    c.selectPosition(p)
    c.redraw()
    c.bodyWantsFocusNow()
    # #1592.  Ignore hits under control of @nosearch
    while True:
        p, pos, newpos = self.find_next_match(p)
        found = pos is not None
        if not found or not g.inAtNosearch(p):  # 2021/03/25: do *not* use c.p.
            break
    if not found and def_flag and not strict:
        # Leo 5.7.3: Look for an alternative defintion of function/methods.
        word2 = self._switch_style(word)
        p = c.rootPosition()  # Bug fix.
        if word2:
            find_pattern = prefix + ' ' + word2
            find.find_text = find_pattern
            ftm.set_find_text(find_pattern)
            # #1592.  Ignore hits under control of @nosearch
            while True:
                p, pos, newpos = self.find_next_match(p)
                found = pos is not None
                if not found or not g.inAtNosearch(p):
                    break
    if found:
        c.redraw(p)
        w.setSelectionRange(pos, newpos, insert=newpos)
        c.bodyWantsFocusNow()
        return p, pos, newpos
    self._restore_after_find_def()  # Avoid massive confusion!
    i, j = save_sel
    c.redraw(old_p)
    w.setSelectionRange(i, j, insert=ins)
    c.bodyWantsFocusNow()
    return None, None, None
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20150717105329.1">def _create_find_all_node(self, result):
    """Create a "Found All" node as the last node of the outline."""
    c = self.c
    found = c.lastTopLevel().insertAfter()
    assert found
    found.h = f"Found All:{self.find_text}"
    status = self.compute_result_status(find_all_flag=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    found.b = f"# {status}\n{''.join(result)}"
    return found
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160409035115.1">def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) &gt; -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) &gt; -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160422073500.1">def _find_all_helper(self, after, data, p, undoType):
    """Handle the find-all command from p to after."""
    c, u = self.c, self.c.undoer
    both = self.search_body and self.search_headline
    count, found, result = 0, None, []
    while 1:
        p, pos, newpos = self.find_next_match(p)
        if pos is None: break
        count += 1
        s = self.work_s
        i, j = g.getLine(s, pos)
        line = s[i:j]
        if self.findAllUniqueFlag:
            m = self.match_obj
            if m:
                self.unique_matches.add(m.group(0).strip())
        elif both:
            result.append('%s%s\n%s%s\n' % (
                '-' * 20, p.h,
                "head: " if self.in_headline else "body: ",
                line.rstrip() + '\n'))
        elif p.isVisited():
            result.append(line.rstrip() + '\n')
        else:
            result.append('%s%s\n%s' % ('-' * 20, p.h, line.rstrip() + '\n'))
            p.setVisited()
    if result or self.unique_matches:
        undoData = u.beforeInsertNode(c.p)
        if self.findAllUniqueFlag:
            found = self._create_find_unique_node()
            count = len(list(self.unique_matches))
        else:
            found = self._create_find_all_node(result)
        u.afterInsertNode(found, undoType, undoData)
        c.selectPosition(found)
        c.setChanged()
    else:
        self.restore(data)
    return count
</t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160516072613.5">def run(self, p=None, force=False, pyflakes_errors_only=False):
    """Run Pyflakes on all Python @&lt;file&gt; nodes in c.p's tree."""
    if not pyflakes:
        return True  # Pretend all is fine.
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    t1 = time.time()
    roots = g.findRootsWithPredicate(c, root, predicate=None)
    if roots:
        # These messages are important for clarity.
        log_flag = not force
        total_errors = self.check_all(log_flag, pyflakes_errors_only, roots)
        if total_errors &gt; 0:
            g.es(f"ERROR: pyflakes: {total_errors} error{g.plural(total_errors)}")
        elif force:
            g.es(
                f"OK: pyflakes: "
                f"{len(roots)} file{g.plural(roots)} "
                f"in {g.timeSince(t1)}")
        elif not pyflakes_errors_only:
            g.es('OK: pyflakes')
        ok = total_errors == 0
    else:
        ok = True
    return ok
</t>
<t tx="ekr.20160517133049.3">def find(self, p):
    """Return True and add p's path to self.seen if p is a Python @&lt;file&gt; node."""
    c = self.c
    found = False
    if p.isAnyAtFileNode():
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path, fn)
            if fn not in self.seen:
                self.seen.append(fn)
                found = True
    return found
</t>
<t tx="ekr.20160920110324.1">@cmd('clone-find-tag')
@cmd('find-clone-tag')
@cmd('cft')
def interactive_clone_find_tag(self, event=None):  # pragma: no cover (interactive)
    """
    clone-find-tag (aka find-clone-tag and cft).

    Create an organizer node whose descendants contain clones of all
    nodes matching the given tag, except @nosearch trees.

    The list is *always* flattened: every cloned node appears as a
    direct child of the organizer node, even if the clone also is a
    descendant of another cloned node.
    """
    w = self.c.frame.body.wrapper
    if w:
        self.start_state_machine(event,
            prefix='Clone Find Tag: ',
            handler=self.interactive_clone_find_tag1)

def interactive_clone_find_tag1(self, event):  # pragma: no cover (interactive)
    c, k = self.c, self.k
    # Settings...
    self.find_text = tag = k.arg
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_clone_find_tag(tag)
    c.treeWantsFocus()
</t>
<t tx="ekr.20160920164418.2">@cmd('tag-children')
def interactive_tag_children(self, event=None):  # pragma: no cover (interactive)
    """tag-children: prompt for a tag and add it to all children of c.p."""
    w = self.c.frame.body.wrapper
    if not w:
        return
    self.start_state_machine(event,
        prefix='Tag Children: ',
        handler=self.interactive_tag_children1)

def interactive_tag_children1(self, event):  # pragma: no cover (interactive)
    c, k, p = self.c, self.k, self.c.p
    # Settings...
    tag = k.arg
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_tag_children(p, tag)
    c.treeWantsFocus()
</t>
<t tx="ekr.20160920164418.4">def do_tag_children(self, p, tag):
    """Handle the tag-children command."""
    c = self.c
    tc = getattr(c, 'theTagController', None)
    if not tc:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print('nodetags not active')
        return
    for p in p.children():
        tc.add_tag(p, tag)
    if not g.unitTesting:  # pragma: no cover (skip)
        g.es_print(f"Added {tag} tag to {len(list(c.p.children()))} nodes")

</t>
<t tx="ekr.20160920221324.1">def convert_to_html(self, s):
    '''Convert s to html using docutils.'''
    c, p = self.c, self.c.p
    # Update the current path.
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    try:
        if self.title:
            s = self.underline(self.title) + s
            self.title = None
        # Call docutils to get the string.
        s = publish_string(s, writer_name='html')
        s = g.toUnicode(s)
    except SystemMessage as sm:
        msg = sm.args[0]
        if 'SEVERE' in msg or 'FATAL' in msg:
            s = 'RST error:\n%s\n\n%s' % (msg, s)
    return s

def update_plantuml(self, s, keywords):
    pc = self
    w = pc.ensure_text_widget()
    path = self.c.p.h[9:].strip()
    print("Plantuml output file name: ", path)
    with open("temp.plantuml", "w") as f:
        f.write(s)
    pth_plantuml_jar = "~/.leo"
    os.system("cat temp.plantuml | java -jar %s/plantuml.jar -pipe &gt; %s" % (pth_plantuml_jar, path))
    template = image_template % (path)
    # Only works in Python 3.x.
    template = g.adjustTripleString(template, pc.c.tab_width).strip()
    pc.show()
    w.setReadOnly(False)
    w.setHtml(template)
    w.setReadOnly(True)

def update_jinja(self, s, keywords):
    pc = self
    h = self.c.p.h
    p = self.c.p
    c = self.c
    oldp = None

    #print "try act"
    if not h.startswith('@jinja'):
        #print("Not a @jinja node")
        return

    def find_root(p):
        for newp in p.parents():
            if newp.h.strip() == '@jinja':
                oldp, p = p, newp
                #print("Found @jinja node")
                return oldp, p
        return None, None

    def find_inputs(p):
        for newp in p.parents():
            if newp.h.strip() == '@jinja inputs':
                oldp, p = p, newp
                _, p = find_root(p) 
                return oldp, p
        return None, None
        
    # if on jinja node's children, find the parent
    if h.strip() == '@jinja template' or h.strip() == '@jinja inputs':
        # not at @jinja, find from parents
        oldp, p = find_root(p)

    elif h.startswith('@jinja variable'):
        # not at @jinja, first find @jinja inputs, then @jinja
        oldp, p = find_inputs(p) 

    def untangle(c,p):
    
        return g.getScript(c,p,
            useSelectedText=False,
            useSentinels=False)

    template_data = {}
    for child in p.children():
        if child.h == '@jinja template':
            template_path = g.os_path_finalize_join(c.getNodePath(p), untangle(c, child).strip())
            #print("template_path: ", template_path)
        elif child.h == '@jinja inputs':
            for template_var_node in child.children():
                template_data[template_var_node.h.replace('@jinja variable', '').strip()] = untangle(c, template_var_node).strip()
            #print("template_data: ", template_data)

    if not template_path:
        g.es("No template_path given. Your @jinja node should contain a child node 'template' with the path to the template (relative or absolute)")
        return

    #print "act"
    tmpl = Template(Path(template_path).read_text())
    out = tmpl.render(template_data)
    w = pc.ensure_text_widget()
    pc.show()
    w.setPlainText(out)
    p.b = out
    c.redraw(p)
    
    # focus back on entry node
    if oldp:
        c.redraw(oldp)
    
</t>
<t tx="ekr.20161001114512.1">def write_leo_tree(self, f, window, root):
    '''Wriite the entire html file to f.'''
    root = root.copy()
    self.write_head(f, root.h, window)
    f.write('&lt;body&gt;')
    f.write('&lt;div class="container"&gt;')
    f.write('&lt;div class="outlinepane"&gt;')
    f.write('&lt;h1&gt;%s&lt;/h1&gt;' % window.shortFileName())
    for sib in root.self_and_siblings():
        self.write_node_and_subtree(f, sib)
    f.write('&lt;/div&gt;')
    f.write('&lt;/div&gt;')
    self.write_body_pane(f, root)
    f.write('&lt;/body&gt;&lt;/html&gt;')
</t>
<t tx="ekr.20161001121838.1">def write_head(self, f, headString, window):

    f.write("""&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;
    &lt;style&gt;%s&lt;/style&gt;
    &lt;style&gt;%s&lt;/style&gt;
    &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;
    &lt;/script&gt;
    &lt;script&gt;%s&lt;/script&gt;
    &lt;title&gt;%s&lt;/title&gt;
&lt;/head&gt;
""" % (
        getData('http_stylesheet'),
        getData('user_http_stylesheet'),
        getData('http_script'),
        (escape(window.shortFileName() + ":" + headString)))
    )
</t>
<t tx="ekr.20161001122919.1">def write_node_and_subtree(self, f, p):

    # This organization, with &lt;headline&gt; elements in &lt;node&gt; elements,
    # allows proper highlighting of nodes.
    f.write('&lt;div class="node" id=n:%s&gt;' % (
        quoteattr(p.gnx),
    ))
    f.write('&lt;div class="headline" id=h:%s expand="%s" icon="%02d" b=%s&gt;%s&lt;/div&gt;' % (
        quoteattr(p.gnx),
        '+' if p.hasChildren() else '-',
        p.computeIcon(),
        quoteattr(p.b),
        escape(p.h),
    ))
    for child in p.children():
        self.write_node_and_subtree(f, child)
    f.write('&lt;/div&gt;')
</t>
<t tx="ekr.20161001124752.1">def write_body_pane(self, f, p):

    f.write('&lt;div class="bodypane"&gt;')
    f.write('&lt;pre class="body-text"&gt;')
    f.write('&lt;code class="body-code"&gt;%s&lt;/code&gt;' % escape(p.b))
        # This isn't correct when put in a triple string.
        # We might be able to use g.adjustTripleString, but this works.
    f.write('&lt;/pre&gt;&lt;/div&gt;')
</t>
<t tx="ekr.20161020031633.1">"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    &lt;Return&gt; or (sometimes) &lt;tab&gt;.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        from leo.commands import checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
        return False
</t>
<t tx="ekr.20161029103615.1">class Py_Importer(Importer):
    '''A class to store and update scanning state.'''

    def __init__(self, importCommands, language='python', **kwargs):
        '''Py_Importer.ctor.'''
        super().__init__(
            importCommands,
            language=language,
            state_class = Python_ScanState,
            strict=True,
        )
        self.put_decorators = self.c.config.getBool('put-python-decorators-in-imported-headlines')

    @others
</t>
<t tx="ekr.20161108131153.10">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():
        return None
    self.root = root = parent.copy()
    self.file_s = s
    # Init the error/status info.
    self.errors = 0
    self.parse_body = parse_body
    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    ws_ok = self.check_blanks_and_tabs(s) # Only issues warnings.
    # Regularize leading whitespace
    if not ws_ok:
        s = self.regularize_whitespace(s)
    # Generate the nodes, including directives and section references.
    # Completely generate all nodes.
    self.generate_nodes(s, parent)
    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    if parse_body:
        ok = self.errors == 0 # Work around problems with directives.
    else:
        ok = self.errors == 0 and self.check(s, parent)
    g.app.unitTestDict['result'] = ok
    # Insert an @ignore directive if there were any serious problems.
    if not ok:
        self.insert_ignore_directive(parent)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return ok
</t>
<t tx="ekr.20161108131153.11">def check_blanks_and_tabs(self, lines):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in g.splitLines(lines):
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            self.report(message)
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20161108131153.12">def insert_ignore_directive(self, parent):
    c = self.c
    parent.v.b = parent.v.b.rstrip() + '\n@ignore\n'
        # Do *not* update the screen by setting p.b.
    if g.unitTesting:
        g.app.unitTestDict['fail'] = g.callers()
    elif parent.isAnyAtFileNode() and not parent.isAtAutoNode():
        g.warning('inserting @ignore')
        c.import_error_nodes.append(parent.h)
</t>
<t tx="ekr.20161108131153.13">def post_pass(self, parent):
    '''
    Optional Stage 2 of the importer pipeline, consisting of zero or more
    substages. Each substage alters nodes in various ways.

    Subclasses may freely override this method, **provided** that all
    substages use the API for setting body text. Changing p.b directly will
    cause asserts to fail later in i.finish().
    '''
    self.clean_all_headlines(parent)
    if self.add_context:
        self.add_class_names(parent)
    self.clean_all_nodes(parent)
    self.unindent_all_nodes(parent)
    #
    # This sub-pass must follow unindent_all_nodes.
    self.promote_trailing_underindented_lines(parent)
    self.promote_last_lines(parent)
    #
    # This probably should be the last sub-pass.
    self.delete_all_empty_nodes(parent)
</t>
<t tx="ekr.20161108131153.14">def regularize_whitespace(self, s):
    '''
    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    '''
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    lines = g.splitLines(s)
    count, result, tab_width = 0, [], self.tab_width
    self.ws_error = False # 2016/11/23
    if tab_width &lt; 0: # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
                # Use negative width.
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for n, line in enumerate(lines):
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
                # Use positive width.
            if s != line:
                count += 1
            result.append(s)
    if count:
        self.ws_error = True # A flag to check.
        if not g.unitTesting:
            # g.es_print('Warning: Intermixed tabs and blanks in', fn)
            # g.es_print('Perfect import test will ignoring leading whitespace.')
            g.es('changed leading %s to %s in %s line%s in %s' % (
                kind2, kind, count, g.plural(count), fn))
        if g.unitTesting: # Sets flag for unit tests.
            self.report('changed %s lines' % count)
    return ''.join(result)
</t>
<t tx="ekr.20161108131153.15"></t>
<t tx="ekr.20161108131153.17">def get_str_lws(self, s):
    '''Return the characters of the lws of s.'''
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20161108131153.18">def error(self, s):
    '''Issue an error and cause a unit test to fail.'''
    self.errors += 1
    self.importCommands.errors += 1

def report(self, message):
    if self.strict:
        self.error(message)
    else:
        self.warning(message)

def warning(self, s):
    if not g.unitTesting:
        g.warning('Warning:', s)
</t>
<t tx="ekr.20161108131153.19">def undent(self, p):
    '''Remove maximal leading whitespace from the start of all lines.'''
    if self.is_rst:
        return p.b # Never unindent rst code.
    lines = self.get_lines(p)
    ws = self.common_lws(lines)
    result = []
    for s in lines:
        if s.startswith(ws):
            result.append(s[len(ws):])
        elif s.isspace():
            # Never change blank lines.
            result.append(s)
        else:
            # Indicate that the line is underindented.
            result.append("%s%s.%s" % (
                self.c.atFileCommands.underindentEscapeString,
                g.computeWidth(ws, self.tab_width),
                s.lstrip()))
    return result
</t>
<t tx="ekr.20161108131153.20">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    if not lines:
        return ''
    lws = self.get_str_lws(lines[0])
    for s in lines:
        if not self.is_ws_line(s):
            lws2 = self.get_str_lws(s)
            if lws2.startswith(lws):
                pass
            elif lws.startswith(lws2):
                lws = lws2
            else:
                lws = '' # Nothing in common.
                break
    return lws
</t>
<t tx="ekr.20161108131153.21">def underindented_comment(self, line):
    if self.at_auto_warns_about_leading_whitespace:
        self.warning(
            'underindented python comments.\n' +
            'Extra leading whitespace will be added\n' + line)

def underindented_line(self, line):
    if self.warn_about_underindented_lines:
        self.error(
            'underindented line.\n'
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20161108131153.3">def check(self, unused_s, parent):
    '''True if perfect import checks pass.'''
    if g.app.suppressImportChecks:
        g.app.suppressImportChecks = False
        return True
    c = self.c
    sfn = g.shortFileName(self.root.h)
    s1 = g.toUnicode(self.file_s, self.encoding)
    s2 = self.trial_write()
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    if 0: # An excellent trace for debugging.
        g.trace(c.shortFileName())
        g.printObj(lines1, tag='lines1')
        g.printObj(lines2, tag='lines2')
    if self.strict:
        # Ignore blank lines only.
        # Adding nodes may add blank lines.
        lines1 = self.strip_blank_lines(lines1)
        lines2 = self.strip_blank_lines(lines2)
    else:
        # Ignore blank lines and leading whitespace.
        # Importing may regularize whitespace, and that's good.
        lines1 = self.strip_all(lines1)
        lines2 = self.strip_all(lines2)
    # Forgive trailing whitespace problems in the last line.
    # This is not the same as clean_last_lines.
    if lines1 and lines2 and lines1 != lines2:
        lines1[-1] = lines1[-1].rstrip()+'\n'
        lines2[-1] = lines2[-1].rstrip()+'\n'
    # self.trace_lines(lines1, lines2, parent)
    ok = lines1 == lines2
    if not ok and not self.strict:
        # Issue an error only if something *other than* lws is amiss.
        lines1, lines2 = self.strip_lws(lines1), self.strip_lws(lines2)
        ok = lines1 == lines2
        if ok and not g.unitTesting:
            print('warning: leading whitespace changed in:', self.root.h)
    if not ok:
        self.show_failure(lines1, lines2, sfn)
        # self.trace_lines(lines1, lines2, parent)
    # Ensure that the unit tests fail when they should.
    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        d['result'] = ok
        if not ok:
            d['fail'] = g.callers()
            # Used in a unit test.
            c.importCommands.errors += 1
    return ok
</t>
<t tx="ekr.20161108131153.4">def clean_blank_lines(self, lines):
    '''Remove all blanks and tabs in all blank lines.'''
    return [self.lstrip_line(z) if z.isspace() else z for z in lines]
</t>
<t tx="ekr.20161108131153.5">def lstrip_line(self, s):
    '''Delete leading whitespace, *without* deleting the trailing newline!'''
    # This fixes a major bug in strip_lws.
    assert s, g.callers()
    return '\n' if s.isspace() else s.lstrip()

def strip_all(self, lines):
    '''Strip blank lines and leading whitespace from all lines of s.'''
    return self.strip_lws(self.strip_blank_lines(lines))

def strip_blank_lines(self, lines):
    '''Strip all blank lines from s.'''
    return [z for z in lines if not z.isspace()]

def strip_lws(self, lines):
    '''Strip leading whitespace from all lines.'''
    return [self.lstrip_line(z) for z in lines]
    # This also works, but I prefer the "extra" call to lstrip().
    # return ['\n' if z.isspace() else z.lstrip() for z in lines].


</t>
<t tx="ekr.20161108131153.6">def trial_write(self):
    '''Return the trial write for self.root.'''
    at = self.c.atFileCommands
    # Leo 5.6: Allow apparent section refs for *all* languages.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        result = at.atAutoToString(self.root)
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
    return g.toUnicode(result, self.encoding)
</t>
<t tx="ekr.20161108131153.7"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161108131153.8">def adjust_parent(self, parent, headline):
    '''Return the effective parent.

    This is overridden by the RstScanner class.'''
    return parent
</t>
<t tx="ekr.20161108131153.9">def clean_headline(self, s, p=None):
    '''
    Return the cleaned version headline s.
    Will typically be overridden in subclasses.
    '''
    return s.strip()
</t>
<t tx="ekr.20161108155143.3">def get_int_lws(self, s):
    '''Return the the lws (a number) of line s.'''
    # Important: use self.tab_width, *not* c.tab_width.
    return g.computeLeadingWhitespaceWidth(s, self.tab_width)
</t>
<t tx="ekr.20161108155143.4">def match(self, s, i, pattern):
    '''Return True if the pattern matches at s[i:]'''
    return s[i:i+len(pattern)] == pattern
</t>
<t tx="ekr.20161108155730.1">class Importer:
    '''
    The new, unified, simplified, interface to Leo's importer code.

    Eventually, all importers will create use this class.
    '''

    @others
</t>
<t tx="ekr.20161108155925.1">def __init__(self,
    importCommands,
    gen_refs=False, # True: generate section references,
    language=None, # For @language directive.
    name=None, # The kind of importer, usually the same as language
    state_class=None, # For i.scan_line
    strict=False,
    **kwargs
):
    '''
    Importer.__init__: New in Leo 6.1.1: ic and c may be None for unit tests.
    '''
    # Copies of args...
    self.importCommands = ic = importCommands
    self.c = c = ic and ic.c
    self.encoding = ic and ic.encoding or 'utf-8'
    self.gen_refs = gen_refs
    self.language = language or name
        # For the @language directive.
    self.name = name or language
    language = self.language
    name = self.name
    assert language and name
    assert self.language and self.name
    self.state_class = state_class
    self.strict = strict
        # True: leading whitespace is significant.
    #
    # Set from ivars...
    self.has_decls = name not in ('xml', 'org-mode', 'vimoutliner')
    self.is_rst = name in ('rst',)
    self.tree_type = ic.treeType if c else None # '@root', '@file', etc.
    #
    # Constants...
    if ic:
        data = g.set_delims_from_language(self.name)
        self.single_comment, self.block1, self.block2 = data
    else:
        self.single_comment, self.block1, self.block2 = '//', '/*', '*/' # Javascript.
    if ic:
        self.escape = c.atFileCommands.underindentEscapeString
        self.escape_string = r'%s([0-9]+)\.' % re.escape(self.escape)
        # m.group(1) is the unindent value.
        self.escape_pattern = re.compile(self.escape_string)
    self.ScanState = ScanState
        # Must be set by subclasses that use general_scan_line.
    self.tab_width = 0 # Must be set in run, using self.root.
    self.ws_pattern = re.compile(r'^\s*$|^\s*%s' % (self.single_comment or ''))
    #
    # Settings...
    self.reloadSettings()
    #
    # State vars.
    self.errors = 0
    if ic:
        ic.errors = 0 # Required.
    self.parse_body = False
    self.refs_dict = {}
        # Keys are headlines. Values are disambiguating number.
    self.skip = 0 # A skip count for x.gen_lines &amp; its helpers.
    self.ws_error = False
    self.root = None

def reloadSettings(self):
    c = self.c
    if not c:
        return
    getBool = c.config.getBool
    c.registerReloadSettings(self)
    # self.at_auto_separate_non_def_nodes = False
    self.add_context = getBool("add-context-to-headlines")
    self.add_file_context = getBool("add-file-context-to-headlines")
    self.at_auto_warns_about_leading_whitespace = getBool('at_auto_warns_about_leading_whitespace')
    self.warn_about_underindented_lines = True
   
</t>
<t tx="ekr.20161108160409.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    trace = 'importers' in g.app.debug
    tail_p = None
    prev_state = self.state_class()
    target = Target(parent, prev_state)
    stack = [target, target]
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        # g.trace(new_state.level(), f"{new_state.level() &lt; top.state.level():1}", repr(line))
        if trace:
            g.trace('%d %d %s' % (
                self.starts_block(i, lines, new_state, prev_state),
                self.ends_block(line, new_state, prev_state, stack),
                line.rstrip()))
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.is_ws_line(line):
            p = tail_p or top.p
            self.add_line(p, line)
        elif self.starts_block(i, lines, new_state, prev_state):
            tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif self.ends_block(line, new_state, prev_state, stack):
            tail_p = self.end_block(line, new_state, stack)
        else:
            p = tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
</t>
<t tx="ekr.20161108160409.3">def end_block(self, line, new_state, stack):
    # The block is ending. Add tail lines until the start of the next block.
    p = stack[-1].p
    self.add_line(p, line)
    self.cut_stack(new_state, stack)
    tail_p = None if self.gen_refs else p
    return tail_p
</t>
<t tx="ekr.20161108160409.5">def add_root_directives(self, parent):
    '''Return the proper directives for the root node p.'''
    table = [
        '@language %s\n' % self.language,
        '@tabwidth %d\n' % self.tab_width,
    ]
    if self.parse_body:
        pass
    elif self.has_lines(parent):
        # Make sure the last line ends with a newline.
        lines = self.get_lines(parent)
        if lines:
            last_line = lines.pop()
            last_line = last_line.rstrip() + '\n'
            self.add_line(parent, last_line)
        self.extend_lines(parent, table)
    else:
        self.set_lines(parent, table)
</t>
<t tx="ekr.20161108160409.6">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    if hasattr(new_state, 'in_context'):
        assert not new_state.in_context(), ('start_new_block', new_state)
    line = lines[i]
    target=stack[-1]
    # Insert the reference in *this* node.
    h = self.gen_ref(line, target.p, target)
    # Create a new child and associated target.
    child = self.create_child_node(target.p, line, h)
    stack.append(Target(child, new_state))
</t>
<t tx="ekr.20161108160409.7">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline.strip()
    return child
</t>
<t tx="ekr.20161108160409.8">def gen_ref(self, line, parent, target):
    '''
    Generate the ref line. Return the headline.
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if self.gen_refs:
        # Fix #441: Make sure all section refs are unique.
        d = self.refs_dict
        n = d.get(h, 0)
        d [h] = n + 1
        if n &gt; 0:
            h = '%s: %s' % (n, h)
        headline = g.angleBrackets(' %s ' % h)
        ref = '%s%s\n' % (
            indent_ws,
            g.angleBrackets(' %s ' % h))
    else:
        if target.ref_flag:
            ref = None
        else:
            ref = '%s@others\n' % indent_ws
            target.at_others_flag = True
        target.ref_flag = True
            # Don't generate another @others in this target.
        headline = h
    if ref:
        self.add_line(parent,ref)
    return headline
</t>
<t tx="ekr.20161108165530.1"></t>
<t tx="ekr.20161108170435.1">def scan_line(self, s, prev_state):
    '''
    A generalized scan-line method.

    SCAN STATE PROTOCOL:

    The Importer class should have a state_class ivar that references a
    **state class**. This class probably should *not* be subclass of the
    ScanState class, but it should observe the following protocol:

    1. The state class's ctor must have the following signature:

        def __init__(self, d)

    2. The state class must have an update method.
    '''
    # This dict allows new data to be added without changing ScanState signatures.
    d = {
        'indent': self.get_int_lws(s),
        'is_ws_line': self.is_ws_line(s),
        'prev':prev_state,
        's':s,
    }
    new_state = self.state_class(d)
    i = 0
    while i &lt; len(s):
        progress = i
        context = new_state.context
        table = self.get_table(context)
        data = self.scan_dict(context, i, s, table)
        i = new_state.update(data)
        assert progress &lt; i
    return new_state
</t>
<t tx="ekr.20161108180655.2">def undent_by(self, s, undent_val):
    '''
    Remove leading whitespace equivalent to undent_val from each line.

    Strict languages: prepend the underindent escape for underindented lines.
    '''
    if self.is_rst:
        return s # Never unindent rst code.
    result = []
    for line in g.splitlines(s):
        lws_s = self.get_str_lws(line)
        lws = g.computeWidth(lws_s, self.tab_width)
        # Add underindentEscapeString only for strict languages.
        if self.strict and not line.isspace() and lws &lt; undent_val:
            # End the underindent count with a period to
            # protect against lines that start with a digit!
            result.append("%s%s.%s" % (
                self.escape, undent_val-lws, line.lstrip()))
        else:
            s = g.removeLeadingWhitespace(line, undent_val, self.tab_width)
            result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20161109045312.1"></t>
<t tx="ekr.20161109045619.1">def print_lines(self, lines):
    '''Print lines for debugging.'''
    print('[')
    for line in lines:
        print(repr(line))
    print(']')

print_list = print_lines
</t>
<t tx="ekr.20161109052011.1">def is_ws_line(self, s):
    '''Return True if s is nothing but whitespace and single-line comments.'''
    return bool(self.ws_pattern.match(s))
</t>
<t tx="ekr.20161109053143.1">def get_leading_indent(self, lines, i, ignoreComments=True):
    '''
    Return the leading whitespace (an int) of the first significant line.
    Ignore blank and comment lines if ignoreComments is True
    '''
    if ignoreComments:
        while i &lt; len(lines):
            if self.is_ws_line(lines[i]):
                i += 1
            else:
                break
    return self.get_int_lws(lines[i]) if i &lt; len(lines) else 0
</t>
<t tx="ekr.20161109072221.1">def undent_body_lines(self, lines, ignoreComments=True):
    '''
    Remove the first line's leading indentation from all lines.
    Return the resulting string.
    '''
    s = ''.join(lines)
    if self.is_rst:
        return s # Never unindent rst code.
    # Calculate the amount to be removed from each line.
    undent_val = self.get_leading_indent(lines, 0, ignoreComments=ignoreComments)
    if undent_val == 0:
        return s
    result = self.undent_by(s, undent_val)
    return result
</t>
<t tx="ekr.20161110042020.1">def finalize_ivars(self, parent):
    '''
    Update the body text of all nodes in parent's tree using the injected
    v._import_lines lists.
    '''
    for p in parent.self_and_subtree():
        v = p.v
        # Make sure that no code in x.post_pass has mistakenly set p.b.
        assert not v._bodyString, repr(v._bodyString)
        lines = v._import_lines
        if lines:
            if not lines[-1].endswith('\n'):
                lines[-1] += '\n'
        v._bodyString = g.toUnicode(''.join(lines), reportErrors=True)
            # Bug fix: 2017/01/24: must convert to unicode!
            # This was the source of the internal error in the p.b getter.
        delattr(v, '_import_lines')
</t>
<t tx="ekr.20161110042512.1"># All code in passes 1 and 2 *must* use this API to change body text.

def add_line(self, p, s):
    '''Append the line s to p.v._import_lines.'''
    assert s and isinstance(s, str), (repr(s), g.callers())
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (repr(s), g.callers())
    p.v._import_lines.append(s)

def clear_lines(self, p):
    p.v._import_lines = []

def extend_lines(self, p, lines):
    p.v._import_lines.extend(list(lines))

def get_lines(self, p):
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (p and p.h, g.callers())
    return p.v._import_lines

def has_lines(self, p):
    return hasattr(p.v, '_import_lines')

def inject_lines_ivar(self, p):
    '''Inject _import_lines into p.v.'''
    # *Never* change p unexpectedly!
    assert not p.v._bodyString, (p and p.h, g.callers(10))
    p.v._import_lines = []

def prepend_lines(self, p, lines):
    p.v._import_lines = list(lines) + p.v._import_lines

def set_lines(self, p, lines):
    p.v._import_lines = list(lines)
</t>
<t tx="ekr.20161110073751.1">def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    if p: # Called from clean_all_headlines:
        return self.get_decorator(p) + p.h
    # Handle defs.
    m = re.match(r'\s*def\s+(\w+)', s)
    if m:
        return m.group(1)
    # Handle classes.
    #913: Show base classes in python importer.
    #978: Better regex handles class C(bar.Bar)
    m = re.match(r'\s*class\s+(\w+)\s*(\([\w.]+\))?', s)
    if m:
        return 'class %s%s' % (m.group(1), m.group(2) or '')
    return s.strip()

def get_decorator(self, p):
    if g.unitTesting or self.put_decorators:
        for s in self.get_lines(p):
            if not s.isspace():
                m = re.match(r'\s*@\s*([\w\.]+)', s)
                if m:
                    s = s.strip()
                    if s.endswith('('):
                        s = s[:-1].strip()
                    return s + ' '
                return ''
    return ''
</t>
<t tx="ekr.20161110125940.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Note: i.gen_ref calls clean_headline without knowing p.
        # As a result, the first argument is required.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
    
</t>
<t tx="ekr.20161110130157.1">def clean_all_nodes(self, parent):
    '''Clean the nodes in parent's tree, in a language-dependent way.'''
    # i.clean_nodes does nothing.
    # Subclasses may override as desired.
    # See perl_i.clean_nodes for an example.
    self.clean_nodes(parent)
</t>
<t tx="ekr.20161110130337.1">def unindent_all_nodes(self, parent):
    '''Unindent all nodes in parent's tree.'''
    for p in parent.subtree():
        lines = self.get_lines(p)
        if all(z.isspace() for z in lines):
            # Somewhat dubious, but i.check covers for us.
            self.clear_lines(p)
        else:
            self.set_lines(p, self.undent(p))
</t>
<t tx="ekr.20161110130709.1">def delete_all_empty_nodes(self, parent):
    '''
    Delete nodes consisting of nothing but whitespace.
    Move the whitespace to the preceding node.
    '''
    c = self.c
    aList = []
    for p in parent.subtree():
        back = p.threadBack()
        if back and back.v != parent.v and back.v != self.root.v and not p.isCloned():
            lines = self.get_lines(p)
            # Move the whitespace from p to back.
            if all(z.isspace() for z in lines):
                self.extend_lines(back, lines)
                # New in Leo 5.7: empty nodes may have children.
                if p.hasChildren():
                    # Don't delete p.
                    p.h = 'organizer'
                    self.clear_lines(p)
                else:
                    # Do delete p.
                    aList.append(p.copy())
    if aList:
        c.deletePositionsInList(aList, redraw=False)
            # Suppress redraw.
</t>
<t tx="ekr.20161110131509.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.subtree():
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    g.trace(line)
                    # Fix #652 by restoring the line.
                    new_line = line[len(m.group(0)):].lstrip()
                    lines.append(new_line)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            if parent.parent() == self.root:
                parent = parent.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161110173058.1">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161111023249.1">def finish(self, parent):
    '''
    Stage 3 (the last) stage of the importer pipeline.

    Subclasses should never need to override this method.
    '''
    # Put directives at the end, so as not to interfere with shebang lines, etc.
    self.add_root_directives(parent)
    #
    # Finally, remove all v._import_list temporaries.
    self.finalize_ivars(parent)
</t>
<t tx="ekr.20161111024447.1">def generate_nodes(self, s, parent):
    '''
    A three-stage pipeline to generate all imported nodes.
    '''
    # Stage 1: generate nodes.
    # After this stage, the p.v._import_lines list contains p's future body text.
    self.gen_lines(s, parent)
    #
    # Optional Stage 2, consisting of zero or more sub-stages.
    # Subclasses may freely override this method, **provided**
    # that all substages use the API for setting body text.
    # Changing p.b directly will cause asserts to fail in i.finish().
    self.post_pass(parent)
    #
    # Stage 3: Put directives in the root node and set p.b for all nodes.
    #
    # Subclasses should never need to override this stage.
    self.finish(parent)
</t>
<t tx="ekr.20161113135037.1">@nobeautify
cached_scan_tables = {}

def get_table(self, context):
    '''
    Return the state table for the given context.

    This method handles caching.  x.get_new_table returns the actual table.
    '''
    key = '%s.%s' % (self.name, context)
        # Bug fix: must keep tables separate.
    table = self.cached_scan_tables.get(key)
    if table:
        return table
    table = self.get_new_dict(context)
    self.cached_scan_tables[key] = table
    return table
</t>
<t tx="ekr.20161114012522.1">def all_contexts(self, table):
    '''
    Return a list of all contexts contained in the third column of the given table.

    This is a support method for unit tests.
    '''
    contexts = set()
    d = table
    for key in d:
        aList = d.get(key)
        for data in aList:
            if len(data) == 4:
                # It's an out-of-context entry.
                contexts.add(data[2])
    # Order must not matter, so sorting is ok.
    return sorted(contexts)
</t>
<t tx="ekr.20161114024119.1">def test_scan_state(self, tests, State):
    '''
    Test x.scan_line or i.scan_line.

    `tests` is a list of g.Bunches with 'line' and 'ctx' fields.

    A typical @command test:

        if c.isChanged(): c.save()
        &lt; &lt; imp.reload importers.linescanner and importers.python &gt; &gt;
        importer = py.Py_Importer(c.importCommands)
        importer.test_scan_state(tests, Python_ScanState)
    '''
    assert self.single_comment == '#', self.single_comment
    table = self.get_table(context='')
    contexts = self.all_contexts(table)
    for bunch in tests:
        assert bunch.line is not None
        line = bunch.line
        ctx = getattr(bunch, 'ctx', None)
        if ctx: # Test one transition.
            ctx_in, ctx_out = ctx
            prev_state =  State()
            prev_state.context = ctx_in
            new_state = self.scan_line(line, prev_state)
            new_context = new_state.context
            assert new_context == ctx_out, (
                'FAIL1:\nline: %r\ncontext: %r new_context: %r ctx_out: %r\n%s\n%s' % (
                    line, ctx_in, new_context, ctx_out, prev_state, new_state))
        else: # Test all transitions.
            for context in contexts:
                prev_state =  State()
                prev_state.context = context
                new_state = self.scan_line(line, prev_state)
                assert new_state.context == context, (
                    'FAIL2:\nline: %r\ncontext: %r new_context: %r\n%s\n%s' % (
                        line, context, new_state.context, prev_state, new_state))
</t>
<t tx="ekr.20161116034633.2">def cut_stack(self, new_state, stack, append=False):
    '''Cut back the stack until stack[-1] matches new_state.'''
    # pylint: disable=arguments-differ
    assert len(stack) &gt; 1 # Fail on entry.
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            assert len(stack) &gt; 1, stack # &lt;
            stack.pop()
        elif top_state.level() == new_state.level():
            assert len(stack) &gt; 1, stack # ==
            if append:
                pass # Append line to the previous node.
            else:
                stack.pop() # Create a new node.
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    assert len(stack) &gt; 1 # Fail on exit.
</t>
<t tx="ekr.20161116034633.7">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    assert not prev_state.in_context(), prev_state
    line = lines[i]
    top = stack[-1]
    # Adjust the stack.
    if new_state.indent &gt; top.state.indent:
        pass
    elif new_state.indent == top.state.indent:
        stack.pop()
    else:
        self.cut_stack(new_state, stack)
    # Create the child.
    top = stack[-1]
    parent = top.p
    self.gen_ref(line, parent, top)
    h = self.clean_headline(line, p=None)
    child = self.create_child_node(parent, line, h)
    self.prepend_lines(child, self.decorator_lines)
    self.decorator_lines = []
    target = PythonTarget(child, new_state)
    target.kind = 'class' if h.startswith('class') else 'def'
    stack.append(target)
</t>
<t tx="ekr.20161116040557.1">starts_pattern = re.compile(r'\s*(class|def)\s+')
    # Matches lines that apparently start a class or def.

def starts_block(self, i, lines, new_state, prev_state, stack):
    '''True if the line startswith class or def outside any context.'''
    # pylint: disable=arguments-differ
    if prev_state.in_context():
        return False
    line = lines[i]
    m = self.starts_pattern.match(line)
    if not m:
        return False
    top = stack[-1]
    prev_indent = top.state.indent
    if top.kind == 'None' and new_state.indent &gt; 0:
        # Underindented top-level class/def.
        return False
    if top.kind == 'def' and new_state.indent &gt; prev_indent:
        # class/def within a def.
        # #1493: Insert decorators.
        p = self.tail_p or top.p
        for line in self.decorator_lines:
            self.add_line(p, line)
        return False
    if top.at_others_flag and new_state.indent &gt; prev_indent:
        return False
    return True
</t>
<t tx="ekr.20161116173901.1">def end_block(self, i, lines, new_state, prev_state, stack):
    '''
    Handle a line that terminates the previous class/def. The line is
    neither a class/def line, and we are not in a multi-line token.

    Skip all lines that are at the same level as the class/def.
    '''
    # pylint: disable=arguments-differ
    top = stack[-1]
    assert new_state.indent &lt; top.state.indent, (
        '\nnew: %s\ntop: %s' % (new_state, top.state))
    assert self.skip == 0, self.skip
    end_indent = new_state.indent
    while i &lt; len(lines):
        progress = i
        self.cut_stack(new_state, stack, append=True)
        top = stack[-1]
        # Add the line.
        line = lines[i]
        self.add_line(top.p, line)
        # Move to the next line.
        i += 1
        if i &gt;= len(lines):
            break
        prev_state = new_state
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
            break
        elif not self.is_ws_line(line) and new_state.indent &lt;= end_indent:
            break
        else:
            self.skip += 1
        assert progress &lt; i, repr(line)
    return top.p
</t>
<t tx="ekr.20161119083054.1">def find_class(self, parent):
    '''
    Find the start and end of a class/def in a node.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    '''
    # Called from Leo's core to implement two minor commands.
    prev_state = Python_ScanState()
    target = Target(parent, prev_state)
    stack = [target, target]
    lines = g.splitlines(parent.b)
    index = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
                # Bug fix 2019/06/05: added "stack" arg(!)
            return self.skip_block(i, index, lines, new_state, stack)
        prev_state = new_state
        index += len(line)
    return None, -1, -1
</t>
<t tx="ekr.20161119124217.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    return new_state.level() &gt; prev_state.level()
</t>
<t tx="ekr.20161119130337.1">def cut_stack(self, new_state, stack):
    '''Cut back the stack until stack[-1] matches new_state.'''
    
    def underflow(n):
        g.trace(n)
        g.trace(new_state)
        g.printList(stack)
        
    # assert len(stack) &gt; 1 # Fail on entry.
    if len(stack) &lt;= 1:
        return underflow(0)
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            if len(stack) &gt; 1:
                stack.pop()
            else:
                return underflow(1)
        elif top_state.level() == new_state.level():
            # assert len(stack) &gt; 1, stack # ==
            # This is the only difference between i.cut_stack and python/cs.cut_stack
            if len(stack) &lt;= 1:
                return underflow(2)
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    elif len(stack) &lt;= 1:
        return underflow(3)
    return None
</t>
<t tx="ekr.20161119161953.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    self.tail_p = None
    prev_state = self.state_class()
    target = PythonTarget(parent, prev_state)
    stack = [target, target]
    self.decorator_lines = []
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    first = True
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.starts_decorator(i, lines, new_state):
            pass # Sets self.skip and self.decorator_lines.
        elif self.starts_block(i, lines, new_state, prev_state, stack):
            first = False
            self.tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif first:
            if self.is_ws_line(line):
                p = self.tail_p or top.p
                self.add_line(p, line)
            else:
                first = False
                h = 'Declarations'
                self.gen_ref(line, parent, target)
                p = self.create_child_node(parent, body=line, headline=h)
                stack.append(PythonTarget(p, new_state))
        elif self.ends_block(line, new_state, prev_state, stack):
            first = False
            self.tail_p = self.end_block(i, lines, new_state, prev_state, stack)
        else:
            p = self.tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
    if self.skip:
        g.trace('can not happen: self.skip &gt; 0', color='red')
    if self.decorator_lines:
        g.trace('can not happen: unused decorator lines...', color='red')
        g.printObj(self.decorator_lines)

</t>
<t tx="ekr.20161119162451.1">def trace_status(self, line, new_state, prev_state, stack, top):
    '''Print everything important in the i.gen_lines loop.'''
    print('')
    try:
        g.trace('===== %r' % line)
    except Exception:
        g.trace('     top.p: %s' % g.toEncodedString(top.p.h))
    # print('len(stack): %s' % len(stack))
    print(' new_state: %s' % new_state)
    print('prev_state: %s' % prev_state)
    # print(' top.state: %s' % top.state)
    g.printList(stack)
</t>
<t tx="ekr.20161120022121.1"></t>
<t tx="ekr.20161123210335.1">def trace_lines(self, lines1, lines2, parent):
    '''Show both s1 and s2.'''
    print('===== s1: %s' % parent.h)
    for i, s in enumerate(lines1):
        g.pr('%3s %r' % (i+1, s))
    print('===== s2')
    for i, s in enumerate(lines2):
        g.pr('%3s %r' % (i+1, s))
</t>
<t tx="ekr.20161123210716.1">def show_failure(self, lines1, lines2, sfn):
    '''Print the failing lines, with surrounding context.'''
    if not g.unitTesting:
        g.es('@auto failed:', sfn, color='red')
    n1, n2 = len(lines1), len(lines2)
    print('\n===== PERFECT IMPORT FAILED =====', sfn)
    print('len(s1): %s len(s2): %s' % (n1, n2))
    for i in range(min(n1, n2)):
        line1, line2 = lines1[i], lines2[i]
        if line1 != line2:
            print('first mismatched line: %s' % (i+1))
            print('s1...')
            print(''.join(self.context_lines(lines1, i)))
            print('s2...')
            print(''.join(self.context_lines(lines2, i)))
            # print(repr(line1))
            # print(repr(line2))
            break
    else:
        print('all common lines match')
</t>
<t tx="ekr.20161124030004.1">def clean_last_lines(self, lines):
    '''Remove blank lines from the end of lines.'''
    while lines and lines[-1].isspace():
        lines.pop()
    return lines
</t>
<t tx="ekr.20161125174423.1">def print_stack(self, stack):
    '''Print a stack of positions.'''
    g.printList([p.h for p in stack])
</t>
<t tx="ekr.20161127102339.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161128025444.1">def scan_dict(self, context, i, s, d):
    '''
    i.scan_dict: Scan at position i of s with the give context and dict.
    Return the 6-tuple: (new_context, i, delta_c, delta_p, delta_s, bs_nl)
    '''
    found = False
    delta_c = delta_p = delta_s = 0
    ch = s[i]
    aList = d.get(ch)
    if aList and context:
        # In context.
        for data in aList:
            kind, pattern, ends = data
            if self.match(s, i, pattern):
                if ends is None:
                    found = True
                    new_context = context
                    break
                elif ends:
                    found = True
                    new_context = ''
                    break
                else:
                    pass # Ignore this match.
    elif aList:
        # Not in context.
        for data in aList:
            kind, pattern, new_context, deltas = data
            if self.match(s, i, pattern):
                found = True
                if deltas:
                    delta_c, delta_p, delta_s = deltas
                break
    if found:
        if kind == 'all':
            i = len(s)
        elif kind == 'len+1':
            i += (len(pattern) + 1)
        else:
            assert kind == 'len', (kind, self.name)
            i += len(pattern)
        bs_nl = pattern == '\\\n'
        return new_context, i, delta_c, delta_p, delta_s, bs_nl
    #
    # No match: stay in present state. All deltas are zero.
    new_context = context
    return new_context, i+1, 0, 0, 0, False
</t>
<t tx="ekr.20161128025508.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, pattern, data):
        key = pattern[0]
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind      pattern  ends?
            '\\':   [('len+1', '\\',    None),],
            '"':    [('len',   '"',     context == '"'),],
            "'":    [('len',   "'",     context == "'"),],
        }
        if block1 and block2:
            add_key(d, block2, ('len', block2, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment, ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1, ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161128054630.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key   kind    pattern ends?
            '\\':   [('len+1', '\\',None),],
            '"':[
                    ('len', '"""',  context == '"""'),
                    ('len', '"',    context == '"'),
                ],
            "'":[
                    ('len', "'''",  context == "'''"),
                    ('len', "'",    context == "'"),
                ],
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block1, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\': [('len+1','\\', context, None),],
            '#':  [('all', '#',   context, None),],
            '"':[
                    # order matters.
                    ('len', '"""',  '"""', None),
                    ('len', '"',    '"',   None),
                ],
            "'":[
                    # order matters.
                    ('len', "'''",  "'''", None),
                    ('len', "'",    "'",   None),
                ],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161205052712.1">def skip_block(self, i, index, lines, prev_state, stack):
    '''
    Find the end of a class/def starting at index
    on line i of lines.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    .'''
    index1 = index
    line = lines[i]
    kind = 'class' if line.strip().startswith('class') else 'def'
    i += 1
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        index += len(line)
        new_state = self.scan_line(line, prev_state)
        if self.ends_block(line, new_state, prev_state, stack):
            return kind, index1, index
        prev_state = new_state
        i += 1
        assert progress &lt; i
    return None, -1, -1
</t>
<t tx="ekr.20161220064822.1">def gen_ref(self, line, parent, target):
    '''
    Generate the at-others and a flag telling this method whether a previous
    @others
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if not target.at_others_flag:
        target.at_others_flag = True
        ref = '%s@others\n' % indent_ws
        self.add_line(parent,ref)
    return h
</t>
<t tx="ekr.20161220073836.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    if self.is_ws_line(line) or prev_state.in_context():
        return False
    # *Any* underindented non-blank line ends the class/def.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161220171728.1">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    return self.get_str_lws(lines[0]) if lines else ''
        # We must unindent the class/def line fully.
        # It would be wrong to examine the indentation of other lines.
</t>
<t tx="ekr.20161222112801.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.children(): # 2018/05/24.
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161222122914.1">def promote_last_lines(self, parent):
    '''A placeholder for python_i.promote_last_lines.'''
</t>
<t tx="ekr.20161222123105.1">def promote_last_lines(self, parent):
    '''python_i.promote_last_lines.'''
    last = parent.lastNode()
    if not last or last.h == 'Declarations':
        return
    if last.parent() != parent:
        return # The indentation would be wrong.
    lines = self.get_lines(last)
    prev_state = self.state_class()
    if_pattern = re.compile(r'^\s*if\b')
    # Scan for a top-level if statement.
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        m = if_pattern.match(line)
        if m and not prev_state.context and new_state.indent == 0:
            self.set_lines(last, lines[:i])
            self.extend_lines(parent, lines[i:])
            break
        else:
            prev_state = new_state
</t>
<t tx="ekr.20170123074946.1">def extractExecutableString(c, p, s):
    """
    Return all lines for the given @language directive.

    Ignore all lines under control of any other @language directive.
    """
    #
    # Rewritten to fix #1071.
    if g.unitTesting:
        return s  # Regretable, but necessary.
    #
    # Return s if no @language in effect. Should never happen.
    language = g.scanForAtLanguage(c, p)
    if not language:
        return s
    #
    # Return s if @language is unambiguous.
    pattern = r'^@language\s+(\w+)'
    matches = list(re.finditer(pattern, s, re.MULTILINE))
    if len(matches) &lt; 2:
        return s
    #
    # Scan the lines, extracting only the valid lines.
    extracting, result = False, []
    for i, line in enumerate(g.splitLines(s)):
        m = re.match(pattern, line)
        if m:
            # g.trace(language, m.group(1))
            extracting = m.group(1) == language
        elif extracting:
            result.append(line)
    return ''.join(result)
</t>
<t tx="ekr.20170126100139.1">def initBlock0(self):
    """
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    """
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20170126101049.1">def setInitialStateNumber(self):
    """
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    """
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None, state + ';blank')
    return n
</t>
<t tx="ekr.20170126103925.1">def languageTag(self, name):
    """
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    """
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    return 'no-language'
</t>
<t tx="ekr.20170216091704.1">def openUrlHelper(event, url=None):
    """Open the UNL or URL under the cursor.  Return it for unit testing."""
    c = getattr(event, 'c', None)
    if not c:
        return None
    w = getattr(event, 'w', c.frame.body.wrapper)
    if not g.app.gui.isTextWrapper(w):
        g.internalError('must be a text wrapper', w)
        return None
    setattr(event, 'widget', w)
    # Part 1: get the url.
    if url is None:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = w.getSelectionRange()
        if i != j:
            return None  # So find doesn't open the url.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # Find the url on the line.
        for match in g.url_regex.finditer(line):
            # Don't open if we click after the url.
            if match.start() &lt;= col &lt; match.end():
                url = match.group()
                if g.isValidUrl(url):
                    break
        else:
            # Look for the unl:
            for match in g.unl_regex.finditer(line):
                # Don't open if we click after the unl.
                if match.start() &lt;= col &lt; match.end():
                    unl = match.group()
                    g.handleUnl(unl, c)
                    return None
    elif not isinstance(url, str):
        url = url.toString()
        url = g.toUnicode(url)
            # Fix #571
    if url and g.isValidUrl(url):
        # Part 2: handle the url
        p = c.p
        if not g.doHook("@url1", c=c, p=p, url=url):
            g.handleUrl(url, c=c, p=p)
        g.doHook("@url2", c=c, p=p)
        return url
    # Part 3: call find-def.
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if word:
        c.findCommands.find_def_strict(event)
    return None
</t>
<t tx="ekr.20170220114553.1">def finalize(self, p):
    """Finalize p's path."""
    c = self.c
    aList = g.get_directives_dict_list(p)
    path = self.c.scanAtPathDirectives(aList)
    path = c.expand_path_expression(path)  # #1341.
    fn = p.anyAtFileNodeName()
    fn = c.expand_path_expression(fn)  # #1341.
    return g.os_path_finalize_join(path, fn)
</t>
<t tx="ekr.20170221063527.1">def handleUnl(unl, c):
    """Handle a Leo UNL. This must *never* open a browser."""
    if not unl:
        return None
    unll = unl.lower()
    if unll.startswith('unl:' + '//'):
        unl = unl[6:]
    elif unll.startswith('file://'):
        unl = unl[7:]
    unl = unl.strip()
    if not unl:
        return None
    unl = g.unquoteUrl(unl)
    # Compute path and unl.
    if unl.find('#') == -1 and unl.find('--&gt;') == -1:
        # The path is the entire unl.
        path, unl = unl, None
    elif unl.find('#') == -1:
        # The path is empty.
        # Move to the unl in *this* commander.
        g.recursiveUNLSearch(unl.split("--&gt;"), c, soft_idx=True)
        return c
    else:
        path, unl = unl.split('#', 1)
    if not path:
        # Move to the unl in *this* commander.
        g.recursiveUNLSearch(unl.split("--&gt;"), c, soft_idx=True)
        return c
    if c:
        base = g.os_path_dirname(c.fileName())
        c_path = g.os_path_finalize_join(base, path)
    else:
        c_path = None
    # Look for the file in various places.
    table = (
        c_path,
        g.os_path_finalize_join(g.app.loadDir, '..', path),
        g.os_path_finalize_join(g.app.loadDir, '..', '..', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'core', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'config', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'dist', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'doc', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'test', path),
        g.app.loadDir,
        g.app.homeDir,
    )
    for path2 in table:
        if path2 and path2.lower().endswith('.leo') and os.path.exists(path2):
            path = path2
            break
    else:
        g.es_print('path not found', repr(path))
        return None
    # End editing in *this* outline, so typing in the new outline works.
    c.endEditing()
    c.redraw()
    if g.unitTesting:
        g.app.unitTestDict['g.recursiveUNLSearch'] = path
    else:
        c2 = g.openWithFileName(path, old_c=c)
        if unl:
            g.recursiveUNLSearch(unl.split("--&gt;"), c2 or c, soft_idx=True)
        if c2:
            c2.bringToFront()
            return c2
    return None
</t>
<t tx="ekr.20170226054459.1">def handleUrlHelper(url, c, p):
    """Open a url.  Most browsers should handle:
        ftp://ftp.uu.net/public/whatever
        http://localhost/MySiteUnderDevelopment/index.html
        file:///home/me/todolist.html
    """
    tag = 'file://'
    original_url = url
    if url.startswith(tag) and not url.startswith(tag + '#'):
        # Finalize the path *before* parsing the url.
        url = g.computeFileUrl(url, c=c, p=p)
    parsed = urlparse.urlparse(url)
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    else:
        leo_path = parsed.path
    if leo_path.endswith('\\'): leo_path = leo_path[:-1]
    if leo_path.endswith('/'): leo_path = leo_path[:-1]
    if parsed.scheme == 'file' and leo_path.endswith('.leo'):
        g.handleUnl(original_url, c)
    elif parsed.scheme in ('', 'file'):
        unquote_path = g.unquoteUrl(leo_path)
        if g.unitTesting:
            g.app.unitTestDict['os_startfile'] = unquote_path
        elif g.os_path_exists(leo_path):
            g.os_startfile(unquote_path)
        else:
            g.es(f"File '{leo_path}' does not exist")
    else:
        if g.unitTesting:
            g.app.unitTestDict['browser'] = url
        else:
            # Mozilla throws a weird exception, then opens the file!
            try:
                webbrowser.open(url)
            except Exception:
                pass
</t>
<t tx="ekr.20170226060816.1">def traceUrl(c, path, parsed, url):

    print()
    g.trace('url          ', url)
    g.trace('c.frame.title', c.frame.title)
    g.trace('path         ', path)
    g.trace('parsed.fragment', parsed.fragment)
    g.trace('parsed.netloc', parsed.netloc)
    g.trace('parsed.path  ', parsed.path)
    g.trace('parsed.scheme', repr(parsed.scheme))
</t>
<t tx="ekr.20170226093349.1">def unquoteUrl(url):
    """Replace special characters (especially %20, by their equivalent)."""
    return urllib.parse.unquote(url)
</t>
<t tx="ekr.20170228082641.1">def composeScript(c, p, s, forcePythonSentinels=True, useSentinels=True):
    """Compose a script from p.b."""
    # This causes too many special cases.
        # if not g.unitTesting and forceEncoding:
            # aList = g.get_directives_dict_list(p)
            # encoding = scanAtEncodingDirectives(aList) or 'utf-8'
            # s = g.insertCodingLine(encoding,s)
    if not s.strip():
        return ''
    at = c.atFileCommands
    old_in_script = g.app.inScript
    try:
        # #1297: set inScript flags.
        g.app.inScript = g.inScript = True
        g.app.scriptDict["script1"] = s
        # Important: converts unicode to utf-8 encoded strings.
        script = at.stringToString(p.copy(), s,
            forcePythonSentinels=forcePythonSentinels,
            sentinels=useSentinels)
        script = script.replace("\r\n", "\n")  # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
        g.app.scriptDict["script2"] = script
    finally:
        g.app.inScript = g.inScript = old_in_script
    return script
</t>
<t tx="ekr.20170305105047.1">decorator_pattern = re.compile(r'^\s*@\s*(\w+)')

def starts_decorator(self, i, lines, prev_state):
    '''
    True if the line looks like a decorator outside any context.

    Puts the entire decorator into the self.decorator_lines list,
    and sets self.skip so that the next line to be handled is a class/def line.
    '''
    assert self.skip == 0
    if prev_state.context:
        # Only test for docstrings, not [{(.
        return False
    old_skip = self.skip
    old_decorator_lines = self.decorator_lines[:]
    line = lines[i]
    m = self.decorator_pattern.match(line)
    if m and m.group(1) not in g.globalDirectiveList:
        # Fix #360: allow multiline matches
        # Carefully skip all lines until a class/def.
        self.decorator_lines = [line]
        for i, line in enumerate(lines[i+1:]):
            new_state = self.scan_line(line, prev_state)
            m = self.starts_pattern.match(line)
            if m:
                # 2018/05/24: don't check in_context!
                # The class or def could start a context.
                return True
            self.decorator_lines.append(line)
            self.skip += 1
            prev_state = new_state
    # Recover froma a bare decorator, without a class or def.
    self.skip = old_skip
    self.decorator_lines = old_decorator_lines
    return False
</t>
<t tx="ekr.20170331141933.1">def writeAsisNode(self, p):
    '''Write the p's node to an @asis file.'''
    at = self

    def put(s):
        """Append s to self.output_list."""
        # #1480: Avoid calling at.os().
        s = g.toUnicode(s, at.encoding, reportErrors=True)
        at.outputList.append(s)

    # Write the headline only if it starts with '@@'.

    s = p.h
    if g.match(s, 0, "@@"):
        s = s[2:]
        if s:
            put('\n')  # Experimental.
            put(s)
            put('\n')
    # Write the body.
    s = p.b
    if s:
        put(s)
</t>
<t tx="ekr.20170404035138.1">def context_lines(self, aList, i, n=2):
    '''Return a list containing the n lines of surrounding context of aList[i].'''
    result = []
    aList1 = aList[max(0, i-n):i]
    aList2 = aList[i+1:i+n+1]
    result.extend(['  %4s %r\n' % (i + 1 - len(aList1) + j, g.truncate(s,60))
        for j, s in enumerate(aList1)])
    result.append('* %4s %r\n' % (i + 1, g.truncate(aList[i], 60)))
    result.extend(['  %4s %r\n' % (i + 2 + j, g.truncate(s, 60))
        for j, s in enumerate(aList2)])
    return result
</t>
<t tx="ekr.20170405191106.1">def import_binary_file(self, fileName, parent):

    # Fix bug 1185409 importing binary files puts binary content in body editor.
    # Create an @url node.
    c = self.c
    if parent:
        p = parent.insertAsLastChild()
    else:
        p = c.lastTopLevel().insertAfter()
    p.h = f"@url file://{fileName}"
    return p
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">"""Recursively import all python files in a directory and clean the result."""
g.cls()
if 0:
    import importlib
    import leo.core.leoImport as leoImport
    importlib.reload(leoImport)
# dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\black.py'
dir_ = g.os_path_finalize_join(g.app.loadDir, '..', 'modes')
assert g.os_path_exists(dir_), repr(dir_)
c.recursiveImport(
    add_context = False,
    dir_ = dir_,
    kind = '@edit', # '@clean', '@edit', '@nosent','@auto','@file',
    recursive = False,
    safe_at_file = False,
    theTypes = ['.py',]
)
</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170510100003.1">def h_return (self, ch):
    '''
    Handle the return key in the minibuffer.
    Send the contents to k.masterKeyHandler.
    '''
    c = self.leo_c
    k = c.k
    val = self.value.strip()
    self.value = ''
    self.update()
    # g.trace('===== inState: %r val: %r' % (k.inState(), val))
    commandName = val
    c.frame.tree.set_status_line(c.p)
        # This may be changed by the command.
    if k.inState():
        # Handle the key.
        k.w = self.leo_wrapper
        k.arg = val
        g.app.gui.curses_gui_arg = val
        k.masterKeyHandler(
            event=KeyEvent(c, char='\n', event='', shortcut='\n', w=None))
        g.app.gui.curses_gui_arg = None
        k.clearState()
    elif commandName == 'repeat-complex-command':
        g.app.gui.repeatComplexCommand(c)
    else:
        # All other alt-x command
        event=KeyEvent(c,char='',event='',shortcut='',w=None)
        c.doCommandByName(commandName, event)
        # Support repeat-complex-command.
        c.setComplexCommand(commandName=commandName)
        c.redraw()
    # Do a full redraw, with c.p as the first visible node.
    # g.trace('----- after command')
    g.app.gui.redraw_in_context(c)
</t>
<t tx="ekr.20170522015906.1">@frame_cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    c = self.c
    w = event and event.widget
    if not isinstance(w, leoFrame.StringTextWrapper):
        g.trace('not a StringTextWrapper', repr(w))
        return
    wname = c.widget_name(w)
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    s = g.app.gui.getTextFromClipboard()
    s = g.toUnicode(s)
    if trace: g.trace('wname', wname, 'len(s)', len(s))
    single_line = any(wname.startswith(z) for z in ('head', 'minibuffer'))
    if single_line:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[: -1]
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    if wname.startswith('body'):
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif wname.startswith('head'):
        c.frame.tree.onHeadChanged(c.p, s=w.getAllText(), undoType='Paste')
            # New for Curses gui.

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20170617125213.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Important: i.gen_ref does not know p when it calls
        # self.clean_headline.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
</t>
<t tx="ekr.20170806094321.7">def make_at_file_outline(self, fn, s, rev):
    """Create a hidden temp outline from lines."""
    # A specialized version of atFileCommands.read.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    at.initReadIvars(root, fn, importFileName=None, atShadow=None)
    if at.errors &gt; 0:
        g.trace('***** errors')
        return None
    at.fast_read_into_root(
        c=hidden_c,
        contents=s,
        gnx2vnode={},
        path=fn,
        root=root,
    )
    return hidden_c
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20170820084258.1">def make_at_clean_outline(self, fn, root, s, rev):
    """
    Create a hidden temp outline from lines without sentinels.
    root is the @&lt;file&gt; node for fn.
    s is the contents of the (public) file, without sentinels.
    """
    # A specialized version of at.readOneAtCleanNode.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    x = hidden_c.shadowController
    hidden_c.frame.createFirstTreeNode()
    hidden_root = hidden_c.rootPosition()
    # copy root to hidden root, including gnxs.
    root.copyTreeFromSelfTo(hidden_root, copyGnxs=True)
    hidden_root.h = fn + ':' + rev if rev else fn
    # Set at.encoding first.
    at.initReadIvars(hidden_root, fn)
        # Must be called before at.scanAllDirectives.
    at.scanAllDirectives(hidden_root)
        # Sets at.startSentinelComment/endSentinelComment.
    new_public_lines = g.splitLines(s)
    old_private_lines = at.write_at_clean_sentinels(hidden_root)
    marker = x.markerFromFileLines(old_private_lines, fn)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    if old_public_lines:
        # Fix #1136: The old lines might not exist.
        new_private_lines = x.propagate_changed_lines(
            new_public_lines, old_private_lines, marker, p=hidden_root)
        at.fast_read_into_root(
            c=hidden_c,
            contents=''.join(new_private_lines),
            gnx2vnode={},
            path=fn,
            root=hidden_root,
        )
    return hidden_c
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171113164709.1">def reload_settings(self):
    """LeoFind.reload_settings."""
    c = self.c
    self.minibuffer_mode = c.config.getBool('minibuffer-find-mode', default=False)
</t>
<t tx="ekr.20171123135625.38">@g.commander_command('insert-body-time')
def insertBodyTime(self, event=None):
    """Insert a time/date stamp at the cursor."""
    c = self; undoType = 'Insert Body Time'
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20171123135625.4">@cmd('execute-script')
def executeScript(self, event=None,
    args=None, p=None, script=None, useSelectedText=True,
    define_g=True, define_name='__main__',
    silent=False, namespace=None, raiseFlag=False,
    runPyflakes=True,
):
    """
    Execute a *Leo* script.
    Keyword args:
    args=None               Not None: set script_args in the execution environment.
    p=None                  Get the script from p.b, unless script is given.
    script=None             None: use script in p.b or c.p.b
    useSelectedText=True    False: use all the text in p.b or c.p.b.
    define_g=True           True: define g for the script.
    define_name='__main__'  Not None: define the name symbol.
    silent=False            No longer used.
    namespace=None          Not None: execute the script in this namespace.
    raiseFlag=False         True: reraise any exceptions.
    runPyflakes=True        True: run pyflakes if allowed by setting.
    """
    c, script1 = self, script
    if runPyflakes:
        run_pyflakes = c.config.getBool('run-pyflakes-on-write', default=False)
    else:
        run_pyflakes = False
    if not script:
        if c.forceExecuteEntireBody:
            useSelectedText = False
        script = g.getScript(c, p or c.p, useSelectedText=useSelectedText)
    script_p = p or c.p
        # Only for error reporting below.
    # #532: check all scripts with pyflakes.
    if run_pyflakes and not g.unitTesting:
        from leo.commands import checkerCommands as cc
        # at = c.atFileCommands
        prefix = ('c,g,p,script_gnx=None,None,None,None;'
                  'assert c and g and p and script_gnx;\n')
        cc.PyflakesCommand(c).check_script(script_p, prefix + script)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0, '.')  # New in Leo 5.0
            sys.path.insert(0, c.frame.openDirectory)  # per SegundoBob
            script += '\n'  # Make sure we end the script properly.
            try:
                if not namespace or namespace.get('script_gnx') is None:
                    namespace = namespace or {}
                    namespace.update(script_gnx=script_p.gnx)
                # We *always* execute the script with p = c.p.
                c.executeScriptHelper(args, define_g, define_name, namespace, script)
            except KeyboardInterrupt:
                g.es('interrupted')
            except Exception:
                if raiseFlag:
                    raise
                g.handleScriptException(c, script_p, script, script1)
            finally:
                del sys.path[0]
                del sys.path[0]
        else:
            tabName = log and hasattr(log, 'tabName') and log.tabName or 'Log'
            g.warning("no script selected", tabName=tabName)
    finally:
        g.app.log = oldLog
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20171123135625.5">def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
</t>
<t tx="ekr.20171123135625.50">def unreformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """unformat the body and update the selection."""
    body, w = c.frame.body, c.frame.body.wrapper
    s = head + result + tail
    ins = max(len(head), len(head) + len(result) - 1)
    w.setAllText(s)  # Destroys coloring.
    changed = original != s
    if changed:
        body.onBodyChanged(undoType, oldSel=oldSel)
    # Advance to the next paragraph.
    ins += 1  # Move past the selection.
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    c.recolor()  # Required.
    w.setSelectionRange(ins, ins, insert=ins)
    # More useful than for reformat-paragraph.
    w.see(ins)
    # Make sure we never scroll horizontally.
    w.setXScrollPosition(0)
</t>
<t tx="ekr.20171123135625.6">def redirectScriptOutput(self):
    c = self
    if c.config.redirect_execute_script_output_to_log_pane:
        g.redirectStdout()  # Redirect stdout
        g.redirectStderr()  # Redirect stderr
</t>
<t tx="ekr.20171123135625.7">def setCurrentDirectoryFromContext(self, p):
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    curDir = g.os_path_abspath(os.getcwd())
    if path and path != curDir:
        try:
            os.chdir(path)
        except Exception:
            pass
</t>
<t tx="ekr.20171123135625.8">def unredirectScriptOutput(self):
    c = self
    if c.exists and c.config.redirect_execute_script_output_to_log_pane:
        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20171123201514.1"></t>
<t tx="ekr.20171124043747.1">def registerCommandShortcut(self, commandName, func, pane, shortcut):
    """
    Register a shortcut for the a command.
    
    **Important**: Bindings created here from plugins can not be overridden.
    This includes @command and @button bindings created by mod_scripting.py.
    """
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    assert not g.isStroke(shortcut)
    if shortcut:
        stroke = g.KeyStroke(binding=shortcut) if shortcut else None
    elif commandName.lower() == 'shortcut':  # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for bi in aList:
            if bi.stroke and not bi.pane.endswith('-mode'):
                stroke = bi.stroke
                pane = bi.pane  # 2015/05/11.
                break
    if stroke:
        k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke)  # Must be a stroke.
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20171129205648.1">def compute_find_options(self):  # pragma: no cover (cmd)
    """Return the status line as two strings."""
    z = []
    # Set the scope field.
    head = self.search_headline
    body = self.search_body
    if self.suboutline_only:
        scope = 'tree'
    elif self.node_only:
        scope = 'node'
    else:
        scope = 'all'
    # scope = self.getOption('radio-search-scope')
    # d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    # scope = d.get(scope) or ''
    head = 'head' if head else ''
    body = 'body' if body else ''
    sep = '+' if head and body else ''
    part1 = f"{head}{sep}{body} {scope}  "
    # Set the type field.
    regex = self.pattern_match
    if regex: z.append('regex')
    table = (
        ('reverse', 'reverse'),
        ('ignore_case', 'noCase'),
        ('whole_word', 'word'),
        # ('wrap', 'wrap'),
        ('mark_changes', 'markChg'),
        ('mark_finds', 'markFnd'),
    )
    for ivar, s in table:
        val = getattr(self, ivar)
        if val: z.append(s)
    part2 = ' '.join(z)
    return part1, part2
</t>
<t tx="ekr.20171129211238.1">def compute_find_options_in_status_area(self):
    c = self.c
    ftm = c.findCommands.ftm
    table = (
        ('Word', ftm.check_box_whole_word),
        ('Ig-case', ftm.check_box_ignore_case),
        ('regeXp', ftm.check_box_regexp),
        ('Body', ftm.check_box_search_body),
        ('Head', ftm.check_box_search_headline),
        # ('wrap-Around', ftm.check_box_wrap_around),
        ('mark-Changes', ftm.check_box_mark_changes),
        ('mark-Finds', ftm.check_box_mark_finds),
    )
    result = [option for option, ivar in table if ivar.checkState()]
    table2 = (
        ('Suboutline', ftm.radio_button_suboutline_only),
        ('Node', ftm.radio_button_node_only),
    )
    for option, ivar in table2:
        if ivar.isChecked():
            result.append(f"[{option}]")
            break
    return f"Find: {' '.join(result)}"
</t>
<t tx="ekr.20171226140643.1">@cmd('find-all-unique-regex')
def interactive_find_all_unique_regex(
    self, event=None):  # pragma: no cover (interactive)
    """
    Create a summary node containing all unique matches of the regex search
    string. This command shows only the matched string itself.
    """
    self.ftm.clear_focus()
    self.match_obj = None
    self.changeAllFlag = False
    self.findAllUniqueFlag = True
    self.ftm.set_entry_focus()
    self.start_state_machine(event,
        prefix='Search Unique Regex: ',
        handler=self.interactive_find_all_unique_regex1,
        escape_handler=self.interactive_change_all_unique_regex1,
    )

def interactive_find_all_unique_regex1(
    self, event=None):  # pragma: no cover (interactive)
    k = self.k
    # Settings...
    find_pattern = k.arg
    self.update_find_list(find_pattern)
    self.ftm.set_find_text(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    return self.do_find_all(settings)

def interactive_change_all_unique_regex1(
    self, event):  # pragma: no cover (interactive)
    k = self.k
    find_pattern = self._sString = k.arg
    self.update_find_list(k.arg)
    s = f"'Replace All Unique Regex': {find_pattern} With: "
    k.setLabelBlue(s)
    self.add_change_string_to_label()
    k.getNextArg(self.interactive_change_all_unique_regex2)

def interactive_change_all_unique_regex2(
    self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    find_pattern = self._sString
    change_pattern = k.arg
    self.update_change_list(change_pattern)
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_change_all(settings)
</t>
<t tx="ekr.20171226143621.1">def _create_find_unique_node(self):
    """Create a "Found Unique" node as the last node of the outline."""
    c = self.c
    found = c.lastTopLevel().insertAfter()
    assert found
    found.h = f"Found Unique Regex:{self.find_text}"
    result = sorted(self.unique_matches)
    found.b = '\n'.join(result)
    return found
</t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180410074238.1">def insert_toc(c, kind):
    """Insert a table of contents at the cursor."""
    undoType = f"Insert {kind.capitalize()} TOC"
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = make_toc(c, kind=kind, root=c.p)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20180418023827.1">def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
</t>
<t tx="ekr.20180418024449.1">def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
</t>
<t tx="ekr.20180418025241.1">def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c = self.c
    if c.vim_mode and c.vimCommands:
        # The "acceptance methods" in leoVim.py return True
        # if vim node has completely handled the key.
        # Otherwise, processing in k.masterKeyHandler continues.
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('do_key returns', ok, repr(event and event.stroke))
        return ok
    return False
</t>
<t tx="ekr.20180418031118.1">def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) &gt; 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
</t>
<t tx="ekr.20180418031417.1">def traceVars(self, event):

    trace = False and not g.unitTesting
    if not trace:
        return
    k = self
    char = event.char
    state = k.state.kind
    stroke = event.stroke
    g.trace(
        f"stroke: {stroke!r}, "
        f"char: {char!r}, "
        f"state: {state}, "
        f"state2: {k.unboundKeyAction}")
</t>
<t tx="ekr.20180418033838.1">def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    trace = 'keys' in g.app.debug
    c, k = self.c, self
    #
    # Experimental special case:
    # Inserting a '.' always invokes the auto-completer.
    # The auto-completer just inserts a '.' if it isn't enabled.
    stroke = event.stroke
    if (
        stroke.s == '.'
        and k.isPlainKey(stroke)
        and self.unboundKeyAction in ('insert', 'overwrite')
    ):
        c.doCommandByName('auto-complete', event)
        return True
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event)
    #
    # #327: Ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        # A superb trace. !s gives shorter trace.
        if trace: g.trace(f"{event.stroke!s} {bi.commandName}")
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20180418034305.1">def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
</t>
<t tx="ekr.20180418040158.1">def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
</t>
<t tx="ekr.20180418105228.1">def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    # trace = 'keys' in g.app.debug and 'verbose' in g.app.debug
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
</t>
<t tx="ekr.20180418114300.1">def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180511045458.1">def _switch_style(self, word):
    """
    Switch between camelCase and underscore_style function defintiions.
    Return None if there would be no change.
    """
    s = word
    if not s:
        return None
    if s[0].isupper():
        return None  # Don't convert class names.
    if s.find('_') &gt; -1:
        # Convert to CamelCase
        s = s.lower()
        while s:
            i = s.find('_')
            if i == -1:
                break
            s = s[:i] + s[i + 1 :].capitalize()
        return s
    # Convert to underscore_style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    s = ''.join(result)
    return None if s == word else s
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    if row &gt;= len(lines):  # 2020/11/27
        return []
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        if 0:  # This *can* happen.
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            # https://jedi.readthedocs.io/en/latest/docs/api.html#script
            script = jedi.Script(source, path=g.shortFileName(fileName))
            completions = script.complete(
                line=1 + n0 + jedi_line,
                column=column,
            )
            t3 = time.process_time()
        except Exception:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180524130023.1">file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    # Note: this method is never called for @clean trees.

def add_class_names(self, p):
    '''
    Add class names to headlines for all descendant nodes.

    Called only when @bool add-context-to-headlines is True.
    '''
    if g.app.unitTesting:
        return # Don't changes the expected headlines.
    after, fn, class_name = None, None, None
    for p in p.self_and_subtree():
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            prefix = m.group(1)
            fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        if p.h.startswith('@path '):
            after, fn, class_name = None, None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if not p.h.startswith(class_name):
                p.h = '%s.%s' % (class_name, p.h)
        elif fn and self.add_file_context:
            tag = ' (%s)' % fn
            if not p.h.endswith(tag):
                p.h += tag
</t>
<t tx="ekr.20180524173510.1"></t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180602103135.10">if verbatim:
    # We are in raw mode, or other special situation.
    # Previous line was verbatim sentinel. Append this line as it is.
    if afterref:
        afterref = False
        if body:  # a List of lines.
            body[-1] = body[-1].rstrip() + line
        else:
            body = [line]
        verbatim = False
    elif in_raw:
        m = end_raw_pat.match(line)
        if m:
            in_raw = False
            verbatim = False
        else:
             body.append(line)
             # Continue verbatim/raw mode.
    else:
        body.append(line)
        verbatim = False
    continue
if line == verbline:  # &lt;delim&gt;@verbatim.
    verbatim = True
    continue
#
# Strip the line only once.
strip_line = line.strip()
#
# Undo the cweb hack.
if is_cweb and line.startswith(sentinel):
    line = line[: len(sentinel)] + line[len(sentinel) :].replace('@@', '@')
# Adjust indentation.
if indent and line[:indent].isspace() and len(line) &gt; indent:
    line = line[indent:]
</t>
<t tx="ekr.20180602103135.12"># This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches the start of the sentinel.
#
if not in_doc and not strip_line.startswith(sentinel):
    # lstrip() is faster than using a regex!
    body.append(line)
    continue
</t>
<t tx="ekr.20180602103135.13">m = all_pat.match(line)
if m:
    # @all tells Leo's *write* code not to check for undefined sections.
    # Here, in the read code, we merely need to add it to the body.
    # Pushing and popping the stack may not be necessary, but it can't hurt.
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@all{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        gnx2body[gnx] = body
    continue
</t>
<t tx="ekr.20180602103135.14">m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@others{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
        indent += m.end(1)  # adjust current identation
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
</t>
<t tx="ekr.20180602103135.16">if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    #
    # #1496: Retire the @doc convention.
    #        An empty line is no longer a sentinel.
    if delim_end and line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or ''  # Trailing text.
        if doc2:
            body.append(f"{doc}{doc2}\n")
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
</t>
<t tx="ekr.20180602103135.17"># Handle an apparent sentinel line.
# This *can* happen, as the result of the git-diff command.
#
# This assert verifies the short-circuit test.
assert strip_line.startswith(sentinel), (repr(sentinel), repr(line))
#
# This trace is less important, but interesting.
g.trace(
    f"{g.shortFileName(self.path)}: ignoring unexpected line: {line.strip()!r}")
# body.append(line)
</t>
<t tx="ekr.20180602103135.18">m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
        continue
    if stack:
        # #1232: Only if the stack exists.
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        continue
</t>
<t tx="ekr.20180602103135.19">m = node_start_pat.match(line)
if m:
    in_doc, in_raw = False, False
    gnx, head = m.group(2), m.group(5)
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
        # m.group(3) is the level number, m.group(4) is the number of stars.
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        if not v:
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode[gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level - 2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[: level - 1]
        level_stack.append((v, clone_v),)
        # Always clear the children!
        v.children = []
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = self.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[: level - 1]
    level_stack.append((v, clone_v),)
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    # dump_v()
    continue
</t>
<t tx="ekr.20180602103135.20">if line.startswith(delim_start + '@-leo'):
    i += 1
    break
</t>
<t tx="ekr.20180602103135.8">def scan_lines(self, delims, first_lines, lines, path, start, test=False):
    '''Scan all lines of the file, creating vnodes.'''
    &lt;&lt; init scan_lines &gt;&gt;
    &lt;&lt; define dump_v &gt;&gt;

    i = 0  # To keep pylint happy.
    for i, line in enumerate(lines[start:]):
        # Order matters.
        &lt;&lt; 1. common code for all lines &gt;&gt;
        &lt;&lt; 2. short-circuit later tests &gt;&gt;
        &lt;&lt; 3. handle @others &gt;&gt; # clears in_doc
        &lt;&lt; 4. handle section refs &gt;&gt; # clears in_doc.
        # Order doesn't matter, but match more common sentinels first.
        &lt;&lt; handle node_start &gt;&gt;
        &lt;&lt; handle end of @doc &amp; @code parts &gt;&gt;
        &lt;&lt; handle @all &gt;&gt;
        &lt;&lt; handle afterref &gt;&gt;
        &lt;&lt; handle @first and @last &gt;&gt;
        &lt;&lt; handle @comment &gt;&gt;
        &lt;&lt; handle @delims &gt;&gt;
        &lt;&lt; handle @raw &gt;&gt;
        &lt;&lt; handle @-leo &gt;&gt;
        # These must be last, in this order.
        &lt;&lt; Last 1. handle remaining @@ lines &gt;&gt;
        &lt;&lt; Last 2. handle remaining @doc lines &gt;&gt;
        &lt;&lt; Last 3. handle remaining @ lines &gt;&gt;
    else:
        # No @-leo sentinel
        return None, []
    # Handle @last lines.
    last_lines = lines[start + i :]
    if last_lines:
        last_lines = ['@last ' + z for z in last_lines]
        gnx2body[root_gnx] = gnx2body[root_gnx] + last_lines
    self.post_pass(gnx2body, gnx2vnode, root_v)
    return root_v, last_lines
</t>
<t tx="ekr.20180602103135.9">#
# Simple vars...
afterref = False
    # A special verbatim line follows @afterref.
clone_v = None
    # The root of the clone tree.
    # When not None, we are scanning a clone and all it's descendants.
delim_start, delim_end = delims
    # The start/end delims.
doc_skip = (delim_start + '\n', delim_end + '\n')
    # To handle doc parts.
first_i = 0
    # Index into first array.
in_doc = False
    # True: in @doc parts.
in_raw = False
    # True: @raw seen.
is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    # True: cweb hack in effect.
indent = 0
    # The current indentation.
level_stack = []
    # Entries are (vnode, in_clone_tree)
n_last_lines = 0
    # The number of @@last directives seen.
root_seen = False
    # False: The next +@node sentinel denotes the root, regardless of gnx.
    # Needed to handle #1065 so reads will not create spurious child nodes.
sentinel = delim_start + '@'
    # Faster than a regex!
stack = []
    # Entries are (gnx, indent, body)
    # Updated when at+others, at+&lt;section&gt;, or at+all is seen.
verbline = delim_start + '@verbatim' + delim_end + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
#
# Init the data for the root node.
#

#
# Init the parent vnode for testing.
#
if self.test:
    root_gnx = gnx = 'root-gnx'
        # The node that we are reading.
        # start with the gnx for the @file node.
    gnx_head = '&lt;hidden top vnode&gt;'
        # The headline of the root node.
    context = None
    parent_v = self.VNode(context=context, gnx=gnx)
    parent_v._headString = gnx_head
        # Corresponds to the @files node itself.
else:
    # Production.
    root_gnx = gnx = self.root.gnx
    context = self.c
    parent_v = self.root.v
root_v = parent_v
    # Does not change.
level_stack.append((root_v, False),)
#
# Init the gnx dict last.
#
gnx2vnode = self.gnx2vnode
    # Keys are gnx's, values are vnodes.
gnx2body = {}
    # Keys are gnxs, values are list of body lines.
gnx2vnode[gnx] = parent_v
    # Add gnx to the keys
gnx2body[gnx] = body = first_lines
    # Add gnx to the keys.
    # Body is the list of lines presently being accumulated.
#
# get the patterns.
data = self.get_patterns(delims)
after_pat, all_pat, code_pat, comment_pat, delims_pat, doc_pat, end_raw_pat, first_pat, last_pat, node_start_pat, others_pat, raw_pat, ref_pat = data

</t>
<t tx="ekr.20180603063102.1">m = after_pat.match(line)
if m:
    afterref = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
</t>
<t tx="ekr.20180603135602.1"># @first, @last, @delims and @comment generate @@ sentinels,
# So this must follow all of those.
if line.startswith(delim_start + '@@'):
    ii = len(delim_start) + 1  # on second '@'
    jj = line.rfind(delim_end) if delim_end else -1
    body.append(line[ii:jj] + '\n')
    continue
</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606053919.1">m = first_pat.match(line)
if m:
    if 0 &lt;= first_i &lt; len(first_lines):
        body.append('@first ' + first_lines[first_i])
        first_i += 1
    else:
        g.trace(f"\ntoo many @first lines: {path}")
        print('@first is valid only at the start of @&lt;file&gt; nodes\n')
        g.printObj(first_lines, tag='first_lines')
        g.printObj(lines[start : i + 2], tag='lines[start:i+2]')
    continue
m = last_pat.match(line)
if m:
    n_last_lines += 1
    continue
</t>
<t tx="ekr.20180606054325.1">if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
        continue
    # Doc lines start with start_delim + one blank.
    # #1496: Retire the @doc convention:
    tail = line[len(delim_start) + 1 :]
    if tail.strip():
        body.append(tail)
    else:
        body.append('\n')
    continue
</t>
<t tx="ekr.20180606080200.1"># http://leoeditor.com/directives.html#part-4-dangerous-directives
m = raw_pat.match(line)
if m:
    in_raw = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
</t>
<t tx="ekr.20180608104836.1">m = delims_pat.match(line)
if m:
    # Get 1 or 2 comment delims
    # Whatever happens, retain the original @delims line.
    delims = m.group(1).strip()
    body.append(f"@delims {delims}\n")
    #
    # Parse the delims.
    delims_pat = re.compile(r'^([^ ]+)\s*([^ ]+)?')
    m2 = delims_pat.match(delims)
    if not m2:
        g.trace(f"Ignoring invalid @comment: {line!r}")
        continue
    delim_start = m2.group(1)
    delim_end = m2.group(2) or ''
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
</t>
<t tx="ekr.20180613061743.1">def dump_v():
    """Dump the level stack and v."""
    print('----- LEVEL', level, v.h)
    print('       PARENT', parent_v.h)
    print('[')
    for i, data in enumerate(level_stack):
        v2, in_tree = data
        print(f"{i+1:2} {in_tree:5} {v2.h}")
    print(']')
    print('PARENT.CHILDREN...')
    g.printObj([v3.h for v3 in parent_v.children])
    print('PARENTS...')
    g.printObj([v4.h for v4 in v.parents])

</t>
<t tx="ekr.20180621050901.1"># http://leoeditor.com/directives.html#part-4-dangerous-directives
m = comment_pat.match(line)
if m:
    # &lt;1, 2 or 3 comment delims&gt;
    delims = m.group(1).strip()
    # Whatever happens, retain the @delims line.
    body.append(f"@comment {delims}\n")
    delim1, delim2, delim3 = g.set_delims_from_string(delims)
        # delim1 is always the single-line delimiter.
    if delim1:
        delim_start, delim_end = delim1, ''
    else:
        delim_start, delim_end = delim2, delim3
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns.
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
</t>
<t tx="ekr.20180622110112.1">def fast_read_into_root(self, c, contents, gnx2vnode, path, root):
    """A convenience wrapper for FastAtReAD.read_into_root()"""
    return FastAtRead(c, gnx2vnode).read_into_root(contents, path, root)
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1 and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import os
import leo.commands.editFileCommands as efc

path = os.path.join(g.app.loadDir, '..', '..')
os.chdir(path)

efc.GitDiffController(c).diff_two_branches(
    branch1='master', # '6bd282f', # 'bc24e607a5', # old branch/rev
    branch2='devel', # new branch/rev
    fn='leo/core/leoTangle.py',
    directory=None,
)
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181009072707.1"># -*- coding: utf-8 -*-
import os
import sys
import unittest
from leo.core import leoBridge

load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    tm = c.testManager
    g.unitTesting = g.app.unitTesting = True
    suite = unittest.makeSuite(unittest.TestCase)
    aList = tm.findAllUnitTestNodes(all=False, marked=False)
    setup_script = None
    found = False
    for p in aList:
        if tm.isTestSetupNode(p):
            setup_script = p.b
            test = None
        elif tm.isTestNode(p):
            test = tm.makeTestCase(p, setup_script)
        elif tm.isSuiteNode(p):
            test = tm.makeTestSuite(p, setup_script)
        elif tm.isTestClassNode(p):
            test = tm.makeTestClass(p)
        else:
            test = None
        if test:
            suite.addTest(test)
            found = True
    if not found:
        print('No unit tests')
        sys.exit(1)
    runner = unittest.TextTestRunner(failfast=True, verbosity=1)
    try:
        result = runner.run(suite)
        if result.errors or result.failures:
            print(f"errors: {len(result.errors)}, failures: {len(result.failures)}")
            sys.exit(1)
        else:
            print('Travis unit tests all passed.')
            sys.exit(0)
    except Exception:
        print('Unexpected exception')
        g.es_exception()
        sys.exit(1)
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20190108052043.1">def findFilesToWrite(self, force):
    """
    Return a list of files to write.
    We must do this in a prepass, so as to avoid errors later.
    """
    trace = 'save' in g.app.debug and not g.unitTesting
    if trace:
        g.trace(f"writing *{'selected' if force else 'all'}* files")
    c = self.c
    if force:
        # The Write @&lt;file&gt; Nodes command.
        # Write all nodes in the selected tree.
        root = c.p
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        root = c.rootPosition()
        p = c.rootPosition()
        after = None
    seen = set()
    files = []
    while p and p != after:
        if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
            # Honor @ignore in *body* text, but *not* in @asis nodes.
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif p.isAnyAtFileNode():
            data = p.v, g.fullPath(c, p)
            if data in seen:
                if trace and force:
                    g.trace('Already seen', p.h)
            else:
                seen.add(data)
                files.append(p.copy())
            # Don't scan nested trees???
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    # When scanning *all* nodes, we only actually write dirty nodes.
    if not force:
        files = [z for z in files if z.isDirty()]
    if trace:
        g.printObj([z.h for z in files], tag='Files to be saved')
    return files, root
</t>
<t tx="ekr.20190108053115.1">def internalWriteError(self, p):
    """
    Fix bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
    Give a more urgent, more specific, more helpful message.
    """
    g.es_exception()
    g.es(f"Internal error writing: {p.h}", color='red')
    g.es('Please report this error to:', color='blue')
    g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
    g.es('Warning: changes to this file will be lost', color='red')
    g.es('unless you can save the file successfully.', color='red')
</t>
<t tx="ekr.20190108054317.1">def findFilesToRead(self, force, root):

    c = self.c
    p = root.copy()
    scanned_tnodes = set()
    files = []
    after = p.nodeAfterTree() if force else None
    while p and p != after:
        data = (p.gnx, g.fullPath(c, p))
        # skip clones referring to exactly the same paths.
        if data in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(data)
        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif (
            p.isAtThinFileNode() or
            p.isAtAutoNode() or
            p.isAtEditNode() or
            p.isAtShadowFileNode() or
            p.isAtFileNode() or
            p.isAtCleanNode()  # 1134.
        ):
            files.append(p.copy())
            p.moveToNodeAfterTree()
        elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Note (see #1081): @asis and @nosent can *not* be updated automatically.
            # Doing so using refresh-from-disk will delete all child nodes.
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    return files
</t>
<t tx="ekr.20190108054803.1">def readFileAtPosition(self, force, p):
    '''Read the @&lt;file&gt; node at p.'''
    at, c, fileName = self, self.c, p.anyAtFileNodeName()
    if p.isAtThinFileNode() or p.isAtFileNode():
        at.read(p, force=force)
    elif p.isAtAutoNode():
        at.readOneAtAutoNode(fileName, p)
    elif p.isAtEditNode():
        at.readOneAtEditNode(fileName, p)
    elif p.isAtShadowFileNode():
        at.readOneAtShadowNode(fileName, p)
    elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        at.rememberReadPath(g.fullPath(c, p), p)
    elif p.isAtCleanNode():
        at.readOneAtCleanNode(p)
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.outputList = []
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        contents = '' if at.errors else ''.join(at.outputList)
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return contents
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190109153627.13">def writeAtShadowNodesHelper(self, writeDirtyOnly=True):
    """Write @shadow nodes in the selected outline"""
    at = self; c = at.c
    p = c.p; after = p.nodeAfterTree()
    found = False
    while p and p != after:
        if (
            p.atShadowFileNodeName() and not p.isAtIgnoreNode()
            and (p.isDirty() or not writeDirtyOnly)
        ):
            ok = at.writeOneAtShadowNode(p)
            if ok:
                found = True
                g.blue(f"wrote {p.atShadowFileNodeName()}")
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @shadow nodes in the selected tree")
        else:
            g.es("no @shadow nodes in the selected tree")
    return found
</t>
<t tx="ekr.20190109160056.1">def atAsisToString(self, root):
    """Write the @asis node to a string."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        at.outputList = []
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        return '' if at.errors else ''.join(at.outputList)
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20190109160056.2">def atAutoToString(self, root):
    """Write the root @auto node to a string, and return it."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        return at.writeAtAutoContents(fileName, root) or ''
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20190109160056.3">def atEditToString(self, root):
    """Write one @edit node."""
    at, c = self, self.c
    try:
        c.endEditing()
        if root.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(
            root, root.atEditNodeName(), atEdit=True, sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        contents = ''.join([
            s for s in g.splitLines(root.b)
                if at.directiveKind4(s, 0) == at.noDirective])
        return contents
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20190109163934.24">def writeAtAutoNodesHelper(self, writeDirtyOnly=True):
    """Write @auto nodes in the selected outline"""
    at = self; c = at.c
    p = c.p; after = p.nodeAfterTree()
    found = False
    while p and p != after:
        if (
            p.isAtAutoNode() and not p.isAtIgnoreNode() and
            (p.isDirty() or not writeDirtyOnly)
        ):
            ok = at.writeOneAtAutoNode(p)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @auto nodes in the selected tree")
        else:
            g.es("no @auto nodes in the selected tree")
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190111153522.1"></t>
<t tx="ekr.20190111172114.1">def replaceFile(self, contents, encoding, fileName, root, ignoreBlankLines=False):
    '''
    Write or create the given file from the contents.
    Return True if the original file was changed.
    '''
    at, c = self, self.c
    if root:
        root.clearDirty()
    #
    # Create the timestamp (only for messages).
    if c.config.getBool('log-show-save-time', default=False):
        format = c.config.getString('log-timestamp-format') or "%H:%M:%S"
        timestamp = time.strftime(format) + ' '
    else:
        timestamp = ''
    #
    # Adjust the contents.
    assert g.isUnicode(contents), g.callers()
    if at.output_newline != '\n':
        contents = contents.replace('\r', '').replace('\n', at.output_newline)
    #
    # If file does not exist, create it from the contents.
    fileName = g.os_path_realpath(fileName)
    sfn = g.shortFileName(fileName)
    if not g.os_path_exists(fileName):
        ok = g.writeFile(contents, encoding, fileName)
        if ok:
            c.setFileTimeStamp(fileName)
            if not g.unitTesting:
                g.es(f"{timestamp}created: {fileName}")
            if root:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(fileName, root)
                at.checkPythonCode(contents, fileName, root)
        else:
            at.addToOrphanList(root)
        # No original file to change. Return value tested by a unit test.
        return False  # No change to original file.
    #
    # Compare the old and new contents.
    old_contents = g.readFileIntoUnicodeString(fileName,
        encoding=at.encoding, silent=True)
    unchanged = (
        contents == old_contents or
        (not at.explicitLineEnding and at.compareIgnoringLineEndings(
        old_contents, contents)) or
        ignoreBlankLines and at.compareIgnoringBlankLines(old_contents, contents))
    if unchanged:
        if not g.unitTesting and c.config.getBool(
            'report-unchanged-files', default=True):
            g.es(f"{timestamp}unchanged: {sfn}")
        # Leo 5.6: Check unchanged files.
        at.checkPythonCode(contents, fileName, root, pyflakes_errors_only=True)
        return False  # No change to original file.
    #
    # Warn if we are only adjusting the line endings.
    if at.explicitLineEnding:
        ok = (
            at.compareIgnoringLineEndings(old_contents, contents) or
            ignoreBlankLines and at.compareIgnoringLineEndings(
            old_contents, contents))
        if not ok:
            g.warning("correcting line endings in:", fileName)
    #
    # Write a changed file.
    ok = g.writeFile(contents, encoding, fileName)
    if ok:
        c.setFileTimeStamp(fileName)
        if not g.unitTesting:
            g.es(f"{timestamp}wrote: {sfn}")
    else:
        g.error('error writing', sfn)
        g.es('not written:', sfn)
        at.addToOrphanList(root)
    at.checkPythonCode(contents, fileName, root)
        # Check *after* writing the file.
    return ok
</t>
<t tx="ekr.20190114061452.27">def compareIgnoringBlankLines(self, s1, s2):
    """Compare two strings, ignoring blank lines."""
    assert g.isUnicode(s1), g.callers()
    assert g.isUnicode(s2), g.callers()
    if s1 == s2:
        return True
    s1 = g.removeBlankLines(s1)
    s2 = g.removeBlankLines(s2)
    return s1 == s2
</t>
<t tx="ekr.20190114061452.28">def compareIgnoringLineEndings(self, s1, s2):
    """Compare two strings, ignoring line endings."""
    assert g.isUnicode(s1), g.callers()
    assert g.isUnicode(s2), g.callers()
    if s1 == s2:
        return True
    # Wrong: equivalent to ignoreBlankLines!
        # s1 = s1.replace('\n','').replace('\r','')
        # s2 = s2.replace('\n','').replace('\r','')
    s1 = s1.replace('\r', '')
    s2 = s2.replace('\r', '')
    return s1 == s2
</t>
<t tx="ekr.20190123051253.1">def remove_temp_file(self, p, path):
    """
    Remove any existing *temp* file for p and path, updating self.files.
    """
    for ef in self.files:
        if path and path == ef.path and p.v == ef.p.v:
            self.destroy_temp_file(ef)
            self.files = [z for z in self.files if z != ef]
            return
</t>
<t tx="ekr.20190201104956.1">def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190326183005.1">def reloadSettings(self):
    """Complete the initialization of all settings."""
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('jedit.reloadSettings.')
    # Do the basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
</t>
<t tx="ekr.20190402091335.1">from leo.commands import editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='51715f5', # Before, the *original* base of ekr-theme.
    rev2='HEAD',    # After: Latest ekr-theme (or devel) commit.
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406193429.1"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
from leo.core import leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190505173053.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
</t>
<t tx="ekr.20190506055928.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
</t>
<t tx="ekr.20190506060857.1"></t>
<t tx="ekr.20190506061636.1"></t>
<t tx="ekr.20190602134414.1">def _change_all_search_and_replace(self, s):
    """
    Search s for self.find_text and replace with self.change_text.
    
    Return (found, new text)
    """
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:
        return False, None
    #
    # Order matters: regex matches ignore whole-word.
    if self.pattern_match:
        return self._change_all_regex(s)
    if self.whole_word:
        return self._change_all_word(s)
    return self._change_all_plain(s)
</t>
<t tx="ekr.20190602151043.2">def _change_all_regex(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.make_regex_subs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20190602151043.4">def _change_all_plain(self, s):
    """
    Perform all plain find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0 &amp; change.
        count += 1
        result.append(s0[prev_i:i])
        result.append(change)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190602155933.1">def _change_all_word(self, s):
    """
    Perform all whole word find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0, change &amp; find0.
        result.append(s0[prev_i:i])
        if g.match_word(s, i, find):
            count += 1
            result.append(change)
        else:
            result.append(find0)
        prev_i = i + len(find)
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import sys
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member
</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
     if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20191206073301.1">@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
</t>
<t tx="ekr.20191207065251.1"></t>
<t tx="ekr.20200108082833.1">def test_lines_before_class(self):

    contents = """\
a = 2
class aClass:
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
</t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length</t>
<t tx="ekr.20200212095937.6"></t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200304130514.1">def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200522075411.1">def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&amp;', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
</t>
<t tx="ekr.20200523135601.1">def insertCharFromEvent(self, event):
    """
    Handle the character given by event, ignoring various special keys:
    - getArg state: k.getArg.
    - Tree: onCanvasKey or onHeadlineKey.
    - Body: ec.selfInsertCommand
    - Log: log_w.insert
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if trace: g.trace('stroke', stroke, 'plain:', k.isPlainKey(stroke), 'widget', name)
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
</t>
<t tx="ekr.20200524151214.1"></t>
<t tx="ekr.20200526074132.1">def executeMinibufferCommand(self, commandName):
    """Call c.doCommandByName, creating the required event."""
    c = self
    event = g.app.gui.create_key_event(c)
    return c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20200727095246.1"></t>
<t tx="ekr.20200913074639.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
</t>
<t tx="ekr.20200913074701.1"># in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20200913075121.1">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20200913075250.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200913082124.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200913082155.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200914071303.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012111649.1">gnx: ekr.20170925083314.1
</t>
<t tx="ekr.20201012111649.3">gnx: ekr.20170925083853.1
</t>
<t tx="ekr.20201012114516.1">@nosearch
</t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.14">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20201013034742.15">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20201013034742.16">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.set_find_text(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.25"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20201013034742.26">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201018062305.1">"""
Overwrite LeoPyRef.leo from the given list of nodes.

This script will delete any nodes that are in LeoPyRef.leo but not in
leoPy.leo.

"""
import io
import os
@others
main(node_list = ['Startup', 'Notes', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by Виталије Милошевић.
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = io.StringIO()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("&lt;vnodes&gt;\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("&lt;/vnodes&gt;\n")
    fc.putTnodes()
    fc.putPostlog()
    s = fc.outputFile.getvalue()
    fc.outputFile = None
    return s
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="ekr.20201021075956.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes at the end of the file marked with "EKR".

@others
if use_php_hack:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = rulesDict4 # EKR: was php_rulesDict1
@language python
@tabwidth -4
</t>
<t tx="ekr.20201021093630.1"></t>
<t tx="ekr.20201022053829.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1718

@language python
@nosearch
</t>
<t tx="ekr.20201022053907.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes by EKR.
&lt;&lt; Attribute dicts &gt;&gt;
&lt;&lt; Keyword dicts &gt;&gt;
@others
&lt;&lt; rulesDictDict &gt;&gt;
# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}
if False:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = php_php_rulesdict

@language python
@tabwidth -4
</t>
<t tx="ekr.20201022053907.10">def php_php_function_rule(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

def php_php_keyword_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

def php_php_keyword_rule2(colorer, s, i):
    return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20201022053907.11">def php_php_op1(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op2(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op3(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op4(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op5(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op7(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op8(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op9(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op10(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op11(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op12(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op13(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op14(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op16(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op17(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op18(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op19(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op20(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op21(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op22(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op23(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op24(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op25(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op26(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op27(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
</t>
<t tx="ekr.20201022053907.12"># Rules dict for php_php ruleset.
php_php_rulesdict = {
    "!": [php_php_op3],
    "\"": [php_php_literal1],
    "#": [php_php_comment4],
    "$": [php_php_keyword_rule1],
    "%": [php_php_op13],
    "&amp;": [php_php_op14],
    "'": [php_php_literal2],
    "(": [php_php_function_rule],
    "*": [php_php_op10],
    "+": [php_php_op7],
    ",": [php_php_op21],
    "-": [php_php_op2, php_php_op8],
    ".": [php_php_op18],
    "/": [php_php_comment1, php_php_comment2, php_php_comment3, php_php_op9],
    "0": [php_php_keyword_rule2],
    "1": [php_php_keyword_rule2],
    "2": [php_php_keyword_rule2],
    "3": [php_php_keyword_rule2],
    "4": [php_php_keyword_rule2],
    "5": [php_php_keyword_rule2],
    "6": [php_php_keyword_rule2],
    "7": [php_php_keyword_rule2],
    "8": [php_php_keyword_rule2],
    "9": [php_php_keyword_rule2],
    ":": [php_php_op27],
    ";": [php_php_op22],
    "&lt;": [php_php_op5, php_php_op12],
    "&lt; ": [php_php_literal4],
    "=": [php_php_op1, php_php_op6],
    "&gt;": [php_php_op4, php_php_op11],
    "?": [php_php_op25],
    "@": [php_php_op26, php_php_keyword_rule2],
    "A": [php_php_keyword_rule2],
    "B": [php_php_keyword_rule2],
    "C": [php_php_keyword_rule2],
    "D": [php_php_keyword_rule2],
    "E": [php_php_keyword_rule2],
    "F": [php_php_keyword_rule2],
    "G": [php_php_keyword_rule2],
    "H": [php_php_keyword_rule2],
    "I": [php_php_keyword_rule2],
    "J": [php_php_keyword_rule2],
    "K": [php_php_keyword_rule2],
    "L": [php_php_keyword_rule2],
    "M": [php_php_keyword_rule2],
    "N": [php_php_keyword_rule2],
    "O": [php_php_keyword_rule2],
    "P": [php_php_keyword_rule2],
    "Q": [php_php_keyword_rule2],
    "R": [php_php_keyword_rule2],
    "S": [php_php_keyword_rule2],
    "T": [php_php_keyword_rule2],
    "U": [php_php_keyword_rule2],
    "V": [php_php_keyword_rule2],
    "W": [php_php_keyword_rule2],
    "X": [php_php_keyword_rule2],
    "Y": [php_php_keyword_rule2],
    "Z": [php_php_keyword_rule2],
    "[": [php_php_op24],
    "]": [php_php_op23],
    "^": [php_php_op16],
    "_": [php_php_keyword_rule2],
    "`": [php_php_literal3],
    "a": [php_php_keyword_rule2],
    "b": [php_php_keyword_rule2],
    "c": [php_php_keyword_rule2],
    "d": [php_php_keyword_rule2],
    "e": [php_php_keyword_rule2],
    "f": [php_php_keyword_rule2],
    "g": [php_php_keyword_rule2],
    "h": [php_php_keyword_rule2],
    "i": [php_php_keyword_rule2],
    "j": [php_php_keyword_rule2],
    "k": [php_php_keyword_rule2],
    "l": [php_php_keyword_rule2],
    "m": [php_php_keyword_rule2],
    "n": [php_php_keyword_rule2],
    "o": [php_php_keyword_rule2],
    "p": [php_php_keyword_rule2],
    "q": [php_php_keyword_rule2],
    "r": [php_php_keyword_rule2],
    "s": [php_php_keyword_rule2],
    "t": [php_php_keyword_rule2],
    "u": [php_php_keyword_rule2],
    "v": [php_php_keyword_rule2],
    "w": [php_php_keyword_rule2],
    "x": [php_php_keyword_rule2],
    "y": [php_php_keyword_rule2],
    "z": [php_php_keyword_rule2],
    "{": [php_php_op20],
    "|": [php_php_op15],
    "}": [php_php_op19],
    "~": [php_php_op17],
}
</t>
<t tx="ekr.20201022053907.13"># Rules for the php_php_literal ruleset.

def php_php_literal_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
php_php_literal_rulesdict = {
    "$": [php_php_literal_rule1],
}
</t>
<t tx="ekr.20201022053907.14"># Rules for the php_javascript_php ruleset...

def php_javascript_php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_javascript_php ruleset.
php_javascript_php_rulesdict = {
    "&lt;": [
        php_javascript_php_rule1,
        php_javascript_php_rule2,
        php_javascript_php_rule3],
}
</t>
<t tx="ekr.20201022053907.15"># Rules for the php_javascript ruleset...

def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
php_javascript_rulesdict = {
    "&gt;": [php_rule58],
    "S": [php_rule59],
}

</t>
<t tx="ekr.20201022053907.16">def phpdoc_rule1(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule2(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def phpdoc_rule4(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule5(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)
        
def phpdoc_rule8(colorer, s, i):
    return colorer.match_keywords(s, i)
    
# Rules dict for php_phpdoc ruleset.
phpdoc_rulesdict = {
    "*": [phpdoc_rule2],
    "0": [phpdoc_rule8],
    "1": [phpdoc_rule8],
    "2": [phpdoc_rule8],
    "3": [phpdoc_rule8],
    "4": [phpdoc_rule8],
    "5": [phpdoc_rule8],
    "6": [phpdoc_rule8],
    "7": [phpdoc_rule8],
    "8": [phpdoc_rule8],
    "9": [phpdoc_rule8],
    "&lt;": [phpdoc_rule3,phpdoc_rule4,phpdoc_rule5,phpdoc_rule6,phpdoc_rule7],
    "@": [phpdoc_rule8],
    "A": [phpdoc_rule8],
    "B": [phpdoc_rule8],
    "C": [phpdoc_rule8],
    "D": [phpdoc_rule8],
    "E": [phpdoc_rule8],
    "F": [phpdoc_rule8],
    "G": [phpdoc_rule8],
    "H": [phpdoc_rule8],
    "I": [phpdoc_rule8],
    "J": [phpdoc_rule8],
    "K": [phpdoc_rule8],
    "L": [phpdoc_rule8],
    "M": [phpdoc_rule8],
    "N": [phpdoc_rule8],
    "O": [phpdoc_rule8],
    "P": [phpdoc_rule8],
    "Q": [phpdoc_rule8],
    "R": [phpdoc_rule8],
    "S": [phpdoc_rule8],
    "T": [phpdoc_rule8],
    "U": [phpdoc_rule8],
    "V": [phpdoc_rule8],
    "W": [phpdoc_rule8],
    "X": [phpdoc_rule8],
    "Y": [phpdoc_rule8],
    "Z": [phpdoc_rule8],
    "_": [phpdoc_rule8],
    "a": [phpdoc_rule8],
    "b": [phpdoc_rule8],
    "c": [phpdoc_rule8],
    "d": [phpdoc_rule8],
    "e": [phpdoc_rule8],
    "f": [phpdoc_rule8],
    "g": [phpdoc_rule8],
    "h": [phpdoc_rule8],
    "i": [phpdoc_rule8],
    "j": [phpdoc_rule8],
    "k": [phpdoc_rule8],
    "l": [phpdoc_rule8],
    "m": [phpdoc_rule8],
    "n": [phpdoc_rule8],
    "o": [phpdoc_rule8],
    "p": [phpdoc_rule8],
    "q": [phpdoc_rule8],
    "r": [phpdoc_rule8],
    "s": [phpdoc_rule8],
    "t": [phpdoc_rule8],
    "u": [phpdoc_rule8],
    "v": [phpdoc_rule8],
    "w": [phpdoc_rule8],
    "x": [phpdoc_rule8],
    "y": [phpdoc_rule8],
    "z": [phpdoc_rule8],
    "{": [phpdoc_rule1],
}
</t>
<t tx="ekr.20201022053907.17"># rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": php_javascript_rulesdict,
    "php_javascript_php": php_javascript_php_rulesdict,
    "php_main": php_main_rulesdict,
    "php_php": php_php_rulesdict,
    "php_php_literal": php_php_literal_rulesdict,
    "php_phpdoc": phpdoc_rulesdict,
    "php_tags": php_tags_rulesdict,
    "php_tags_literal": php_tags_literal_rulesdict,
}
</t>
<t tx="ekr.20201022053907.2">

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}
</t>
<t tx="ekr.20201022053907.3"># Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}
</t>
<t tx="ekr.20201022053907.4"># Rules for php_main ruleset...
# All rules start with '&lt;' or '&amp;'.

def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup",
        begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
php_main_rulesdict = {
    "&amp;": [php_rule9],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule4,php_rule5,php_rule6,php_rule7,php_rule8],
}
</t>
<t tx="ekr.20201022053907.5"># Rules for the php_tags ruleset...

def php_tags_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule4(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
# Rules dict for php_tags ruleset.
php_tags_rulesdict = {
    "\"": [php_tags_rule4,],
    "'": [php_tags_rule5,],
    "&lt;": [php_tags_rule1, php_tags_rule2, php_tags_rule3,],
    "=": [php_tags_rule6,],
}

</t>
<t tx="ekr.20201022053907.6">def php_tags_literal_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
php_tags_literal_rulesdict = {
    "&lt;": [
        php_tags_literal_rule1,
        php_tags_literal_rule2,
        php_tags_literal_rule3,
    ],
}
</t>
<t tx="ekr.20201022053907.7"># Rules for the php_php ruleset...

</t>
<t tx="ekr.20201022053907.8">def php_php_comment1(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment2(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment3(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

def php_php_comment4(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)
</t>
<t tx="ekr.20201022053907.9">def php_php_literal1(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal2(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal3(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1",
        begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</t>
<t tx="ekr.20201022055738.1">use_php_hack = False

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}

# Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}

# Rules for php_main ruleset.

</t>
<t tx="ekr.20201022055738.10">def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.11">def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
rulesDict1 = {
    "&amp;": [php_rule9,],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule5,php_rule6,php_rule7,php_rule8,],
    "&lt; ": [php_rule4,],
}

# Rules for php_tags ruleset.

</t>
<t tx="ekr.20201022055738.12">def php_rule10(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.13">def php_rule11(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.14">def php_rule12(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.15">def php_rule13(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.16">def php_rule14(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.17">def php_rule15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

# Rules dict for php_tags ruleset.
rulesDict2 = {
    "\"": [php_rule13,],
    "'": [php_rule14,],
    "&lt;": [php_rule10,php_rule11,php_rule12,],
    "=": [php_rule15,],
}

# Rules for php_tags_literal ruleset.

</t>
<t tx="ekr.20201022055738.18">def php_rule16(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.19">def php_rule17(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.2">def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.20">def php_rule18(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
rulesDict3 = {
    "&lt;": [php_rule16,php_rule17,php_rule18,],
}

# Rules for php_php ruleset.

</t>
<t tx="ekr.20201022055738.21">def php_rule19(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.22">def php_rule20(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.23">def php_rule21(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.24">def php_rule22(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.25">def php_rule23(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.26">def php_rule24(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.27">def php_rule25(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.28">def php_rule26(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1", begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.29">def php_rule27(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

</t>
<t tx="ekr.20201022055738.3">def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.30">def php_rule28(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.31">def php_rule29(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.32">def php_rule30(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.33">def php_rule31(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.34">def php_rule32(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.35">def php_rule33(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.36">def php_rule34(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.37">def php_rule35(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.38">def php_rule36(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.39">def php_rule37(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.4">def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.40">def php_rule38(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.41">def php_rule39(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.42">def php_rule40(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.43">def php_rule41(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.44">def php_rule42(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.45">def php_rule43(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.46">def php_rule44(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.47">def php_rule45(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.48">def php_rule46(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.49">def php_rule47(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.5">def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.50">def php_rule48(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.51">def php_rule49(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.52">def php_rule50(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.53">def php_rule51(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.54">def php_rule52(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.55">def php_rule53(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.56">def php_rule54(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.57">def php_rule55(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

</t>
<t tx="ekr.20201022055738.58">def php_rule56(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_php ruleset.
rulesDict4 = {
    "!": [php_rule30,],
    "\"": [php_rule21,],
    "#": [php_rule25,],
    "$": [php_rule27,],
    "%": [php_rule40,],
    "&amp;": [php_rule41,],
    "'": [php_rule22,],
    "(": [php_rule55,],
    "*": [php_rule37,],
    "+": [php_rule34,],
    ",": [php_rule48,],
    "-": [php_rule29,php_rule35,],
    ".": [php_rule45,],
    "/": [php_rule19,php_rule20,php_rule24,php_rule36,],
    "0": [php_rule56,],
    "1": [php_rule56,],
    "2": [php_rule56,],
    "3": [php_rule56,],
    "4": [php_rule56,],
    "5": [php_rule56,],
    "6": [php_rule56,],
    "7": [php_rule56,],
    "8": [php_rule56,],
    "9": [php_rule56,],
    ":": [php_rule54,],
    ";": [php_rule49,],
    "&lt;": [php_rule32,php_rule39,],
    "&lt; ": [php_rule26,],
    "=": [php_rule28,php_rule33,],
    "&gt;": [php_rule31,php_rule38,],
    "?": [php_rule52,],
    "@": [php_rule53,php_rule56,],
    "A": [php_rule56,],
    "B": [php_rule56,],
    "C": [php_rule56,],
    "D": [php_rule56,],
    "E": [php_rule56,],
    "F": [php_rule56,],
    "G": [php_rule56,],
    "H": [php_rule56,],
    "I": [php_rule56,],
    "J": [php_rule56,],
    "K": [php_rule56,],
    "L": [php_rule56,],
    "M": [php_rule56,],
    "N": [php_rule56,],
    "O": [php_rule56,],
    "P": [php_rule56,],
    "Q": [php_rule56,],
    "R": [php_rule56,],
    "S": [php_rule56,],
    "T": [php_rule56,],
    "U": [php_rule56,],
    "V": [php_rule56,],
    "W": [php_rule56,],
    "X": [php_rule56,],
    "Y": [php_rule56,],
    "Z": [php_rule56,],
    "[": [php_rule51,],
    "]": [php_rule50,],
    "^": [php_rule43,],
    "_": [php_rule56,],
    "`": [php_rule23,],
    "a": [php_rule56,],
    "b": [php_rule56,],
    "c": [php_rule56,],
    "d": [php_rule56,],
    "e": [php_rule56,],
    "f": [php_rule56,],
    "g": [php_rule56,],
    "h": [php_rule56,],
    "i": [php_rule56,],
    "j": [php_rule56,],
    "k": [php_rule56,],
    "l": [php_rule56,],
    "m": [php_rule56,],
    "n": [php_rule56,],
    "o": [php_rule56,],
    "p": [php_rule56,],
    "q": [php_rule56,],
    "r": [php_rule56,],
    "s": [php_rule56,],
    "t": [php_rule56,],
    "u": [php_rule56,],
    "v": [php_rule56,],
    "w": [php_rule56,],
    "x": [php_rule56,],
    "y": [php_rule56,],
    "z": [php_rule56,],
    "{": [php_rule47,],
    "|": [php_rule42,],
    "}": [php_rule46,],
    "~": [php_rule44,],
}

# Rules for php_php_literal ruleset.

</t>
<t tx="ekr.20201022055738.59">def php_rule57(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
rulesDict5 = {
    "$": [php_rule57,],
}

# Rules for php_javascript ruleset.

</t>
<t tx="ekr.20201022055738.6">def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup", begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.60">def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

</t>
<t tx="ekr.20201022055738.61">def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
rulesDict6 = {
    "&gt;": [php_rule58,],
    "S": [php_rule59,],
}

# Rules for php_javascript_php ruleset.

</t>
<t tx="ekr.20201022055738.62">def php_rule60(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.63">def php_rule61(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.64">def php_rule62(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)


# Rules dict for php_javascript_php ruleset.
rulesDict7 = {
    "&lt;": [php_rule60,php_rule61,php_rule62,],
}

# Rules for php_phpdoc ruleset.

</t>
<t tx="ekr.20201022055738.65">def php_rule63(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.66">def php_rule64(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.67">def php_rule65(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.68">def php_rule66(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.69">def php_rule67(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.7">def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.70">def php_rule68(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.71">def php_rule69(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)

</t>
<t tx="ekr.20201022055738.72">def php_rule70(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_phpdoc ruleset.
rulesDict8 = {
    "*": [php_rule64,],
    "0": [php_rule70,],
    "1": [php_rule70,],
    "2": [php_rule70,],
    "3": [php_rule70,],
    "4": [php_rule70,],
    "5": [php_rule70,],
    "6": [php_rule70,],
    "7": [php_rule70,],
    "8": [php_rule70,],
    "9": [php_rule70,],
    "&lt;": [php_rule65,php_rule66,php_rule67,php_rule68,php_rule69,],
    "@": [php_rule70,],
    "A": [php_rule70,],
    "B": [php_rule70,],
    "C": [php_rule70,],
    "D": [php_rule70,],
    "E": [php_rule70,],
    "F": [php_rule70,],
    "G": [php_rule70,],
    "H": [php_rule70,],
    "I": [php_rule70,],
    "J": [php_rule70,],
    "K": [php_rule70,],
    "L": [php_rule70,],
    "M": [php_rule70,],
    "N": [php_rule70,],
    "O": [php_rule70,],
    "P": [php_rule70,],
    "Q": [php_rule70,],
    "R": [php_rule70,],
    "S": [php_rule70,],
    "T": [php_rule70,],
    "U": [php_rule70,],
    "V": [php_rule70,],
    "W": [php_rule70,],
    "X": [php_rule70,],
    "Y": [php_rule70,],
    "Z": [php_rule70,],
    "_": [php_rule70,],
    "a": [php_rule70,],
    "b": [php_rule70,],
    "c": [php_rule70,],
    "d": [php_rule70,],
    "e": [php_rule70,],
    "f": [php_rule70,],
    "g": [php_rule70,],
    "h": [php_rule70,],
    "i": [php_rule70,],
    "j": [php_rule70,],
    "k": [php_rule70,],
    "l": [php_rule70,],
    "m": [php_rule70,],
    "n": [php_rule70,],
    "o": [php_rule70,],
    "p": [php_rule70,],
    "q": [php_rule70,],
    "r": [php_rule70,],
    "s": [php_rule70,],
    "t": [php_rule70,],
    "u": [php_rule70,],
    "v": [php_rule70,],
    "w": [php_rule70,],
    "x": [php_rule70,],
    "y": [php_rule70,],
    "z": [php_rule70,],
    "{": [php_rule63,],
}

# x.rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": rulesDict6,
    "php_javascript_php": rulesDict7,
    "php_main": rulesDict1,
    "php_php": rulesDict4,
    "php_php_literal": rulesDict5,
    "php_phpdoc": rulesDict8,
    "php_tags": rulesDict2,
    "php_tags_literal": rulesDict3,
}

# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}

# EKR
</t>
<t tx="ekr.20201022055738.8">def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.9">def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201030053803.1"></t>
<t tx="ekr.20201109075104.1">def afterChangeBody(self, p, command, bunch):
    """
    Create an undo node using d created by beforeChangeNode.
    
    *Important*: Before calling this method, caller must:
    - Set p.v.b. (Setting p.b would cause a redraw).
    - Set the desired selection range and insert point.
    - Set the y-scroll position, if desired.
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'body'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeBody
    bunch.redoHelper = u.redoChangeBody
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newIns = w.getInsertPoint()
    bunch.newMarked = p.isMarked()
    # Careful: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
    # 
    if g.unitTesting:
        assert command.lower() != 'typing', g.callers()
    elif command.lower() == 'typing':
        g.trace(
            'Error: undoType should not be "Typing"\n'
            'Call u.doTyping instead')
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20201110015336.1">g.cls()
import os
import re
path = os.path.join(g.app.loadDir, '..', 'modes', 'php.py')
with open(path, 'r') as f:
    contents = f.read()
def_pat = r'^def\s*(php_rule[0-9]+)'
for line in g.splitLines(contents):
    m = re.match(def_pat, line)
    if m:
        print(m.group(1))</t>
<t tx="ekr.20201111052557.1">def patch_1591(self):
    ''' behavior change in PyQt versions greater than 5.12 --
        workaround is to manually set the button icons /and/ sizes
    '''

    size = QtCore.QSize(16,16)
    ui = self.ui.UI

    for i in range(10):
        button = getattr(ui, f"butPri{i}")
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', "cleo", f"pri{i}.png")
        button.setIcon(QtGui.QIcon(path))
        button.setIconSize(size)
        button.setToolTip(f"Priority {i}")

    table = (
            # Alternate priorities...
            ('butPriChk', 'chkblk.png', 'Check Mark'),
            ('butPriToDo', 'chkboxblk.png', 'Box Mark'),
            ('butPriX', 'xblk.png', 'Black X'),
            ('butPriXgry', 'xgry.png', 'Gray X'),
            ('butPriBang', 'bngblk.png', 'Exclamation Point'),
            ('butPriQuery', 'qryblk.png', 'Question Mark'),
            ('butPriBullet', 'bullet.png', 'Bullet'),
            ('butPriClr', 'edit-clear.png', 'Clear Priority'),
            # Other labels...
            ('butDetails', 'document-save.png', 'Toggle Details'),
            ('butNext', 'down.png', 'Next Node'),
            ('butNextTodo', 'bottom.png', 'Next To Do'),
            ('butClrTime', 'edit-clear.png', 'Clear Required Time'),
            ('butClrProg', 'edit-clear.png', 'Clear Progress')
        )

    for attr, icon, tooltip in table:
        button = getattr(ui, attr)
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', "cleo", icon)
        button.setIcon(QtGui.QIcon(path))
        button.setIconSize(size)
        button.setToolTip(tooltip)
</t>
<t tx="ekr.20201113190926.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1734

@language python
@nosearch
</t>
<t tx="ekr.20201114110737.1">def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    
    Return the value returned by the command, or None if no command is executed.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return None
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&amp;', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return None
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        return None
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return None
    #
    # Invoke the command, if given.
    if func:
        return_value = c.doCommand(func, commandName, event=event)
        if c.exists:
            c.frame.updateStatusLine()
        return return_value
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return None
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()
    return None
</t>
<t tx="ekr.20201114160816.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">**Move More**

- Beautify files.
- Call Art Institue re membership.

- P: Finish monk painting.
- P: Memorize first page of Courante (Hands together).
- P: Start arranging rest of Bethena waltz.

Leo:
*** Reply to Félix.
- Remove version stuff in plugins.
- New issue: (test in devel) import-file fails for external files. 
- New Issue: Improve tutorials with Grammarly.

Promises:
- P: Limit Leo work to 2 hours/day.
- P: Limit social media time.
- Use music study as a break from music practice.

@language rest
@wrap
@nosearch</t>
<t tx="ekr.20201119104633.1"></t>
<t tx="ekr.20201119113415.1">************* Module leo.commands.killBufferCommands
killBufferCommands.py:297:16: E1102: self.kbiterator.next is not callable (not-callable)

************* Module leo.core.leoKeys
leoKeys.py:3135:12: E1102: handler is not callable (not-callable)

************* Module leo.core.leoRst
leoRst.py:1804:8: E1121: Too many positional arguments for method call (too-many-function-args)
leoRst.py:1991:8: E1120: No value for argument 'p' in method call (no-value-for-parameter)

************* Module leo.plugins.active_path
active_path.py:284:16: E1120: No value for argument 'a' in function call (no-value-for-parameter)

************* Module leo.plugins.bookmarks
bookmarks.py:489:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
bookmarks.py:544:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.cursesGui2
cursesGui2.py:481:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2740:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2974:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3122:4: W0222: Signature differs from overridden 'display' method (signature-differs)
cursesGui2.py:3128:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3134:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3298:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3756:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3976:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.demo
demo.py:31:8: E1101: Instance of 'LeoApp' has no 'next' member (no-member)
demo.py:39:8: E1101: Instance of 'LeoApp' has no 'prev' member (no-member)
demo.py:47:8: E1101: Instance of 'LeoApp' has no 'end' member (no-member)
demo.py:274:28: E1102: self.next is not callable (not-callable)
demo.py:276:24: E1102: self.next is not callable (not-callable)
demo.py:727:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:732:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:745:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:766:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:787:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:795:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:799:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:806:13: E1101: Instance of 'LeoApp' has no 'get_icon_fn' member (no-member)
demo.py:824:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:825:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:833:12: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:844:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:848:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:855:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:859:25: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:860:24: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:893:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:902:12: E1101: Instance of 'LeoApp' has no 'find_node' member (no-member)
demo.py:904:25: E1101: Instance of 'LeoApp' has no 'headline_geometry' member (no-member)

************* Module leo.plugins.importers.javascript
importers/javascript.py:520:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.notebook
notebook.py:74:12: E0611: No name 'QtQuick' in module 'PyQt5' (no-name-in-module)

************* Module leo.plugins.python_terminal
python_terminal.py:76:12: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
python_terminal.py:294:16: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.quicksearch
quicksearch.py:249:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.read_only_nodes
read_only_nodes.py:167:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:200:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:221:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)

************* Module leo.plugins.screencast
screencast.py:622:16: E1102: m.next is not callable (not-callable)
screencast.py:683:12: E1102: m.next is not callable (not-callable)
screencast.py:689:12: E1102: m.next is not callable (not-callable)
screencast.py:691:12: E1102: m.next is not callable (not-callable)
screencast.py:693:12: E1102: m.prev is not callable (not-callable)

************* Module leo.plugins.stickynotes_plus
stickynotes_plus.py:184:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
</t>
<t tx="ekr.20201119114229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1746

@language python
@nosearch
</t>
<t tx="ekr.20201119120953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1747

@language python
@nosearch
</t>
<t tx="ekr.20201128045435.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1760

These seem harmless, but they are mysterious.

@language python
@nosearch


</t>
<t tx="ekr.20201128050540.1">c:\leo.repo\leo-editor&gt;python c:\leo.repo\leo-editor\launchLeo.py --no-splash --gui=qttabs leo\core\leoPy.leo

Leo 6.4-devel, ekr-undo branch, build d1ba6bc993

2020-11-27 15:02:52 -0600
wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
pylint: leoKeys.py
pylint finished
Starting log_listener.py
About to start TCP server...
--------------------
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
   pr: Saving: c:/leo.repo/leo-editor/leo/test/unitTest.leo
listener suspended
killed log listener.

c:\leo.repo\leo-editor&gt;</t>
<t tx="ekr.20201128051459.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1733

@language python
@nosearch
</t>
<t tx="ekr.20201128052211.1">@nosearch

# flattened, word, ignore-case, body

# found 22 nodes</t>
<t tx="ekr.20201128125708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1758

**After** the sabbatical:

- Enable tests of selection range.
- Enable tests of undo/redo.
- Rename 'directives' kwarg to 'parent_b'.
- Remove tempNode.
- (Maybe): run-all-tests command.

@language python
@nosearch
</t>
<t tx="ekr.20201128132124.1"></t>
<t tx="ekr.20201128132228.1"></t>
<t tx="ekr.20201128132310.1"></t>
<t tx="ekr.20201128132526.1"></t>
<t tx="ekr.20201128133405.1"></t>
<t tx="ekr.20201128133541.1"></t>
<t tx="ekr.20201128164717.1"></t>
<t tx="ekr.20201128164717.10">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.100">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.101">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.102">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.103">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.104">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.105">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.106">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.107">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.108">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.109"></t>
<t tx="ekr.20201128164717.11">vr = c.helpCommands.helpForBindings()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.110">from leo.core import leoBeautify
from leo.commands import convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.111">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20201128164717.112">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.113">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.114">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.115">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.116">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.118">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.12">vr = c.helpCommands.helpForFindCommands()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.120">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.121">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.122">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.123">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.124">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.125"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.126"># Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
</t>
<t tx="ekr.20201128164717.127"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.128">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.129">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.13">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.130">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.131">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.132">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        target = p.copy()
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h, c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
</t>
<t tx="ekr.20201128164717.133"></t>
<t tx="ekr.20201128164717.136"></t>
<t tx="ekr.20201128164717.137"></t>
<t tx="ekr.20201128164717.138"></t>
<t tx="ekr.20201128164717.139"></t>
<t tx="ekr.20201128164717.14">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.140"></t>
<t tx="ekr.20201128164717.141">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.142">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.145"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

</t>
<t tx="ekr.20201128164717.146"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0:
        c.undoer.undo()
</t>
<t tx="ekr.20201128164717.147">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.148">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.149">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.15">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.150">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.151">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.152">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.153">first line
    line 1
last line
</t>
<t tx="ekr.20201128164717.154">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.155">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
</t>
<t tx="ekr.20201128164717.156">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.157">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.158">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.159">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.16">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.160">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.161">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.162">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.164">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.165">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.166">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.167">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.168">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.169">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.17">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.170">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.171">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.172">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.174">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.175">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.176">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.177">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.178">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.179">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.18">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.180">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.181">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.182">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.184">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.186">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.188">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.189">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.19">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.190">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.191">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.192">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.193">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.194">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.195">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.196">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.197">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.198">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.199">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.2"></t>
<t tx="ekr.20201128164717.20">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.200">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.202">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.204">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.205">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.206">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.207">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.208">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.209">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.21">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.210">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.211">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.212"># Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
</t>
<t tx="ekr.20201128164717.213"></t>
<t tx="ekr.20201128164717.214">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.215">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.216">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.217">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.218">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.219">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.22">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.220">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.221">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.222">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.223">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.224">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.225">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.226">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.227">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.228">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.229">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.23">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.230">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.231">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.232">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.233">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.234">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.235">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.236">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.237">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.238">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.239">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.24">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.240">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.241">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.242"></t>
<t tx="ekr.20201128164717.245"></t>
<t tx="ekr.20201128164717.246"></t>
<t tx="ekr.20201128164717.247"></t>
<t tx="ekr.20201128164717.248"></t>
<t tx="ekr.20201128164717.249"></t>
<t tx="ekr.20201128164717.25">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.250"></t>
<t tx="ekr.20201128164717.251">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.254">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.255">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.256">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.257">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.258">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.259">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.26">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.260">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.261">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.262">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.263">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.266">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.267">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.268">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.269">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.27">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.270">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.271">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.272">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.273">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.274">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.275">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.276">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.277">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.278">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.279">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.28">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.280">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.281">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.282">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.283">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.284">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.285">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.286">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.287">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.288">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.289">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.29">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.290">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.291">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.292">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.293">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.294">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.295">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.296">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.297">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.298">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.299">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
</t>
<t tx="ekr.20201128164717.3">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.30">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.300">result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
</t>
<t tx="ekr.20201128164717.301">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.302">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.303">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.304">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.305">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.306">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.308">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.309">c.editCommands.ccolumn = 4 # Set the comment column
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.31">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.310">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.311">first line
line b
last line
</t>
<t tx="ekr.20201128164717.312">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.313">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.314">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.315">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.316">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.317">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.318">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.319">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.32">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.320">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.321">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.322">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.323">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.324">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.325">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.326">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.327">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.328">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.329">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.33">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.330">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.331">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.332">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.333"># To do: use tables as in the clean-c test.
</t>
<t tx="ekr.20201128164717.334">child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20201128164717.335">@language python
def spam:
    pass
</t>
<t tx="ekr.20201128164717.336">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
if not sys.platform.startswith('win'):
    self.skipTest('Requires Windows')
trace = False
h = '@auto unittest/at-auto-md-line-number-test.md'
root = g.findNodeAnywhere(c, h)
assert root
s = c.gotoCommands.get_external_file_with_sentinels(root)
if trace:
    print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
for n in range(20):
    p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
    if found:
        if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
    else:
        if trace: print('not found: %s' % (n+1))
        assert n == 8, n
        break
</t>
<t tx="ekr.20201128164717.337"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.org'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.338"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.otl'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 5, n
            break
</t>
<t tx="ekr.20201128164717.339">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20201128164717.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.340"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
</t>
<t tx="ekr.20201128164717.341"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.342"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.343"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.344"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.345"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
</t>
<t tx="ekr.20201128164717.346">c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

</t>
<t tx="ekr.20201128164717.347"></t>
<t tx="ekr.20201128164717.348"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.349">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.350">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.351">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.352">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.353">line 1
line 2

</t>
<t tx="ekr.20201128164717.354">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.355">line 1
line 2

</t>
<t tx="ekr.20201128164717.356">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.357">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.358">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.359">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.36">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.360">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.361">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.362">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.363">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.364"></t>
<t tx="ekr.20201128164717.365"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.366">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.367">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.368">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.369">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.37">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.370">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.371">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.372">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.373">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.374">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.375">line 1
# The next line contains two trailing blanks.
line 3  
line 4
</t>
<t tx="ekr.20201128164717.376">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.377">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.378">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.379">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.38">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.380">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.381">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.382">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.383">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.384">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.385">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.386">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.387">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.388">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.389"></t>
<t tx="ekr.20201128164717.39">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.390">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.391">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.392">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.393">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.394">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.395">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.396">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.397">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.398"># Test of bug 799695: colorizer bug after move-lines-up into a docstring

# import os ; os.system('cls')

n = c.frame.body.colorizer.full_recolor_count

c.testManager.runEditCommandTest(p)

# Not an effective test, even though the bug fix was to call
# c.recolor_now(incremental=False)

# g.trace(n,c.frame.body.colorizer.full_recolor_count)

# assert c.frame.body.colorizer.full_recolor_count &gt; n
</t>
<t tx="ekr.20201128164717.399">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.4">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.40">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.400">@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
</t>
<t tx="ekr.20201128164717.401">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.402">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.403">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.404">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.405">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.406">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.407">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.408">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.409">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.41">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.410">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.411">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.412">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.413">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.414">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.415">a

b
</t>
<t tx="ekr.20201128164717.416">a

b
</t>
<t tx="ekr.20201128164717.417">a

b
</t>
<t tx="ekr.20201128164717.418">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.419">a

b
</t>
<t tx="ekr.20201128164717.42">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.420">a

b
</t>
<t tx="ekr.20201128164717.421">a

b
</t>
<t tx="ekr.20201128164717.422">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.423">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.424">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.425">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.426">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.427">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.428">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.429">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.43">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.430">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.431">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.432">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.433">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.434">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.435">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.436">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.437">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.438">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.439">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.44">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.440">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.441">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.442">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.443">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.444">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.445">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.446">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.447">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.448">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.449">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.45">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.450">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.451">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.452">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.453">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.454">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.455">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.456">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.457">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.458">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.459">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.46">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.460">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.461">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.462">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.463">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.464">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.465">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.466">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.467">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.468">a
d
e
z
x
</t>
<t tx="ekr.20201128164717.469">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.47">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.470">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.471">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.472">c
A
z
X
Y
b
</t>
<t tx="ekr.20201128164717.473">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.474">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = '(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉ©BE|cz):\n'
    u = '(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        binding = 'Return' if char == '\n' else char
        event = g.app.gui.create_key_event(c,char=char,binding=binding,w=w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20201128164717.475">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c, binding='Tab', char='\t', w=w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
</t>
<t tx="ekr.20201128164717.476"># xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
</t>
<t tx="ekr.20201128164717.477">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.478">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.479">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.48">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.480">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.481">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.482">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.483">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.484">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.485">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.486">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.487">x
z
A
c
B
</t>
<t tx="ekr.20201128164717.488">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.489">c.sortRecentFiles()
</t>
<t tx="ekr.20201128164717.49">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.490">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
</t>
<t tx="ekr.20201128164717.491"></t>
<t tx="ekr.20201128164717.492"></t>
<t tx="ekr.20201128164717.493"></t>
<t tx="ekr.20201128164717.494">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.495">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.496">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.497">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.498">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.499">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.5">first line
line 1
    line a
line b
last line
</t>
<t tx="ekr.20201128164717.50">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.500">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.501">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.502">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.503">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.504">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.505">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.506">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.507">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.508">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.509">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.51">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.510">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.511">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.512">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.513">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.514">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.515">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.516">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.517">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.518">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.519">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.52">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.520">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.521">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.522">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.523">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.524">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.525">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.526">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.527">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.528">first line
before bar2 += foo after
last line
</t>
<t tx="ekr.20201128164717.529">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.53">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.530">from leo.core import leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.531">@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength &gt;= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (&lt;any&gt;oldScope).leftCurlyCount or not (&lt;any&gt;oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(&lt;any&gt;oldScope).leftCurlyCount !==(&lt;any&gt;newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(&lt;any&gt;oldScope).rightCurlyCount !==(&lt;any&gt;newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
</t>
<t tx="ekr.20201128164717.532">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.533">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.534">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.535">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.536">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.537">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.538">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.539">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.54">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.540">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.541">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.542">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.543">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.544"></t>
<t tx="ekr.20201128164717.545"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.546">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.547">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.548">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.549"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.55">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.550">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.551">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.552">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.553"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.554">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.555">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.556">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.557"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.558">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.559">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.56">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.560">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.561"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.562">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.563">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.564">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.565"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.566">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.567">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.568">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.569"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.57">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.570">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.571">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.572">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.573"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.574">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.575">@pagewidth 40
'''
docstring.
more docstring.
'''
</t>
<t tx="ekr.20201128164717.576">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.577"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.578">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.579">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.58">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.580">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.581"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.582">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.583">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.584">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.585"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.586">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.587">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.588">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.589"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.59">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.590">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.591">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.592">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.593"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.594">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.595">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.596">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.597"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.598">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.599">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.6">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.60">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.600">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.601"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.602">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.603">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.604">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.605"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.606">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.607">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.608">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.609"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.61">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.610">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.611">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.612">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.613"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.614">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.615">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.616">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.617"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.618">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.619">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.62">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.620">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.621"></t>
<t tx="ekr.20201128164717.622">ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20201128164717.623">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20201128164717.624">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s &lt;%s&gt; expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,s,expected,result)
</t>
<t tx="ekr.20201128164717.625"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType='X')
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20201128164717.626"># A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
</t>
<t tx="ekr.20201128164717.627">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20201128164717.628"># start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
</t>
<t tx="ekr.20201128164717.629"># targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20201128164717.63">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.630">vr = c.helpCommands.helpForMinibuffer()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.631">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.632">ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.633">ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,w=w)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20201128164717.634">w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20201128164717.635"># These tests will be important when revising config code.
</t>
<t tx="ekr.20201128164717.636"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20201128164717.637"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
</t>
<t tx="ekr.20201128164717.638">line 1.
line 2(xxx).
line 3.
</t>
<t tx="ekr.20201128164717.639">if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20201128164717.64">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.640"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20201128164717.641">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.642">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.643">u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.644">u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.645">n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
</t>
<t tx="ekr.20201128164717.646">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w, 'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste, 'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, f"oops3 expected {h} got: {p.h}"
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.647">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.648">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.649">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.65">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.650">h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
</t>
<t tx="ekr.20201128164717.651">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.652">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')

k = c.k
if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        # char, shortcut.
        g.app.gui.event_generate(c,'X','Shift+X',w)
        g.app.gui.event_generate(c,'Y','Shift+Y',w)
        g.app.gui.event_generate(c,'Z','Shift+Z',w)
        g.app.gui.event_generate(c,'\n','Return',w)
        expected = h + 'XYZ'
        assert p.h == expected, f"oops 1: expected {expected!r} got {p.h!r}"
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, f"oops 2: expected {h!r} got {p.h!r}"
    finally:
        if 1:
            c.setHeadString(p, h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.653">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.654">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.655">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
</t>
<t tx="ekr.20201128164717.656"># Print does not work: it is redirected.
g.pr('\nEnd of typing tests')
</t>
<t tx="ekr.20201128164717.657"># Print does not work: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
</t>
<t tx="ekr.20201128164717.66">firstline
last line
</t>
<t tx="ekr.20201128164717.67">first line
last line
</t>
<t tx="ekr.20201128164717.68">firstline
last line
</t>
<t tx="ekr.20201128164717.69">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.70">first line
last lin
</t>
<t tx="ekr.20201128164717.71">first line
last line
</t>
<t tx="ekr.20201128164717.72">first line
last lin
</t>
<t tx="ekr.20201128164717.73">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.74">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.75">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.76">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.77">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.78">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.79">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.8">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.80">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.81">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.82">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.83">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.84">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.85">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.86">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.87">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.88">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.89">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.9">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.90">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.91">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.92">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.93">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.95">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.96">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.97">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.98">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.99">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128165500.1">"""Convert old-style tests to new-style tests"""
g.cls()
import importlib
from leo.core import leoTest2
importlib.reload(leoTest2)

root = g.findTopLevelNode(c, 'unit-tests: leoEditCommands')
target = g.findTopLevelNode(c, 'new-tests')
if root and target:
    leoTest2.convert_leoEditCommands_tests(c, root, target)
else:
    print('Error: root and target nodes must be top-level nodes.')</t>
<t tx="ekr.20201128171127.1"></t>
<t tx="ekr.20201129132149.1"></t>
<t tx="ekr.20201130074836.1">def convert_leoEditCommands_tests(c, root, target):
    """
    Convert @test nodes to new-style tests.
    
    root:   A node containing (a copy of) tests from unitTest.leo.
    target: A node whose children will be the resulting tests.
            These nodes can then be copied to be children of a test class.
    """
    if not root or not target:
        print('Error: root and target nodes must be top-level nodes.', color='red')
        return
    # Be safe.
    if target.hasChildren():
        print('Please delete children of ', target.h, color='red')
        return
    converter = ConvertEditCommandsTests()
    count = 0
    for p in root.subtree():
        if p.h.startswith('@test') and 'runEditCommandTest' in p.b:
            converter.convert(p, target)
            count += 1
    c.redraw()
    print(f"converted {count} @test nodes", color='blue')
</t>
<t tx="ekr.20201202085332.1">def test_add_space_to_lines(self):
    """Test case for add-space-to-lines"""
    before_b = """\
first line
line 1
    line a
line b
last line
"""
    after_b = """\
first line
 line 1
     line a
 line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "4.6"),
        after_sel=("2.0", "4.7"),
        command_name="add-space-to-lines",
    )
</t>
<t tx="ekr.20201202085332.10">def test_back_to_home_at_start_of_line(self):
    """Test case for back-to-home (at start of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.100">def test_rectangle_yank(self):
    """Test case for rectangle-yank"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-yank",
    )
</t>
<t tx="ekr.20201202085332.101">def test_remove_blank_lines(self):
    """Test case for remove-blank-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "6.9"),
        command_name="remove-blank-lines",
    )
</t>
<t tx="ekr.20201202085332.102">def test_remove_space_from_lines(self):
    """Test case for remove-space-from-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line

line 1
   line a
       line b

line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "9.0"),
        command_name="remove-space-from-lines",
    )
</t>
<t tx="ekr.20201202085332.103">def test_remove_tab_from_lines(self):
    """Test case for remove-tab-from-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="remove-tab-from-lines",
    )
</t>
<t tx="ekr.20201202085332.104">def test_reverse_region(self):
    """Test case for reverse-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\

last line
line c
        line b
    line a
line 1
first line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.10", "7.10"),
        command_name="reverse-region",
    )
</t>
<t tx="ekr.20201202085332.105">def test_reverse_sort_lines(self):
    """Test case for reverse-sort-lines"""
    before_b = """\
a
d
e
z
x
"""
    after_b = """\
z
x
e
d
a
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="reverse-sort-lines",
    )
</t>
<t tx="ekr.20201202085332.106">def test_reverse_sort_lines_ignoring_case(self):
    """Test case for reverse-sort-lines-ignoring-case"""
    before_b = """\
c
A
z
X
Y
b
"""
    after_b = """\
z
Y
X
c
b
A
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.1"),
        after_sel=("1.0", "6.1"),
        command_name="reverse-sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.107">def test_sort_columns(self):
    """Test case for sort-columns"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
        line b
    line a
first line
last line
line 1
line c
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.2"),
        after_sel=("1.0", "7.0"),
        command_name="sort-columns",
    )
</t>
<t tx="ekr.20201202085332.108">def test_sort_lines(self):
    """Test case for sort-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
        line b
    line a
line 1
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.6"),
        command_name="sort-lines",
    )
</t>
<t tx="ekr.20201202085332.109">def test_sort_lines_ignoring_case(self):
    """Test case for sort-lines-ignoring-case"""
    before_b = """\
x
z
A
c
B
"""
    after_b = """\
A
B
c
x
z
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.11">def test_back_to_home_at_indentation(self):
    """Test case for back-to-home (at indentation"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "2.4"),
        after_sel=("2.0", "2.0"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.110">def test_split_line(self):
    """Test case for split-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first
 line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("2.0", "2.0"),
        command_name="split-line",
    )
</t>
<t tx="ekr.20201202085332.111">def test_start_of_line(self):
    """Test case for start-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.112">def test_start_of_line_2(self):
    """Test case for start-of-line (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.113">def test_start_of_line_extend_selection(self):
    """Test case for start-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.10"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.114">def test_start_of_line_extend_selection_2(self):
    """Test case for start-of-line-extend-selection (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.4"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.115">def test_tabify(self):
    """Test case for tabify"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="tabify",
    )
</t>
<t tx="ekr.20201202085332.116">def test_transpose_chars(self):
    """Test case for transpose-chars"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
frist line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.2", "1.2"),
        command_name="transpose-chars",
    )
</t>
<t tx="ekr.20201202085332.117">def test_transpose_lines(self):
    """Test case for transpose-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.10", "2.10"),
        command_name="transpose-lines",
    )
</t>
<t tx="ekr.20201202085332.118">def test_transpose_words(self):
    """Test case for transpose-words"""
    before_b = """\
first line
before bar2 += foo after
last line
"""
    after_b = """\
first line
before foo += bar2 after
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.11", "2.11"),
        command_name="transpose-words",
    )
</t>
<t tx="ekr.20201202085332.119">def test_untabify(self):
    """Test case for untabify"""
    before_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="untabify",
    )
</t>
<t tx="ekr.20201202085332.12">def test_back_to_home_at_end_of_line(self):
    """Test case for back-to-home (at end of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.12", "2.12"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.120">def test_upcase_region(self):
    """Test case for upcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="upcase-region",
    )
</t>
<t tx="ekr.20201202085332.121">def test_upcase_word(self):
    """Test case for upcase-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    LINE a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.7"),
        command_name="upcase-word",
    )
</t>
<t tx="ekr.20201202085332.122">def test_reformat_paragraph_list_1_of_5(self):
    """Test case for reformat-paragraph list 1 of 5"""
    before_b = """\
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.123">def test_reformat_paragraph_list_2_of_5(self):
    """Test case for reformat-paragraph list 2 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.0", "4.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.124">def test_reformat_paragraph_list_3_of_5(self):
    """Test case for reformat-paragraph list 3 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("10.0", "10.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.125">def test_reformat_paragraph_list_4_of_5(self):
    """Test case for reformat-paragraph list 4 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.126">def test_reformat_paragraph_list_5_of_5(self):
    """Test case for reformat-paragraph list 5 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("15.1", "15.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.127">def test_reformat_paragraph_new_code_1_of_8(self):
    """Test case for reformat-paragraph new code 1 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("2.0", "2.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.128">def test_reformat_paragraph_new_code_2_of_8(self):
    """Test case for reformat-paragraph new code 2 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.129">def test_reformat_paragraph_new_code_3_of_8(self):
    """Test case for reformat-paragraph new code 3 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
more docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring. more docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "4.1"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.13">def test_back_word(self):
    """Test case for back-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.183", "1.183"),
        after_sel=("1.178", "1.178"),
        command_name="back-word",
    )
</t>
<t tx="ekr.20201202085332.130">def test_reformat_paragraph_new_code_4_of_8(self):
    """Test case for reformat-paragraph new code 4 of 8"""
    before_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.131">def test_reformat_paragraph_new_code_5_of_8(self):
    """Test case for reformat-paragraph new code 5 of 8"""
    before_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.132">def test_reformat_paragraph_new_code_6_of_8(self):
    """Test case for reformat-paragraph new code 6 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.133">def test_reformat_paragraph_new_code_7_of_8(self):
    """Test case for reformat-paragraph new code 7 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.11", "2.11"),
        after_sel=("3.1", "3.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.134">def test_reformat_paragraph_new_code_8_of_8(self):
    """Test case for reformat-paragraph new code 8 of 8"""
    before_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.135">def test_reformat_paragraph_paragraph_1_of_3(self):
    """Test case for reformat-paragraph paragraph 1 of 3"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.136">def test_reformat_paragraph_paragraph_2_of_3(self):
    """Test case for reformat-paragraph paragraph 2 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("25.0", "25.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.137">def test_reformat_paragraph_paragraph_3_of_3(self):
    """Test case for reformat-paragraph paragraph 3 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("25.10", "25.10"),
        after_sel=("34.0", "34.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.138">def test_reformat_paragraph_simple_hanging_indent(self):
    """Test case for reformat-paragraph simple hanging indent"""
    before_b = """\
Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.139">def test_reformat_paragraph_simple_hanging_indent_2(self):
    """Test case for reformat-paragraph simple hanging indent 2"""
    before_b = """\
Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.14">def test_back_word_extend_selection(self):
    """Test case for back-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.342", "3.342"),
        after_sel=("3.332", "3.342"),
        command_name="back-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.140">def test_reformat_paragraph_simple_hanging_indent_3(self):
    """Test case for reformat-paragraph simple hanging indent 3"""
    before_b = """\
Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.15">def test_backward_delete_char(self):
    """Test case for backward-delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first lie
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.9", "1.9"),
        after_sel=("1.8", "1.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.16">def test_backward_delete_char__middle_of_line(self):
    """Test case for backward-delete-char  (middle of line)"""
    before_b = """\
first line
last line
"""
    after_b = """\
firstline
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.6", "1.6"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.17">def test_backward_delete_char_last_char(self):
    """Test case for backward-delete-char (last char)"""
    before_b = """\
first line
last line
"""
    after_b = """\
first line
last lin
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.8", "2.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.18">def test_backward_delete_word_no_selection(self):
    """Test case for backward-delete-word (no selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa cccc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.19">def test_backward_delete_word_selection(self):
    """Test case for backward-delete-word (selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa bbcc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.7", "1.12"),
        after_sel=("1.7", "1.7"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.2">def test_add_tab_to_lines(self):
    """Test case for add-tab-to-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
    line 1
        line a
            line b
    line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.10"),
        command_name="add-tab-to-lines",
    )
</t>
<t tx="ekr.20201202085332.20">def test_backward_kill_paragraph(self):
    """Test case for backward-kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("7.0", "7.0"),
        command_name="backward-kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.21">def test_backward_kill_sentence(self):
    """Test case for backward-kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("2.23", "2.23"),
        command_name="backward-kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.22">def test_backward_kill_word(self):
    """Test case for backward-kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.5", "3.5"),
        command_name="backward-kill-word",
    )
</t>
<t tx="ekr.20201202085332.23">def test_beginning_of_buffer(self):
    """Test case for beginning-of-buffer"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.56", "5.56"),
        after_sel=("1.0", "1.0"),
        command_name="beginning-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.24">def test_beginning_of_buffer_extend_selection(self):
    """Test case for beginning-of-buffer-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.423", "3.423"),
        after_sel=("1.0", "3.423"),
        command_name="beginning-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.25">def test_beginning_of_line(self):
    """Test case for beginning-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.0", "3.0"),
        command_name="beginning-of-line",
    )
</t>
<t tx="ekr.20201202085332.26">def test_beginning_of_line_extend_selection(self):
    """Test case for beginning-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.10", "4.10"),
        after_sel=("4.0", "4.10"),
        command_name="beginning-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.27">def test_capitalize_word(self):
    """Test case for capitalize-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    Line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="capitalize-word",
    )
</t>
<t tx="ekr.20201202085332.28">def test_center_line(self):
    """Test case for center-line"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "9.0"),
        after_sel=("3.0", "9.0"),
        command_name="center-line",
    )
</t>
<t tx="ekr.20201202085332.29">def test_center_region(self):
    """Test case for center-region"""
    before_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    after_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="center-region",
    )
</t>
<t tx="ekr.20201202085332.3">def test_back_char(self):
    """Test case for back-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.8", "3.8"),
        after_sel=("3.7", "3.7"),
        command_name="back-char",
    )
</t>
<t tx="ekr.20201202085332.30">def test_clean_lines(self):
    """Test case for clean-lines"""
    before_b = """\
# Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
"""
    after_b = """\
# Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="clean-lines",
    )
</t>
<t tx="ekr.20201202085332.31">def test_clear_selected_text(self):
    """Test case for clear-selected-text"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.4"),
        after_sel=("2.4", "2.4"),
        command_name="clear-selected-text",
    )
</t>
<t tx="ekr.20201202085332.32">def test_count_region(self):
    """Test case for count-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.8"),
        after_sel=("2.4", "4.8"),
        command_name="count-region",
    )
</t>
<t tx="ekr.20201202085332.33">def test_delete_char(self):
    """Test case for delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
firstline
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.5", "1.5"),
        command_name="delete-char",
    )
</t>
<t tx="ekr.20201202085332.34">def test_delete_indentation(self):
    """Test case for delete-indentation"""
    before_b = """\
first line
    line 1
last line
"""
    after_b = """\
first line
line 1
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.8", "2.8"),
        after_sel=("2.4", "2.4"),
        command_name="delete-indentation",
    )
</t>
<t tx="ekr.20201202085332.35">def test_delete_spaces(self):
    """Test case for delete-spaces"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("3.0", "3.0"),
        command_name="delete-spaces",
    )
</t>
<t tx="ekr.20201202085332.36">def test_do_nothing(self):
    """Test case for do-nothing"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="do-nothing",
    )
</t>
<t tx="ekr.20201202085332.37">def test_downcase_region(self):
    """Test case for downcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="downcase-region",
    )
</t>
<t tx="ekr.20201202085332.38">def test_downcase_word(self):
    """Test case for downcase-word"""
    before_b = """\
XYZZY line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
xyzzy line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.4", "1.4"),
        after_sel=("1.4", "1.4"),
        command_name="downcase-word",
    )
</t>
<t tx="ekr.20201202085332.39">def test_end_of_buffer(self):
    """Test case for end-of-buffer"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.3", "1.3"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.4">def test_back_char_extend_selection(self):
    """Test case for back-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.12", "4.12"),
        after_sel=("4.11", "4.12"),
        command_name="back-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.40">def test_end_of_buffer_extend_selection(self):
    """Test case for end-of-buffer-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "7.0"),
        command_name="end-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.41">def test_end_of_line(self):
    """Test case for end-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.10", "1.10"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.42">def test_end_of_line_2(self):
    """Test case for end-of-line 2"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("6.0", "6.0"),
        after_sel=("6.9", "6.9"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.43">def test_end_of_line_internal_blank_line(self):
    """Test case for end-of-line (internal blank line)"""
    before_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.0", "2.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.44">def test_end_of_line_blank_last_line(self):
    """Test case for end-of-line (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.45">def test_end_of_line_single_char_last_line(self):
    """Test case for end-of-line (single char last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.1", "7.1"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.46">def test_end_of_line_extend_selection(self):
    """Test case for end-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.10"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.47">def test_end_of_line_extend_selection_blank_last_line(self):
    """Test case for end-of-line-extend-selection (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.48">def test_exchange_point_mark(self):
    """Test case for exchange-point-mark"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.10"),
        after_sel=("1.0", "1.10"),
        command_name="exchange-point-mark",
    )
</t>
<t tx="ekr.20201202085332.49">def test_extend_to_line(self):
    """Test case for extend-to-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "3.3"),
        after_sel=("3.0", "3.10"),
        command_name="extend-to-line",
    )
</t>
<t tx="ekr.20201202085332.5">def test_back_paragraph(self):
    """Test case for back-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("6.7", "6.7"),
        command_name="back-paragraph",
    )
</t>
<t tx="ekr.20201202085332.50">def test_extend_to_paragraph(self):
    """Test case for extend-to-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "13.33"),
        command_name="extend-to-paragraph",
    )
</t>
<t tx="ekr.20201202085332.51">def test_extend_to_sentence(self):
    """Test case for extend-to-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("1.395", "3.142"),
        command_name="extend-to-sentence",
    )
</t>
<t tx="ekr.20201202085332.52">def test_extend_to_word(self):
    """Test case for extend-to-word"""
    before_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.12"),
        command_name="extend-to-word",
    )
</t>
<t tx="ekr.20201202085332.53">def test_finish_of_line(self):
    """Test case for finish-of-line"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.12", "3.12"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.54">def test_finish_of_line_2(self):
    """Test case for finish-of-line (2)"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.55">def test_finish_of_line_extend_selection(self):
    """Test case for finish-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.9"),
        command_name="finish-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.56">def test_fill_paragraph(self):
    """Test case for fill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.7"),
        after_sel=("10.0", " 10.0"),
        command_name="fill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.57">def test_forward_char(self):
    """Test case for forward-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.3", "1.3"),
        command_name="forward-char",
    )
</t>
<t tx="ekr.20201202085332.58">def test_forward_char_extend_selection(self):
    """Test case for forward-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("1.1", "1.2"),
        command_name="forward-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.59">def test_forward_end_word_end_of_line(self):
    """Test case for forward-end-word (end of line)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("3.4", "3.4"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.6">def test_back_paragraph_extend_selection(self):
    """Test case for back-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.5"),
        after_sel=("6.7", "9.5"),
        command_name="back-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.60">def test_forward_end_word_start_of_word(self):
    """Test case for forward-end-word (start of word)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.310", "1.310"),
        after_sel=("1.317", "1.317"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.61">def test_forward_end_word_extend_selection(self):
    """Test case for forward-end-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.20", "3.20"),
        after_sel=("3.20", "3.30"),
        command_name="forward-end-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.62">def test_forward_paragraph(self):
    """Test case for forward-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("15.0", "15.0"),
        command_name="forward-paragraph",
    )
</t>
<t tx="ekr.20201202085332.63">def test_forward_paragraph_extend_selection(self):
    """Test case for forward-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("10.0", "15.0"),
        command_name="forward-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.64">def test_forward_sentence(self):
    """Test case for forward-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.17", "3.17"),
        after_sel=("3.142", "3.142"),
        command_name="forward-sentence",
    )
</t>
<t tx="ekr.20201202085332.65">def test_forward_sentence_extend_selection(self):
    """Test case for forward-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.264", "1.264"),
        after_sel=("1.264", "1.395"),
        command_name="forward-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.66">def test_forward_word(self):
    """Test case for forward-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.261", "1.261"),
        after_sel=("1.272", "1.272"),
        command_name="forward-word",
    )
</t>
<t tx="ekr.20201202085332.67">def test_forward_word_extend_selection(self):
    """Test case for forward-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("1.395", "3.4"),
        command_name="forward-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.68">def test_indent_relative(self):
    """Test case for indent-relative"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
        line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.0", "5.0"),
        after_sel=("5.8", "5.8"),
        command_name="indent-relative",
    )
</t>
<t tx="ekr.20201202085332.69">def test_indent_rigidly(self):
    """Test case for indent-rigidly"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
	line 1
	    line a
	        line b
	line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.0"),
        after_sel=("2.0", "5.1"),
        command_name="indent-rigidly",
    )
</t>
<t tx="ekr.20201202085332.7">def test_back_sentence(self):
    """Test case for back-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.169", "3.169"),
        after_sel=("3.143", "3.143"),
        command_name="back-sentence",
    )
</t>
<t tx="ekr.20201202085332.70">def test_indent_to_comment_column(self):
    """Test case for indent-to-comment-column"""
    before_b = """\
first line
line b
last line
"""
    after_b = """\
first line
    line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="indent-to-comment-column",
    )
</t>
<t tx="ekr.20201202085332.71">def test_insert_newline(self):
    """Test case for insert-newline"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first li
ne
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.8", "1.8"),
        after_sel=("2.0", "2.0"),
        command_name="insert-newline",
    )
</t>
<t tx="ekr.20201202085332.72">def test_insert_parentheses(self):
    """Test case for insert-parentheses"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first() line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.6", "1.6"),
        command_name="insert-parentheses",
    )
</t>
<t tx="ekr.20201202085332.73">def test_kill_paragraph(self):
    """Test case for kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "8.0"),
        command_name="kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.74">def test_kill_sentence(self):
    """Test case for kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.27", "1.27"),
        command_name="kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.75">def test_kill_word(self):
    """Test case for kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.7", "2.7"),
        command_name="kill-word",
    )
</t>
<t tx="ekr.20201202085332.76">def test_kill_line_end_body_text(self):
    """Test case for kill-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.77">def test_kill_line_end_line_text(self):
    """Test case for kill-line end-line-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2

"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.78">def test_kill_line_start_line(self):
    """Test case for kill-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.79">def test_kill_line_start_blank_line(self):
    """Test case for kill-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.8">def test_back_sentence_extend_selection(self):
    """Test case for back-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.208", "3.208"),
        after_sel=("3.143", "3.208"),
        command_name="back-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.80">def test_kill_to_end_of_line_end_body_text(self):
    """Test case for kill-to-end-of-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.81">def test_kill_to_end_of_line_end_line(self):
    """Test case for kill-to-end-of-line end-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.6", "2.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.82">def test_kill_to_end_of_line_after_last_visible_char(self):
    """Test case for kill-to-end-of-line after last visible char"""
    before_b = """\
line 1
# The next line contains two trailing blanks.
line 3  
line 4
"""
    after_b = """\
line 1
# The next line contains two trailing blanks.
line 3line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.83">def test_kill_to_end_of_line_start_line(self):
    """Test case for kill-to-end-of-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.84">def test_kill_to_end_of_line_start_blank_line(self):
    """Test case for kill-to-end-of-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.85">def test_kill_to_end_of_line_middle_line(self):
    """Test case for kill-to-end-of-line middle-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
li
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.2", "2.2"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.86">def test_move_lines_down(self):
    """Test case for move-lines-down"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line c
    line a
        line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "4.3"),
        after_sel=("4.3", "5.3"),
        command_name="move-lines-down",
    )
</t>
<t tx="ekr.20201202085332.87">def test_move_lines_up(self):
    """Test case for move-lines-up"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.2", "1.2"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.88">def test_move_lines_up_into_docstring(self):
    """Test case for move-lines-up (into docstring)"""
    before_b = '''\
@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
'''
    after_b = '''\
@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
'''
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.1", "7.1"),
        after_sel=("6.1", "6.1"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.89">def test_move_past_close(self):
    """Test case for move-past-close"""
    before_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.12", "1.12"),
        command_name="move-past-close",
    )
</t>
<t tx="ekr.20201202085332.9">def test_back_to_indentation(self):
    """Test case for back-to-indentation"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.13", "4.13"),
        after_sel=("4.8", "4.8"),
        command_name="back-to-indentation",
    )
</t>
<t tx="ekr.20201202085332.90">def test_move_past_close_extend_selection(self):
    """Test case for move-past-close-extend-selection"""
    before_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.11"),
        command_name="move-past-close-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.91">def test_newline_and_indent(self):
    """Test case for newline-and-indent"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("3.4", "3.4"),
        command_name="newline-and-indent",
    )
</t>
<t tx="ekr.20201202085332.92">def test_next_line(self):
    """Test case for next-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("2.0", "2.0"),
        command_name="next-line",
    )
</t>
<t tx="ekr.20201202085332.93">def test_previous_line(self):
    """Test case for previous-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("2.0", "2.0"),
        command_name="previous-line",
    )
</t>
<t tx="ekr.20201202085332.94">def test_rectangle_clear(self):
    """Test case for rectangle-clear"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-clear",
    )
</t>
<t tx="ekr.20201202085332.95">def test_rectangle_close(self):
    """Test case for rectangle-close"""
    before_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-close",
    )
</t>
<t tx="ekr.20201202085332.96">def test_rectangle_delete(self):
    """Test case for rectangle-delete"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-delete",
    )
</t>
<t tx="ekr.20201202085332.97">def test_rectangle_kill(self):
    """Test case for rectangle-kill"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("5.3", "5.3"),
        command_name="rectangle-kill",
    )
</t>
<t tx="ekr.20201202085332.98">def test_rectangle_open(self):
    """Test case for rectangle-open"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-open",
    )
</t>
<t tx="ekr.20201202085332.99">def test_rectangle_string(self):
    """Test case for rectangle-string"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.8"),
        command_name="rectangle-string",
    )
</t>
<t tx="ekr.20201202144529.1"></t>
<t tx="ekr.20201203045146.1">import os
g.cls()
cwd = os.getcwd()
os.system('leo-unittest')
os.chdir(cwd)</t>
<t tx="ekr.20201203114411.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1766

@language python
@nosearch
</t>
<t tx="ekr.20201204172235.1">leo_cursor_width = 0

leo_vim_mode = None

def paintEvent(self, event):
    """
    LeoQTextBrowser.paintEvent.
    
    New in Leo 6.4: Draw a box around the cursor in command mode.
                    This is as close as possible to vim's look.
    """
    c, vc, w = self.leo_c, self.leo_c.vimCommands, self
    #
    # First, call the base class paintEvent.
    QtWidgets.QTextBrowser.paintEvent(self, event)
    
    def set_cursor_width(width):
        """Set the cursor width, but only if necessary."""
        if self.leo_cursor_width != width:
            self.leo_cursor_width = width
            w.setCursorWidth(width)
    
    #
    # Are we in vim mode?
    if self.leo_vim_mode is None:
        self.leo_vim_mode = c.config.getBool('vim-mode', default=False)
    #
    # Are we in command mode?
    if self.leo_vim_mode:
        in_command = vc and vc.state == 'normal'  # vim mode.
    else:
        in_command = c.k.unboundKeyAction == 'command'  # vim emulation.
    #
    # Draw the box only in command mode, when w is the body pane, with focus.
    if (
        not in_command
        or w != c.frame.body.widget
        or w != g.app.gui.get_focus()
    ):
        set_cursor_width(c.config.getInt('qt-cursor-width') or 1)
        return
    #
    # Set the width of the cursor.
    font = w.currentFont()
    cursor_width = QtGui.QFontMetrics(font).averageCharWidth()
    set_cursor_width(cursor_width)
    #
    # Draw a box around the cursor.
    qp = QtGui.QPainter()
    qp.begin(self.viewport())
    qp.drawRect(w.cursorRect())
    qp.end()
</t>
<t tx="ekr.20201208114843.1"># No longer needed. Use the git-diff-pr command.
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request()
</t>
<t tx="ekr.20201222095250.1">g.cls()
import glob
import os
theme_dir = os.path.join(g.app.loadDir, '..', 'themes')
assert os.path.exists(theme_dir), repr(theme_dir)
paths = glob.glob(f"{theme_dir}{os.sep}*.leo")

def clean(s):
    return s.strip().replace('-','').replace('_','').replace(' ','')
    
for path in paths:
    d = {}
    c = g.createHiddenCommander(path)
    sfn = c.shortFileName()
    if sfn == 'old_themes.leo':
        continue
    print('checking ', sfn)
    for p in c.all_unique_positions():
        h = clean(p.h)
        if h.startswith('@'):
            if h in d:
                print(f"  {sfn:20}: duplicate {h}")
            else:
                d [h] = True
print('done')</t>
<t tx="ekr.20210108053422.1">def batch_change(self, root, replacements, settings=None):
    """
    Support batch change scripts.
    
    replacement: a list of tuples (find_string, change_string).
    settings: a dict or g.Bunch containing find/change settings.
    
    Example:
        
        h = '@file src/ekr/coreFind.py'
        root = g.findNodeAnywhere(c, h)
        assert root
        replacements = (
            ('clone_find_all', 'do_clone_find_all'),
            ('clone_find_all_flattened', 'do_clone_find_all_flattened'),
        )
        settings = dict(suboutline_only=True)
        count = c.findCommands.batch_change(c, root, replacements, settings)
        if count:
            c.save()
    """
    try:
        self._init_from_dict(settings or {})
        count = 0
        for find, change in replacements:
            count += self._batch_change_helper(root, find, change)
        return count
    except Exception:
        g.es_exception()
        return 0
</t>
<t tx="ekr.20210108070948.1">def _batch_change_helper(self, p, find_text, change_text):

    c, p1, u = self.c, p.copy(), self.c.undoer
    undoType = 'Batch Change All'
    # Check...
    if not find_text:  # pragma: no cover
        return 0
    if not self.search_headline and not self.search_body:
        return 0  # pragma: no cover
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:  # pragma: no cover
            return 0
    # Init...
    self.find_text = find_text
    self.change_text = self.replace_back_slashes(change_text)
    if self.node_only:
        positions = [p1]
    elif self.suboutline_only:
        positions = p1.self_and_subtree()
    else:
        positions = c.all_unique_positions()
    # Init the work widget.
    s = p.h if self.in_headline else p.b
    self.work_s = s
    self.work_sel = (0, 0, 0)
    # The main loop.
    u.beforeChangeGroup(p1, undoType)
    count = 0
    for p in positions:
        count_h, count_b = 0, 0
        undoData = u.beforeChangeNodeContents(p)
        if self.search_headline:
            count_h, new_h = self._change_all_search_and_replace(p.h)
            if count_h:
                count += count_h
                p.h = new_h
        if self.search_body:
            count_b, new_b = self._change_all_search_and_replace(p.b)
            if count_b:
                count += count_b
                p.b = new_b
        if count_h or count_b:
            u.afterChangeNodeContents(p1, 'Replace All', undoData)
    u.afterChangeGroup(p1, undoType, reportFlag=True)
    if not g.unitTesting:  # pragma: no cover
        print(f"{count:3}: {find_text:&gt;30} =&gt; {change_text}")
    return count
</t>
<t tx="ekr.20210108083003.1">def _init_from_dict(self, settings):
    """Initialize ivars from settings (a dict or g.Bunch)."""
    # The valid ivars and reasonable defaults.
    valid = dict(
        ignore_case=False,
        node_only=False,
        pattern_match=False,
        search_body=True,
        search_headline=True,
        suboutline_only=False,  # Seems safest.  # Was True !!!
        whole_word=True,
    )
    # Set ivars to reasonable defaults.
    for ivar in valid:
        setattr(self, ivar, valid.get(ivar))
    # Override ivars from settings.
    errors = 0
    for ivar in settings.keys():
        if ivar in valid:
            val = settings.get(ivar)
            if val in (True, False):
                setattr(self, ivar, val)
            else:  # pragma: no cover
                g.trace("bad value: {ivar!r} = {val!r}")
                errors += 1
        else:  # pragma: no cover
            g.trace(f"ignoring {ivar!r} setting")
            errors += 1
    if errors:  # pragma: no cover
        g.printObj(sorted(valid.keys()), tag='valid keys')
</t>
<t tx="ekr.20210110073117.10">def _cfa_find_next_match(self, p):
    """
    Find the next batch match at p.
    """
    # Called only from unit tests.
    table = []
    if self.search_headline:
        table.append(p.h)
    if self.search_body:
        table.append(p.b)
    for s in table:
        self.reverse = False
        pos, newpos = self.inner_search_helper(s, 0, len(s), self.find_text)
        if pos != -1:
            return True
    return False
</t>
<t tx="ekr.20210110073117.11"># A stand-alone method for unit tests.
def do_clone_find_tag(self, tag):
    """
    Do the clone-all-find commands from settings.
    Return (len(clones), found) for unit tests.
    """
    c, u = self.c, self.c.undoer
    tc = getattr(c, 'theTagController', None)
    if not tc:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print('nodetags not active')
        return 0, c.p
    clones = tc.get_tagged_nodes(tag)
    if not clones:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print(f"tag not found: {tag}")
        tc.show_all_tags()
        return 0, c.p
    undoData = u.beforeInsertNode(c.p)
    found = self._create_clone_tag_nodes(clones)
    u.afterInsertNode(found, 'Clone Find Tag', undoData)
    assert c.positionExists(found, trace=True), found
    c.setChanged()
    c.selectPosition(found)
    c.redraw()
    return len(clones), found
</t>
<t tx="ekr.20210110073117.12">def _create_clone_tag_nodes(self, clones):
    """
    Create a "Found Tag" node as the last node of the outline.
    Clone all positions in the clones set as children of found.
    """
    c, p = self.c, self.c.p
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = f"Found Tag: {self.find_text}"
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkCopiedAsNthChild(found, n)
    return found
</t>
<t tx="ekr.20210110073117.23">def replace_all_helper(self, s):
    """
    Search s for self.find_text and replace with self.change_text.
    
    Return (found, new text)
    """
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:
        return False, None
    #
    # Order matters: regex matches ignore whole-word.
    if self.pattern_match:
        return self.batch_regex_replace(s)
    if self.whole_word:
        return self.batch_word_replace(s)
    return self.batch_plain_replace(s)
</t>
<t tx="ekr.20210110073117.24">def batch_plain_replace(self, s):
    """
    Perform all plain find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0 &amp; change.
        count += 1
        result.append(s0[prev_i:i])
        result.append(change)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20210110073117.25">def batch_regex_replace(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.make_regex_subs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20210110073117.26">def batch_word_replace(self, s):
    """
    Perform all whole word find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0, change &amp; find0.
        result.append(s0[prev_i:i])
        if g.match_word(s, i, find):
            count += 1
            result.append(change)
        else:
            result.append(find0)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20210110073117.31">def check_args(self, tag):
    """Check the user arguments to a command."""
    if not self.search_headline and not self.search_body:
        if not g.unitTesting:
            g.es_print("not searching headline or body")  # pragma: no cover (skip)
        return False
    if not self.find_text:
        if not g.unitTesting:
            g.es_print(f"{tag}: empty find pattern")  # pragma: no cover (skip)
        return False
    return True
</t>
<t tx="ekr.20210110073117.32">def compile_pattern(self):
    """Precompile the regexp pattern if necessary."""
    try:  # Precompile the regexp.
        # pylint: disable=no-member
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        # Escape the search text.
        # Ignore the whole_word option.
        s = self.find_text
        # A bad idea: insert \b automatically.
            # b, s = '\\b', self.find_text
            # if self.whole_word:
                # if not s.startswith(b): s = b + s
                # if not s.endswith(b): s = s + b
        self.re_obj = re.compile(s, flags)
        return True
    except Exception:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.warning('invalid regular expression:', self.find_text)
        return False
</t>
<t tx="ekr.20210110073117.33">def compute_result_status(self, find_all_flag=False):  # pragma: no cover (cmd)
    """Return the status to be shown in the status line after a find command completes."""
    # Too similar to another method...
    status = []
    table = (
        ('whole_word', 'Word'),
        ('ignore_case', 'Ignore Case'),
        ('pattern_match', 'Regex'),
        ('suboutline_only', '[Outline Only]'),
        ('node_only', '[Node Only]'),
        ('search_headline', 'Head'),
        ('search_body', 'Body'),
    )
    for ivar, val in table:
        if getattr(self, ivar):
            status.append(val)
    return f" ({', '.join(status)})" if status else ''
</t>
<t tx="ekr.20210110073117.34">def _cfa_create_nodes(self, clones, flattened):
    """
    Create a "Found" node as the last node of the outline.
    Clone all positions in the clones set a children of found.
    """
    c = self.c
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = f"Found:{self.find_text}"
    status = self.compute_result_status(find_all_flag=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    flat = 'flattened, ' if flattened else ''
    found.b = f"@nosearch\n\n# {flat}{status}\n\n# found {len(clones)} nodes"
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkCopiedAsNthChild(found, n)
    # Sort the clones in place, without undo.
    found.v.children.sort(key=lambda v: v.h.lower())
    return found
</t>
<t tx="ekr.20210110073117.4">def init_ivars_from_settings(self, settings):
    """
    Initialize all ivars from settings, including required defaults.
    
    This should be called from the do_ methods as follows:
        
        self.init_ivars_from_settings(settings)
        if not self.check_args('find-next'):
            return &lt;appropriate error indication&gt;
    """
    #
    # Init required defaults.
    self.reverse = False
    #
    # Init find/change strings.
    self.change_text = settings.change_text
    self.find_text = settings.find_text
    #
    # Init find options.
    self.ignore_case = settings.ignore_case
    self.mark_changes = settings.mark_changes
    self.mark_finds = settings.mark_finds
    self.node_only = settings.node_only
    self.pattern_match = settings.pattern_match
    self.search_body = settings.search_body
    self.search_headline = settings.search_headline
    self.suboutline_only = settings.suboutline_only
    self.whole_word = settings.whole_word
    # self.wrapping = settings.wrapping
</t>
<t tx="ekr.20210110073117.43">def inner_search_helper(self, s, i, j, pattern):
    """
    Dispatch the proper search method based on settings.
    """
    backwards = self.reverse
    nocase = self.ignore_case
    regexp = self.pattern_match
    word = self.whole_word
    if backwards:
        i, j = j, i
    if not s[i:j] or not pattern:
        return -1, -1
    if regexp:
        pos, newpos = self._inner_search_regex(s, i, j, pattern, backwards, nocase)
    elif backwards:
        pos, newpos = self._inner_search_backward(s, i, j, pattern, nocase, word)
    else:
        pos, newpos = self._inner_search_plain(s, i, j, pattern, nocase, word)
    return pos, newpos
</t>
<t tx="ekr.20210110073117.44">def _inner_search_backward(self, s, i, j, pattern, nocase, word):
    """
    rfind(sub [,start [,end]])

    Return the highest index in the string where substring sub is found,
    such that sub is contained within s[start,end].
    
    Optional arguments start and end are interpreted as in slice notation.

    Return (-1, -1) on failure.
    """
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
    pattern = self.replace_back_slashes(pattern)
    n = len(pattern)
    # Put the indices in range.  Indices can get out of range
    # because the search code strips '\r' characters when searching @edit nodes.
    i = max(0, i)
    j = min(len(s), j)
    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        return -1, -1
    if word:
        while 1:
            k = s.rfind(pattern, i, j)
            if k == -1:
                break
            if self._inner_search_match_word(s, k, pattern):
                return k, k + n
            j = max(0, k - 1)
        return -1, -1
    k = s.rfind(pattern, i, j)
    if k == -1:
        return -1, -1
    return k, k + n
</t>
<t tx="ekr.20210110073117.45">def _inner_search_match_word(self, s, i, pattern):
    """Do a whole-word search."""
    pattern = self.replace_back_slashes(pattern)
    if not s or not pattern or not g.match(s, i, pattern):
        return False
    pat1, pat2 = pattern[0], pattern[-1]
    n = len(pattern)
    ch1 = s[i - 1] if 0 &lt;= i - 1 &lt; len(s) else '.'
    ch2 = s[i + n] if 0 &lt;= i + n &lt; len(s) else '.'
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    return not inWord
</t>
<t tx="ekr.20210110073117.46">def _inner_search_plain(self, s, i, j, pattern, nocase, word):
    """Do a plain search."""
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
    pattern = self.replace_back_slashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern, i, j)
            if k == -1:
                break
            if self._inner_search_match_word(s, k, pattern):
                return k, k + n
            i = k + n
        return -1, -1
    k = s.find(pattern, i, j)
    if k == -1:
        return -1, -1
    return k, k + n
</t>
<t tx="ekr.20210110073117.47">def _inner_search_regex(self, s, i, j, pattern, backwards, nocase):
    """Called from inner_search_helper"""
    re_obj = self.re_obj  # Use the pre-compiled object
    if not re_obj:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.trace('can not happen: no re_obj')
        return -1, -1
    if backwards:
        # Scan to the last match using search here.
        i, last_mo = 0, None
        while i &lt; len(s):
            mo = re_obj.search(s, i, j)
            if not mo:
                break
            i += 1
            last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s, i, j)
    if mo:
        self.match_obj = mo
        return mo.start(), mo.end()
    self.match_obj = None
    return -1, -1
    #
    # The following is mysterious.
    # Félix, please don't bother with it.
    # I'll re-enable it if it ever makes sense to me :-)
    ###
        # # if mo and mo.group(0) != 'def': g.trace(i, mo, mo.start(), mo.end())
        # while mo and 0 &lt;= i &lt;= len(s):
            # if mo.start() == mo.end():
                # if backwards:
                    # # Search backward using match instead of search.
                    # i -= 1
                    # while 0 &lt;= i &lt; len(s):
                        # mo = re_obj.match(s, i, j)
                        # if mo: break
                        # i -= 1
                # else:
                    # i += 1
                    # mo = re_obj.search(s, i, j)
            # else:
                # self.match_obj = mo
                # return mo.start(), mo.end()
        # self.match_obj = None
        # return -1, -1
</t>
<t tx="ekr.20210110073117.48">def make_regex_subs(self, change_text, groups):
    """
    Substitute group[i-1] for \\i strings in change_text.
    
    Groups is a tuple of strings, one for every matched group.
    """

    # g.printObj(list(groups), tag=f"groups in {change_text!r}")

    def repl(match_object):
        """re.sub calls this function once per group."""
        # # 1494...
        n = int(match_object.group(1)) - 1
        if 0 &lt;= n &lt; len(groups):
            # Executed only if the change text contains groups that match.
            return (
                groups[n].
                    replace(r'\b', r'\\b').
                    replace(r'\f', r'\\f').
                    replace(r'\n', r'\\n').
                    replace(r'\r', r'\\r').
                    replace(r'\t', r'\\t').
                    replace(r'\v', r'\\v'))
        # No replacement.
        return match_object.group(0)

    result = re.sub(r'\\([0-9])', repl, change_text)
    return result
</t>
<t tx="ekr.20210110073117.49">def replace_back_slashes(self, s):
    """Carefully replace backslashes in a search pattern."""
    # This is NOT the same as:
    #
    #   s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    #
    # because there is no rescanning.
    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i + 1]
            if ch == '\\':
                s = s[:i] + s[i + 1 :]  # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i + 2 :]  # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i + 2 :]  # replace \t by a tab
            else:
                i += 1  # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20210110073117.5">def init_settings(self, settings):
    """Initialize all user settings."""

</t>
<t tx="ekr.20210110073117.6">def default_settings(self):
    """Return a dict representing all default settings."""
    c = self.c
    return g.Bunch(
        # State...
        in_headline=False,
        p=c.rootPosition(),
        # Find/change strings...
        find_text='',
        change_text='',
        # Find options...
        ignore_case=False,
        mark_changes=False,
        mark_finds=False,
        node_only=False,
        pattern_match=False,
        reverse=False,
        search_body=True,
        search_headline=True,
        suboutline_only=False,
        whole_word=False,
        wrapping=False,
    )
</t>
<t tx="ekr.20210110073117.9">def _cf_helper(self, settings, flatten):  # Caller has  checked the settings.
    """
    The common part of the clone-find commands.
    
    Return the number of found nodes.
    """
    c, u = self.c, self.c.undoer
    if self.pattern_match:
        ok = self.compile_pattern()
        if not ok: return 0
    if self.suboutline_only:
        p = c.p
        after = p.nodeAfterTree()
    else:
        p = c.rootPosition()
        after = None
    count, found = 0, None
    clones, skip = [], set()
    while p and p != after:
        progress = p.copy()
        if p.v in skip:  # pragma: no cover (minor)
            p.moveToThreadNext()
        elif g.inAtNosearch(p):
            p.moveToNodeAfterTree()
        elif self._cfa_find_next_match(p):
            count += 1
            if p not in clones:
                clones.append(p.copy())
            if flatten:
                p.moveToThreadNext()
            else:
                # Don't look at the node or it's descendants.
                for p2 in p.self_and_subtree(copy=False):
                    skip.add(p2.v)
                p.moveToNodeAfterTree()
        else:  # pragma: no cover (minor)
            p.moveToThreadNext()
        assert p != progress
    self.ftm.set_radio_button('entire-outline')
    # suboutline-only is a one-shot for batch commands.
    self.node_only = self.suboutline_only = False
    self.root = None
    if clones:
        undoData = u.beforeInsertNode(c.p)
        found = self._cfa_create_nodes(clones, flattened=False)
        u.afterInsertNode(found, 'Clone Find All', undoData)
        assert c.positionExists(found, trace=True), found
        c.setChanged()
        c.selectPosition(found)
    g.es("found", count, "matches for", self.find_text)
    return count  # Might be useful for the gui update.
</t>
<t tx="ekr.20210110092457.1">@language python
@nosearch
</t>
<t tx="ekr.20210110092457.5">g.cls()
import os
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
# os.system('py-cov-find')
command = r'pytest --cov-report html --cov-report term-missing --cov leo.core.leoFind leo\core\leoFind.py'
os.system(command)
g.es_print('done')</t>
<t tx="ekr.20210110092457.6">import os
# os.system('moz htmlcov/leo_core_leoFind_py.html')
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
os.system('moz htmlcov/leo_core_leoFind_py.html')</t>
<t tx="ekr.20210110092457.7">g.cls()
import os
os.system('python -m unittest leoFind.py')
g.es_print('done')</t>
<t tx="ekr.20210111082524.1">def init_vim_search(self, pattern):  # pragma: no cover (cmd)
    """Initialize searches in vim mode."""
    c = self.c
    if c.vim_mode and c.vimCommands:
        c.vimCommands.update_dot_before_search(
            find_pattern=pattern,
            change_pattern=None)  # A flag.
</t>
<t tx="ekr.20210112044303.1">@cmd('re-search-backward')
def interactive_re_search_backward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, but with regex and in reverse."""
    # Set flags for show_find_options.
    self.reverse = True
    self.pattern_match = True
    self.show_find_options()
    # Set flags for do_find_next().
    self.request_reverse = True
    self.request_pattern_match = True
    # Go.
    self.start_state_machine(event,
        prefix='Regexp Search Backward:',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )

</t>
<t tx="ekr.20210112050845.1">@cmd('word-search')
@cmd('word-search-forward')
def word_search_forward(self, event):  # pragma: no cover (interactive)
    """Same as start-search, with whole_word setting."""
    # Set flag for show_find_options.
    self.whole_word = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_whole_world = True
    # Go.
    self.start_state_machine(event,
        prefix='Word Search: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20210112192011.1"></t>
<t tx="ekr.20210112192427.1"></t>
<t tx="ekr.20210113054702.1">import os
print(f"\nos.curdir: {os.path.abspath(os.curdir)}")</t>
<t tx="ekr.20210114094846.1"># A stand-alone method for unit testing.
def do_clone_find_all(self, settings):
    """
    Do the clone-all-find commands from settings.

    Return the count of found nodes.
    
    This is a stand-alone method for unit testing.
    """
    self.init_ivars_from_settings(settings)
    if not self.check_args('clone-find-all'):
        return 0
    return self._cf_helper(settings, flatten=False)
</t>
<t tx="ekr.20210114094944.1"># A stand-alone method for unit testing.
def do_clone_find_all_flattened(self, settings):
    """
    Do the clone-find-all-flattened command from the settings.
    
    Return the count of found nodes.
    
    This is a stand-alone method for unit testing.
    """
    self.init_ivars_from_settings(settings)
    if self.check_args('clone-find-all-flattened'):
        return self._cf_helper(settings, flatten=True)
    return 0
</t>
<t tx="ekr.20210114100105.1"># A stand-alone method for unit testing.
def do_change_then_find(self, settings):
    """
    Do the change-then-find command from settings.
    
    This is a stand-alone method for unit testing.
    """
    p = self.c.p
    self.init_ivars_from_settings(settings)
    if not self.check_args('change-then-find'):
        return False
    if self.change_selection(p):
        self.do_find_next(settings)
    return True

</t>
<t tx="ekr.20210114202757.1">def _compute_find_def_settings(self, find_pattern):

    settings = self.default_settings()
    table = (
        ('change_text', ''),
        ('find_text', find_pattern),
        ('ignore_case', False),
        ('pattern_match', False),
        ('reverse', False),
        ('search_body', True),
        ('search_headline', False),
        ('whole_word', True),
    )
    for attr, val in table:
        # Guard against renamings &amp; misspellings.
        assert hasattr(self, attr), attr
        assert attr in settings.__dict__, attr
        # Set the values.
        setattr(self, attr, val)
        settings[attr] = val
    return settings
</t>
<t tx="ekr.20210117143611.1">def start_search1(self, event=None):  # pragma: no cover
    """Common handler for use by vim commands and other find commands."""
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    find_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    self.update_find_list(find_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()  # Required.
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    # Do the command!
    self.do_find_next(settings)  # Handles reverse.
</t>
<t tx="ekr.20210117143614.1">def start_search_escape1(self, event=None):  # pragma: no cover
    """
    Common escape handler for use by find commands.
    
    Prompt for a change pattern.
    """
    k = self.k
    self._sString = find_pattern = k.arg
    # Settings.
    k.getArgEscapeFlag = False
    self.ftm.set_find_text(find_pattern)
    self.update_find_list(find_pattern)
    self.find_text = find_pattern
    self.change_text = self.ftm.get_change_text()
    # Gui...
    regex = ' Regex' if self.pattern_match else ''
    backward = ' Backward' if self.reverse else ''
    prompt = f"Replace{regex}{backward}: {find_pattern} With: "
    k.setLabelBlue(prompt)
    self.add_change_string_to_label()
    k.getNextArg(self._start_search_escape2)

</t>
<t tx="ekr.20210117143615.1">def _start_search_escape2(self, event):  # pragma: no cover
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Compute settings...
    find_pattern = self._sString
    change_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.update_change_list(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()  # Required
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_find_next(settings)
</t>
<t tx="ekr.20210118003803.1">@cmd('find-var')
def find_var(self, event=None):  # pragma: no cover (cmd)
    """Find the var under the cursor."""
    ftm, p = self.ftm, self.c.p
    # Check...
    word = self._compute_find_def_word(event)
    if not word:
        return
    # Settings...
    self.find_pattern = find_pattern = word + ' ='
    ftm.set_find_text(find_pattern)
    self._save_before_find_def(p)  # Save previous settings.
    self.init_vim_search(find_pattern)
    self.update_change_list(self.change_text)  # Optional. An edge case.
    settings = self._compute_find_def_settings(find_pattern)
    # Do the command!
    self.do_find_var(settings, word)

def do_find_var(self, settings, word):
    """A standalone helper for unit tests."""
    return self._fd_helper(settings, word, def_flag=False, strict=False)
</t>
<t tx="ekr.20210118013157.1">"""
Convert defs in LeoFind to pep8 names.
- Don't change defs containing underscores.
- Check for existing target.
"""
g.cls()
import re
h = 'class LeoFind (LeoFind.py)'
root = g.findNodeAnywhere(c, h)
@others
if root:
    main(root)
else:
    print('not found:', root)</t>
<t tx="ekr.20210118013807.1">def main(root):
    pattern = re.compile(r'^def\s+(\w+)', re.MULTILINE)
    for pass_n in (0, 1):
        n = 0
        for p in root.subtree():
            for m in re.finditer(pattern, p.b):
                target = m.group(0)
                old_func = m.group(1)
                if '_' in target:
                    continue
                if target.islower():
                    continue
                if old_func == 'finishCreate':  # Special case.
                    return
                new_func = new_name(old_func)
                if new_func == old_func:
                    continue
                if pass_n == 0:
                    if exists(new_func, root):
                        g.trace(f"already exists: {old_func} {new_func}")
                        g.trace('aborting')
                        return
                else:
                    n += 1
                    convert(old_func, new_func, root)
    g.trace(f"converted {n} function names")
    c.redraw()
            </t>
<t tx="ekr.20210118020530.1">def new_name(s):
    """Return the new name of s."""
    assert ' ' not in s
    # Convert s to underscore style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    return ''.join(result).replace('i_search', 'isearch')
</t>
<t tx="ekr.20210118021337.1">def exists(s, root):
    """Return True if s exists in any of root's nodes."""
    for p in root.self_and_subtree():
        if s in p.b:
            return True
    return False</t>
<t tx="ekr.20210118024739.1">def convert(old_func, new_func, root):
    print(f"{old_func} =&gt; {new_func}\n")
    for p in root.subtree():
        pattern = rf"\b{old_func}\b"
        p.h = re.sub(pattern, new_func, p.h)
        p.b = re.sub(pattern, new_func, p.b)
        # g.printObj(g.splitLines(s2), tag='p.h')
    print('')</t>
<t tx="ekr.20210202110128.29">class LeoServer:
    """Leo Server Controller"""
    @others
</t>
<t tx="ekr.20210202110128.30">def __init__(self, testing=False):

    import leo.core.leoApp as leoApp
    import leo.core.leoBridge as leoBridge
    import leo.core.leoExternalFiles as leoExternalFiles
    global g
    t1 = time.process_time()
    #
    # Init ivars first.
    self.c = None  # Currently Selected Commander.
    self.dummy_c = None  # Set below, after we set g.
    self.action = None
    self.bad_commands_list = []  # Set below.
    self.config = None
    self.current_id = 0  # Id of action being processed.
    self.log_flag = False  # set by "log" key
    #
    # Start the bridge.
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=False,   # True: attempt to load plugins.
        readSettings=False,  # True: read standard settings files.
        silent=True,         # True: don't print signon messages.
        verbose=False,       # True: prints messages that would be sent to the log pane.
    )
    self.g = g = self.bridge.globals()
    self.dummy_c = g.app.newCommander(fileName=None)  # To inspect commands
    self.bad_commands_list = self._bad_commands(self.dummy_c)
    #
    # Complete the initialization, as in LeoApp.initApp.
    g.app.idleTimeManager = leoApp.IdleTimeManager()
    g.app.idleTimeManager.start()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController(None)
    t2 = time.process_time()
    print(f"LeoServer: init leoBridge in {t2-t1:4.2} sec.")
</t>
<t tx="ekr.20210202110128.51">def _es(self, s):  # pragma: no cover (tested in client).
    """
    Send a response that does not correspond to a request.
    
    The response *must* have an "async" key, but *not* an "id" key.
    """
    tag = '_es'
    message = g.toUnicode(s)
    package = {"async": "", "s": message}
    response = json.dumps(package, separators=(',', ':'))
    if self.loop:
        self.loop.create_task(self._async_output(response))
    else:
        print(f"{tag}: Error loop not ready {message}")
</t>
<t tx="ekr.20210202110128.52">def _init_connection(self, web_socket):  # pragma: no cover (tested in client).
    """Begin the connection."""
    self.web_socket = web_socket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="ekr.20210202110128.54">def _do_message(self, d):
    """
    Handle d, a python dict representing the incoming request.
    d must have at least the following keys:
    
    - "id": A positive integer.
    - "action": A string, which is either:
        - The name of public method of this class.
        - "execute-leo-command".
          d["package"]["leo-command-name"] should be the name of a Leo command.
    
    Return a dict, created by _make_response, containing least these keys:

    - "id":         Same as the incoming id.
    - "action":     Same as the incoming action.
    - "commander":  A dict describing self.c.
    - "node":       None, or an archived position describing self.c.p.
    """
    tag = '_do_message'
    # Require "id" and "action" keys. The "package" key is optional.
    id_ = d.get("id")
    if id_ is None:  # pragma: no cover
        raise ServerError(f"{tag}: no id")
    action = d.get("action")
    if action is None:  # pragma: no cover
        raise ServerError("f{tag}: no action")
    package = d.get('package', {})
    # Set log flag.
    self.log_flag = package.get("log")
    # Set the current_id and action ivars for _make_response.
    self.current_id = id_
    self.action = action
    # Execute the requested action.
    if action == "execute-leo-command":
        func = self._do_leo_command
    else:
        func = self._do_server_command
    result = func(action, package)
    if result is None:  # pragma: no cover
        raise ServerError(f"{tag}: no response: {action!r}")
    return result
</t>
<t tx="ekr.20210202110128.55">def get_all_open_commanders(self, package):
    """Return array describing each commander in g.app.commanders()."""
    files = [
        {
            "changed": c.isChanged(),
            "name": c.fileName(),
            "selected": c == self.c,
        } for c in g.app.commanders()
    ]
    return self._make_response({"open-commanders": files})
</t>
<t tx="ekr.20210202110128.57">def open_file(self, package):
    """
    Open a leo file with the given filename.
    Create a new document if no name.
    """
    found, tag = False, 'open_file'
    filename = package.get('filename')  # Optional.
    if filename:
        for c in g.app.commanders():
            if c.fileName() == filename:
                found = True
    if not found:
        c = self.bridge.openLeoFile(filename)
        c.findCommands.ftm = StringFindTabManager(c)
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: bridge did not open {filename!r}")
    if not c.frame.body.wrapper:  # pragma: no cover
        raise ServerError(f"{tag}: no wrapper")
    # Assign self.c
    self.c = c
    c.selectPosition(c.rootPosition())  # Required.
    # Check the outline!
    self._check_outline(c)
    if self.log_flag:  # pragma: no cover
        self._dump_outline(c)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.58">def close_file(self, package):
    """Closes an outline opened with open_file."""
    c = self._check_c()
    # Close the outline, even if it is dirty!
    c.clearChanged()
    c.close()
    # Select the first open outline, if any.
    commanders = g.app.commanders()
    self.c = commanders and commanders[0] or None
    # Return a response describing self.c, not the closed outline.
    return self._make_response()
</t>
<t tx="ekr.20210202110128.61">def get_ui_states(self, package):
    """
    Return the enabled/disabled UI states for the open commander, or defaults if None.
    """
    c = self._check_c()
    tag = 'get_ui_states'
    try:
        states = {
            "changed": c and c.changed,
            "canUndo": c and c.canUndo(),
            "canRedo": c and c.canRedo(),
            "canDemote": c and c.canDemote(),
            "canPromote": c and c.canPromote(),
            "canDehoist": c and c.canDehoist(),
        }
    except Exception as e:  # pragma: no cover
        raise ServerError(f"{tag}: Exception setting state: {e}")
    return self._make_response({"states": states})
</t>
<t tx="ekr.20210202110128.63">def page_up(self, package):
    """
    Selects a node "N" steps up in the tree to simulate page up.
    """
    c = self._check_c()
    n = package.get("n", 3)
    for z in range(n):
        c.selectVisBack()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.64">def page_down(self, package):
    """
    Selects a node "n" steps down in the tree to simulate page down.
    """
    c = self._check_c()
    n = package.get("n", 3)
    for z in range(n):
        c.selectVisNext()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.66">def get_body_states(self, package):
    """
    Return body data for p, where p is c.p if package["ap"] is missing.
    """
    c = self._check_c()
    p = self._get_p(package)
    wrapper = c.frame.body.wrapper
    
    def row_col_dict(i):
        junk, line, col = wrapper.toPythonIndexRowCol(i)
        return {"line": line, "col": col}
        
    # Get the language.
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language')
        or g.getLanguageFromAncestorAtFileNode(p)
        or c.config.getLanguage('target-language')
        or 'plain'
    )
    # get values from wrapper if it's the selected node.
    if c.p.v.gnx == p.v.gnx:
        active = wrapper.getInsertPoint()
        start, end = wrapper.getSelectionRange(True)
        scroll = wrapper.getYScrollPosition()
    else:  # pragma: no cover
        active = p.v.insertSpot
        start = p.v.selectionStart
        end = p.v.selectionStart + p.v.selectionLength
        scroll = p.v.scrollBarSpot
    states = {
        'language': language.lower(),
        'selection': {
            # "gnx": p.v.gnx,  # EKR: Not needed. The reponse will have p.v.gnx.
            "scroll": scroll,
            "active": row_col_dict(active),
            "start": row_col_dict(start),
            "end": row_col_dict(end),
        }
    }
    return self._make_response({"body-states": states})
</t>
<t tx="ekr.20210202110128.68">def get_children(self, package):
    """
    Return the node data for children of p, where p is c.p if package["ap"] is missing."""
    self._check_c()
    p = self._get_p(package)
    return self._make_response({
        # "children": [self._p_to_ap(child) for child in p.children()]
        "children": [self._get_position_d(child) for child in p.children()]
    })
</t>
<t tx="ekr.20210202110128.69">def get_parent(self, package):
    """Return the node data for the parent of position p, where p is c.p if package["ap"] is missing."""
    self._check_c()
    p = self._get_p(package)
    parent = p.parent()
    data = self._get_position_d(parent) if parent else None
    return self._make_response({"parent": data})
</t>
<t tx="ekr.20210202110128.71">def get_all_positions(self, package):
    """
    Return a list of position data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = [
        self._get_position_d(p) for p in c.all_positions(copy=False)
    ]
    return self._make_response({"position-data-list": result})
</t>
<t tx="ekr.20210202110128.72">def get_body(self, package):
    """
    Return p.b, where p is c.p if package["ap"] is missing.
    
    Note: There is no need for a separate get_body_length command,
          because _make_response always adds "body-length": len(p.b)
    """
    self._check_c()
    p = self._get_p(package)
    # _make_response adds all the cheap redraw data, including "body-length"
    return self._make_response({"body": p.b})
    
</t>
<t tx="ekr.20210202110128.74">def set_body(self, package):
    """
    Undoably set p.b, where p is c.p if package["ap"] is missing.
    """
    tag = 'set_body'
    c = self._check_c()
    p = self._get_p(package)
    u, wrapper = c.undoer, c.frame.body.wrapper
    body = package.get('body')
    if body is None:  # pragma: no cover
        raise ServerError(f"{tag}: no body given")
    bunch = u.beforeChangeNodeContents(p)
    p.v.setBodyString(body)
    u.afterChangeNodeContents(p, "Body Text", bunch)
    if c.p == p:
        wrapper.setAllText(body)
    if not self.c.isChanged():  # pragma: no cover
        c.setChanged()
    if not p.v.isDirty():  # pragma: no cover
        p.setDirty()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.75">def set_selection(self, package):
    """
    Set the selection range for p.b, where p is c.p if package["ap"] is missing.
    
    Set the selection in the wrapper if p == c.p
    
    Package has these keys:
        
    - "ap":     An archived position for position p.
    - "start":  The start of the selection.
    - "end":    The end of the selection.
    - "insert": The insert point. Must be either start or end.
    - "scroll": An optional scroll position.
    """
    c = self._check_c()
    p = self._get_p(package)  # Will raise ServerError if p does not exist.
    v = p.v
    wrapper = c.frame.body.wrapper
    start = package.get('start', 0)
    end = package.get('end', 0)
    insert = package.get('insert', 0)
    scroll = package.get('scroll', 0)
    if p == c.p:
        wrapper.setSelectionRange(start, end, insert)
        wrapper.setYScrollPosition(scroll)
    # Always set vnode attrs.
    v.scrollBarSpot = scroll
    v.insertSpot = insert
    v.selectionStart = start
    v.selectionLength = abs(start - end)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.76">def set_headline(self, package):
    """
    Undoably set p.h, where p is c.p if package["ap"] is missing.
    """
    tag = 'set_headline'
    c = self._check_c()
    p = self._get_p(package)
    u = c.undoer
    h = package.get('headline')
    if not h:  # pragma: no cover
        raise ServerError(f"{tag}: no headline")
    bunch = u.beforeChangeNodeContents(p)
    p.h = h
    u.afterChangeNodeContents(p, 'Change Headline', bunch)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.77">def set_current_position(self, package):
    """Select position p, where p is c.p if package["ap"] is missing."""
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.78">def expand_node(self, package):
    """
    Expand the node at position p, where p is c.p if package["ap"] is missing.
    
    To expand c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "expand-node",
    }
    """
    self._check_c()
    p = self._get_p(package)
    p.expand()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.79">def contract_node(self, package):
    """
    Contract the node at position p, where p is c.p if package["ap"] is missing.
    
    To contract c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "contract-node",
    }
    """
    self._check_c()
    p = self._get_p(package)
    p.contract()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.84">def _test_round_trip_positions(self, c):  # pragma: no cover (tested in client).
    """Test the round tripping of p_to_ap and ap_to_p."""
    tag = '_test_round_trip_positions'
    for p in c.all_unique_positions():
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        if p != p2:
            self._dump_outline(c)
            raise ServerError(f"{tag}: round-trip failed: ap: {ap!r}, p: {p!r}, p2: {p2!r}")
</t>
<t tx="ekr.20210202110128.85">def _ap_to_p(self, ap):
    """
    Convert ap (archived position, a dict) to a valid Leo position.
    Raise ServerError on any kind of error.
    """
    tag = '_ap_to_p'
    c = self._check_c()
    gnx_d = c.fileCommands.gnxDict
    outer_stack = ap.get('stack')
    if outer_stack is None:  # pragma: no cover.
        raise ServerError(f"{tag}: no stack in ap: {ap!r}")
    if not isinstance(outer_stack, (list, tuple)):  # pragma: no cover.
        raise ServerError(f"{tag}: stack must be tuple or list: {outer_stack}")
    
    def d_to_childIndex_v (d):
        """Helper: return childIndex and v from d ["childIndex"] and d["gnx"]."""
        childIndex = d.get('childIndex')
        if childIndex is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no childIndex in {d}")
        try:
            childIndex = int(childIndex)
        except Exception:  # pragma: no cover.
            raise ServerError(f"{tag}: bad childIndex: {childIndex!r}")
        gnx = d.get('gnx')
        if gnx is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no gnx in {d}.")
        v = gnx_d.get(gnx)
        if v is None:  # pragma: no cover.
            raise ServerError(f"{tag}: gnx not found: {gnx!r}")
        return childIndex, v
    #
    # Compute p.childIndex and p.v.
    childIndex, v = d_to_childIndex_v(ap)
    #
    # Create p.stack.
    stack = []
    for stack_d in outer_stack:
        stack_childIndex, stack_v = d_to_childIndex_v(stack_d)
        stack.append((stack_v, stack_childIndex))
    #
    # Make p and check p.
    p = Position(v, childIndex, stack)
    if not c.positionExists(p):  # pragma: no cover.
        print(
            f"{tag}: Bad ap: {ap!r}\n"
            # f"{tag}: position: {p!r}\n"
            f"{tag}: v {v!r} childIndex: {childIndex!r}\n"
            f"{tag}: stack: {stack!r}")
        raise ServerError(f"{tag}: p does not exist in {c.shortFileName()}")
    return p
</t>
<t tx="ekr.20210202110128.86">def _p_to_ap(self, p):
    """
    Convert Leo position p to a serializable archived position.
    
    This returns only position-related data.
    get_position_data returns all data needed to redraw the screen.
    """
    self._check_c()
    stack = [{'gnx': v.gnx, 'childIndex': childIndex}
        for (v, childIndex) in p.stack]
    return {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'stack': stack,
    }
</t>
<t tx="ekr.20210202110128.90">async def ws_handler(websocket, path):
    """
    The web socket handler: server.ws_server.

    It must be a coroutine accepting two arguments: a WebSocketServerProtocol and the request URI.
    """
    tag = 'server'
    trace = True
    verbose = False
    try:
        controller._init_connection(websocket)
        # Start by sending empty as 'ok'.
        n = 0
        async_n = 0
        await websocket.send(controller._make_response())
        # controller._sign_on()
        async for json_message in websocket:
            try:
                n += 1
                d = None
                trace = True  ## controller.trace
                d = json.loads(json_message)
                if trace and verbose:
                    print(f"{tag}: got: {d}")
                elif trace:
                    print(f"{tag}: got: {d.get('action')}")
                answer = controller._do_message(d)
            except TerminateServer as e:
                raise websockets.exceptions.ConnectionClosed(code=1000, reason=e)
            except ServerError as e:
                data = f"{d}" if d else f"json syntax error: {json_message!r}"
                error = f"{tag}:  ServerError: {e}...\n{tag}:  {data}"
                print("")
                print(error)
                print("")
                package = {
                    "id": controller.current_id,
                    "action": controller.action,
                    "request": data,
                    "ServerError": f"{e}",
                }  
                answer = json.dumps(package, separators=(',', ':'))
            except InternalServerError as e:  # pragma: no cover
                print(f"{tag}: InternalServerError {e}")
                break
            except Exception as e:  # pragma: no cover
                print(f"{tag}: Unexpected Exception! {e}")
                g.printObj(package, tag=f"message: {d}")
                g.print_exception()
                break
            await websocket.send(answer)
            if n in (3, 4, 7, 10):
                async_n += 1
                controller._es(f"async message {async_n}")
    except websockets.exceptions.ConnectionClosedError as e:  # pragma: no cover
        print(f"{tag}: closed error: {e}")
    except websockets.exceptions.ConnectionClosed as e:
        print(f"{tag}: closed normally: {e}")
    # Don't call EventLoop.stop(). It terminates abnormally.
        # asyncio.get_event_loop().stop()
</t>
<t tx="ekr.20210202183724.1">def save_file(self, package):  # pragma: no cover (too dangerous).
    """Save the leo outline."""
    c = self._check_c()
    c.save()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.10">def toggle_mark(self, package):
    """
    Toggle the mark at position p, where p is c.p if package["ap"] is missing.
    
    To *toggle* the mark of c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "toggle-mark",
    }
    """
    self._check_c()
    p = self._get_p(package)
    if p.isMarked():
        p.clearMarked()
    else:
        p.setMarked()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.11">def clone_node(self, package):
    """
    Clone the node at position p, where p is c.p if package["ap"] is missing.
    
    To clone c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "clone",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.clone()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.12">def cut_node(self, package):  # pragma: no cover (too dangerous, for now)
    """
    Cut the node (and its descendants) at position p, where p is c.p if package["ap"] is missing.
    
    To cut c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "cut-node",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.cutOutline()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.13">def delete_node(self, package):  # pragma: no cover (too dangerous, for now)
    """
    Delete the node (and its descendants) at position p, where p is c.p if package["ap"] is missing.
    
    To delete c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "delete-node",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.deleteOutline()  # Handles undo.
    return self._make_response()
</t>
<t tx="ekr.20210202183724.15">def insert_node(self, package):
    """
    Insert a new node at position p, where p is c.p if package["ap"] is missing.

    This node has 'newHeadline' as its headline.
    
    To insert a new node at c.p (with the default headline), use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "insert-node",
    }
    
    Use the 'set_headline' method to undoably set any node's headlines.
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.insertHeadline()  # Handles undo, sets c.p
    return self._make_response()
</t>
<t tx="ekr.20210202183724.16">def undo(self, package):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canUndo():
        u.undo()
    # Félix: Caller can get focus using other calls.
    return self._make_response()
</t>
<t tx="ekr.20210202183724.17">def redo(self, package):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canRedo():
        u.redo()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.2">def get_buttons(self, package):  # pragma: no cover (no scripting controller)
    """Gets the currently opened file's @buttons list"""
    d = self._check_button_command('get_buttons')
    return self._make_response({
        "buttons": sorted(list(d.get.keys()))
    })
</t>
<t tx="ekr.20210202183724.3">def remove_button(self, package):  # pragma: no cover (no scripting controller)
    """Remove button by name."""
    tag = 'remove_button'
    name = package.get("name")
    if not name:
        raise ServerError(f"{tag}: no button name given")
    d = self._check_button_command(tag)
    if name not in d:
        raise ServerError(f"{tag}: button {name!r} does not exist")
    try:
        del d [name]
    except Exception as e:
        raise ServerError(f"{tag}: exception removing button {name!r}: {e}")
    return self._make_response({
        "buttons": sorted(list(d.get.keys()))
    })
</t>
<t tx="ekr.20210202183724.4">def click_button(self, package):  # pragma: no cover (no scripting controller)
    """Handles buttons clicked in client from the '@button' panel"""
    tag = 'click_button'
    name = package.get("name")
    if not name:
        raise ServerError(f"{tag}: no button name given")
    d = self._check_button_command(tag)
    button = d.get(name)
    if not button:
        raise ServerError(f"{tag}: button {name!r} does not exist")
    try:
        button.command()
    except Exception as e:
        raise ServerError(f"{tag}: exception clicking button {name!r}: {e}")
    return self._make_response()
</t>
<t tx="ekr.20210202183724.5">def get_all_leo_commands(self, package):
    """Return a list of all Leo commands that make sense in leoInteg."""
    tag = 'get_all_leo_commands'
    c = self.dummy_c  # Use the dummy commander.
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands(c)  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:  # pragma: no cover
        print('duplicate command names...')
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:  # pragma: no cover
            print('no func:', command_name)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:  # pragma: no cover
            print('no name', command_name)
            continue
        doc = func.__doc__ or ''
        result.append({
            "command-name": command_name,
            "func":  func_name,
            "detail": doc,
        })
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(result)} leo commands\n")
        g.printObj([z.get("command-name") for z in result], tag=tag)
    return self._make_response({"commands": result})
</t>
<t tx="ekr.20210202183724.6">def _bad_commands(self, c):
    """Return the list of Leo's command names that leoInteg should ignore."""
    d = c.commandsDict  # keys are command names, values are functions.
    bad = []
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="ekr.20210202183724.7">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',
        'clone-find-all-flattened',
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="ekr.20210202193505.1"></t>
<t tx="ekr.20210202193540.1"></t>
<t tx="ekr.20210202193642.1"></t>
<t tx="ekr.20210202193709.1"># These will fail unless the open_file inits c.theScriptingController.
</t>
<t tx="ekr.20210204145818.1">async def _async_output(self, json):  # pragma: no cover (tested in server)
    """Output json string to the web_socket"""
    tag = '_async_output'
    if self.web_socket:
        await self.web_socket.send(bytes(json, 'utf-8'))
    else:
        g.trace(f"{tag}: no web socket. json: {json!r}")
</t>
<t tx="ekr.20210204154548.1"></t>
<t tx="ekr.20210205102806.1"></t>
<t tx="ekr.20210205102818.1">def error(self, package):
    """For unit testing. Raise ServerError"""
    raise ServerError("error called")
</t>
<t tx="ekr.20210205103759.1">def shut_down(self, package):
    """Shut down the server."""
    tag = 'shut_down'
    n = len(g.app.commanders())
    if n:  # pragma: no cover
        raise ServerError(f"{tag}: {n} open outlines")
    raise TerminateServer("client requested shut down")
</t>
<t tx="ekr.20210206062654.1">def get_sign_on(self, package):
    """Synchronous version of _sign_on"""
    g.app.computeSignon()
    signon = []
    for z in (g.app.signon, g.app.signon1):
        for z2 in z.split('\n'):
            signon.append(z2.strip())
    return self._make_response({"sign-on": "\n".join(signon)})
</t>
<t tx="ekr.20210206182638.1">def _make_response(self, package=None):
    """
    Return a json string representing a response dict.
    
    The 'package' kwarg, if present, must be a python dict describing a
    response. package may be an empty dict or None.
    
    The 'p' kwarg, if present, must be a position.
    
    First, this method creates a response (a python dict) containing all
    the keys in the 'package' dict, with the following added keys:
        
    - "id":         The incoming id.
    - "action":     The incoming action.
    - "commander":  A dict describing self.c.
    - "node":       None, or an archived position describing self.c.p.
    
    Finally, this method returns the json string corresponding to the
    response.
    """
    tag = '_make_response'
    c = self.c  # It is valid for c to be None.
    if package is None:
        package = {}
    p = package.get("p")
    if p:
        del package ["p"]
    # Raise an *internal* error if checks fail.
    if isinstance(package, str):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad package kwarg: {package!r}")
    if p and not isinstance(p, Position):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad p kwarg: {p!r}")
    if p and not c:  # pragma: no cover
        raise InternalServerError(f"{tag}: p but not c")
    if p and not c.positionExists(p):  # pragma: no cover
        raise InternalServerError(f"{tag}: p does not exist: {p!r}")
    if c and not c.p:  # pragma: no cover
        raise InternalServerError(f"{tag}: empty c.p")
    #
    # Always add these keys.
    package ["id"] = self.current_id
    package ["action"] = self.action
    # The following keys are relevant only if there is an open commander.
    if c:
        # Allow commands, especially _get_redraw_d, to specify p!
        p = p or c.p
        package ["commander"] = {
            "changed": c.isChanged(),
            "file_name": c.fileName(), # Can be None for new files.
        }
        # Add all the node data, including:
        # - "node": self._p_to_ap(p) # Contains p.gnx, p.childIndex and p.stack.
        # - All the *cheap* redraw data for p.
        redraw_d = self._get_position_d(p)
        for key, value in redraw_d.items():
            if key in package:  # pragma: no cover
                raise InternalServerError(f"{tag}: key {key!r} in package: {package!r}")
            package [key] = value
    if self.log_flag:  # pragma: no cover
        g.printObj(package, tag=f"{tag} returns")
    return json.dumps(package, separators=(',', ':')) 
</t>
<t tx="ekr.20210207051720.1">def _check_button_command(self, tag):  # pragma: no cover (no scripting controller)
    """
    Check that a button command is possible.
    Raise ServerError if not. Otherwise, return sc.buttonsDict.
    """
    c = self._check_c()
    sc = getattr(c, "theScriptingController", None)
    if not sc:
        # This will happen unless mod_scripting is loaded!
        raise ServerError(f"{tag}: no scripting controller")
    return sc.buttonsDict
</t>
<t tx="ekr.20210207054237.1">def _check_c(self):
    """Return self.c or raise ServerError if self.c is None."""
    tag = '_check_c'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no open commander")
    return c
</t>
<t tx="ekr.20210209055518.1">def get_all_server_commands(self, package):
    """
    Public server method:
    Return the names of all callable public methods of the server.
    """
    tag = 'get_all_server_commands'
    names = self._get_all_server_commands()
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(names)} server commands\n")
        g.printObj(names, tag=tag)
    return self._make_response({"server-commands": names})

def _get_all_server_commands(self):
    """
    Private server method:
    Return the names of all callable public methods of the server.
    """
    members = inspect.getmembers(self, inspect.ismethod)
    return sorted([name for (name, value) in members if not name.startswith('_')])
</t>
<t tx="ekr.20210209062536.1">def _do_leo_command(self, action, package):
    """
    Execute the leo command given by package ["leo-command-name"].
    
    The client must open an outline before calling this method.
    """
    # We *can* require self.c to exist, because:
    # 1. all commands imply c.
    # 2. The client must call open_file to set self.c.
    tag = '_execute_leo_command'
    c = self._check_c()
    command_name = package.get("leo-command-name")
    if not command_name:  # pragma: no cover
        raise ServerError(f"{tag}: no 'leo-command-name' key in package")
    if command_name in self.bad_commands_list:  # pragma: no cover
        raise ServerError(f"{tag}: disallowed command: {command_name!r}")
    func = c.commandsDict.get(command_name)
    if not func:  # pragma: no cover
        raise ServerError(f"{tag}: Leo command not found: {command_name!r}")
    value = func(event={"c":c})
    return self._make_response({"return-value": value})
</t>
<t tx="ekr.20210209085438.1">def _do_server_command(self, action, package):
    tag = '_do_server_command'
    # Disallow hidden methods.
    if action.startswith('_'):  # pragma: no cover
        raise ServerError(f"{tag}: action starts with '_': {action!r}")
    # Find and execute the server method.
    func = getattr(self, action, None)
    if not func:
        raise ServerError(f"{tag}: action not found: {action!r}")  # pragma: no cover
    if not callable(func):
        raise ServerError(f"{tag}: not callable: {func!r}")  # pragma: no cover
    return func(package)
</t>
<t tx="ekr.20210210081236.1">def _get_p(self, package):
    """Return _ap_to_p(package["ap"]) or c.p."""
    tag = '_get_ap'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no c")
    ap = package.get("ap")
    if ap:
        p = self._ap_to_p(ap)
        if not p:  # pragma: no cover
            raise ServerError(f"{tag}: no p")
        if not c.positionExists(p):  # pragma: no cover
            raise ServerError(f"{tag}: position does not exist. ap: {ap!r}")
    if not c.p:  # pragma: no cover
        raise ServerError(f"{tag}: no c.p")
    return c.p
</t>
<t tx="ekr.20210211053733.1">def _get_position_d(self, p):
    """
    Return a python dict containing:
    - "node": self._p_to_ap(p).
    - All *cheap* redraw data..
    
    Use get_ua to get p.ua *plus* all this redraw data.
    
    Note: v.computeIcon sets iconVal as follows:
        v, val = self, 0
        if v.hasBody(): val += 1
        if v.isMarked(): val += 2
        if v.isCloned(): val += 4
        if v.isDirty(): val += 8
    """
    return {
        "node": self._p_to_ap(p), # Contains p.gnx, p.childIndex and p.stack.
        # The cheap redraw data...
        "body-length": len(p.b),  # *Not* p.b.
        "has-children": p.hasChildren(),  # *Not* p.children().
        "has-ua": bool(p.v.u),  # *Not* p.v.u.
        "headline": p.h,
        "icon-val": p.v.iconVal,  # An int between 0 and 15.
        "is-at-file": p.isAnyAtFileNode(),
        "level": p.level(),  # Useful for debugging.
    }
</t>
<t tx="ekr.20210211053955.1">def get_position_data_dict(self, package):
    """
    Return a dict of postition data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = {
        p.v.gnx: self._get_position_d(p)
            for p in c.all_unique_positions(copy=False)
    }
    return self._make_response({"position-data-dict": result})
</t>
<t tx="ekr.20210211084004.1"></t>
<t tx="ekr.20210211131234.1">def _check_outline(self, c):
    """Check self.c for consistency."""
    # Check that all positions exist.
    self._check_outline_positions(c)
    # Test round-tripping.
    self._test_round_trip_positions(c)
</t>
<t tx="ekr.20210211131707.1">def _dump_outline(self, c):  # pragma: no cover
    """Dump the outline."""
    tag = '_dump_outline'
    print(f"{tag}: {c.shortFileName()}...\n")
    for p in c.all_positions():
        self._dump_position(p)
    print('')

def _dump_position(self, p):  # pragma: no cover
    level_s = ' ' * 2 * p.level()
    print(f"{level_s}{p.childIndex():2} {p.v.gnx} {p.h}")
</t>
<t tx="ekr.20210211131827.1">def _check_outline_positions(self, c):
    """Verify that all positions in c exist."""
    tag = '_check_outline_positions'
    for p in c.all_positions(copy=False):
        if not c.positionExists(p):  # pragma: no cover
            message = f"{tag}: position {p!r} does not exist in {c.shortFileName()}"
            print(message)
            self._dump_position(p)
            raise ServerError(message)
</t>
<t tx="ekr.20210211233814.1">def get_ua(self, package):
    """Return p.v.u, making sure it can be serialized."""
    self._check_c()
    p = self._get_p(package)
    try:
        ua = {"ua": p.v.u}
        json.dumps(ua, separators=(',', ':'))
        response = {"p": p, "ua": p.v.u} 
    except Exception:  # pragma: no cover
        response = {"p": p, "bad-ua": repr(p.v.u)} 
    # _make_response adds all the cheap redraw data.
    return self._make_response(response)
</t>
<t tx="ekr.20210212092848.1"></t>
<t tx="ekr.20210212092854.1">def find_all(self, package):
    """Run Leo's find-all command and return results."""
    tag = 'find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210212094817.1">def _get_find_settings(self, c):
    """Return a g.Bunch containing the present find settings settings."""
    return c.findCommands.ftm.get_settings()
    ###
        # # For now, return EKR defaults.
        # return g.Bunch(
            # find_text=None, change_text=None,
            # search_body=True, search_headline=True,
            # ignore_case=True, pattern_match=False, whole_word=True,
            # mark_changes=False, mark_finds=False,
            # node_only=False, suboutline_only=False,
            # entry_focus=None,
        # )  
</t>
<t tx="ekr.20210214154702.1">def get_focus(self, packages):
    """
    Return a representation of the focs widget,
    one of ("body", "tree", "headline", repr(the_widget)).
    """
    w = g.app.gui.get_focus()
    focus = g.app.gui.widget_name(w)
    return self._make_response({"focus": focus})
</t>
<t tx="ekr.20210221042145.1">def change_all(self, package):
    """Run Leo's change-all command and return results."""
    tag = 'change_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    change_text = package.get("change_text")
    if change_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no change text")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    settings.change_text = change_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042406.1">def change_then_find(self, package):
    """Run Leo's change-then-find command and return results."""
    tag = 'change_then_find'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_then_find(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042541.1">def clone_find_all(self, package):
    """Run Leo's clone-find-all command and return results."""
    tag = 'clone_find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042633.1">def clone_find_all_flattened(self, package):
    """Run Leo's clone-find-all-flattened command and return results."""
    tag = 'clone_find_all_flattened'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all_flattened(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042719.1">def clone_find_tag(self, package):
    """Run Leo's clone-find-tag command and return results."""
    tag = 'clone_find_tag'
    c = self._check_c()
    fc = c.findCommands
    the_tag = package.get("tag")
    if not the_tag:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    settings = self._get_find_settings(c)
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    n, p = fc.do_clone_find_tag(settings)
    if self.log_flag:  # pragma: no cover
        g.trace("tag: {the_tag} n: {n} p: {p and p.h!r}")
    return self._make_response({"n": n, "p": p})
</t>
<t tx="ekr.20210221042808.1">def find_next(self, package):
    """Run Leo's find-next command and return results."""
    tag = 'find_next'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_next(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221042851.1">def find_previous(self, package):
    """Run Leo's find-previous command and return results."""
    tag = 'find_previous'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_prev(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043043.1">def find_def(self, package):
    """Run Leo's find-def command and return results."""
    tag = 'find_def'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_def(settings, word=find_text, strict=False)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043134.1">def find_var(self, package):
    """Run Leo's find-var command and return results."""
    tag = 'find_var'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_var(settings, word=find_text)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043224.1">def tag_children(self, package):
    """Run Leo's tag-children command and return results."""
    # This is not a find command!
    tag = 'tag_children'
    c = self._check_c()
    fc = c.findCommands
    the_tag = package.get("tag")
    if the_tag is None:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    # Unlike find commands, do_tag_children does not use a settings dict.
    fc.do_tag_children(c.p, the_tag)
    return self._make_response({})
</t>
<t tx="ekr.20210222033958.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1810

- YouTube vids: https://stackoverflow.com/questions/48103685/youtube-video-embedding-pyqt
- Math: https://stackoverflow.com/questions/56760843/how-to-display-mathematical-typesetting-mathjax-latex-etc-in-qt-using-pyqt5
- Matplotlib plots: https://www.learnpyqt.com/tutorials/plotting-matplotlib/
- leaflet maps: https://github.com/skylarkdrones/pyqtlet
- Quizlet flash cards: https://quizlet.com/cn/213650959/pyqt-flash-cards/
- Screen shots: 3Blue1Brown: https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw

@language python
@nosearch
</t>
<t tx="ekr.20210223083935.1"></t>
<t tx="ekr.20210223083944.1">ID,Type,SKU,Name,Short description,Description,Date sale price starts,Date sale price ends,Tax status,Tax class,In stock?,Stock,Backorders allowed?,Sold individually?,Weight (lbs),Length (in),Width (in),Height (in),Allow customer reviews?,Purchase note,Sale price,Regular price,Categories,Tags,Shipping class,Images,Download limit,Download expiry days,Parent,Grouped products,Upsells,Cross-sells,External URL,Button text,Position,Attribute 1 name,Attribute 1 value(s),Attribute 1 visible,Attribute 1 global,Attribute 2 name,Attribute 2 value(s),Attribute 2 visible,Attribute 2 global,Meta: _wpcom_is_markdown,Download 1 name,Download 1 URL,Download 2 name,Download 2 URL


,,5100.1,Chenille Scarf Red x Black,Chenille Scarf,,,,,,1,1,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5102.4,Silk Scarf Azalea x Fine,Silk Scarf,,,,,,1,1,,,,,,,,,,99,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,6533,Mohair Hat,"Mohair Hat, Mitten &amp; Scarf",,,,,,1,1,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,2148,Mohair Mitten,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5104,Mohair Scarf,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,59,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7108,Silk Cowl Canyons x Pacific,Silk Cowl,,,,,,,,,,,,,,,,,??,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7144, Long Cowl Canyons Chenile  x Peacock Silk,Chenille &amp; Silk Cowl,,,,,,,,,,,,,,,,,89,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,Deflected Doubleweave Scarf,,,,,,,,,,,,,,,,,139,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,Rayon &amp; Chenille Scarf,,,,,,,,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
</t>
<t tx="ekr.20210223084024.1">,,5100.1,Chenille Scarf Red x Black,Chenille Scarf,,,,,,1,1,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5102.4,Silk Scarf Azalea x Fine,Silk Scarf,,,,,,1,1,,,,,,,,,,99,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,6533,Mohair Hat,"Mohair Hat, Mitten &amp; Scarf",,,,,,1,1,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,2148,Mohair Mitten,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5104,Mohair Scarf,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,59,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7108,Silk Cowl Canyons x Pacific,Silk Cowl,,,,,,,,,,,,,,,,,??,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7144, Long Cowl Canyons Chenile  x Peacock Silk,Chenille &amp; Silk Cowl,,,,,,,,,,,,,,,,,89,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,Deflected Doubleweave Scarf,,,,,,,,,,,,,,,,,139,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,Rayon &amp; Chenille Scarf,,,,,,,,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
</t>
<t tx="ekr.20210223084115.1">root = g.findTopLevelNode(c, '@csv')
assert root
for s in g.splitlines(p.b):
    fields = ???
    child = root.insertAsLastChild()
    child.h = </t>
<t tx="ekr.20210226104255.1">g.cls()
p = c.lastTopLevel()
lines = g.splitLines(p.b)
n = lines[0].count(',')
# print(n)
for i, s in enumerate(lines):
    if s.strip():
        n2 = s.count(',')
        if n != n2:
            print(i, n2)
print('done')
</t>
<t tx="ekr.20210226104315.1">SKU,Description,In stock?,Stock,Regular price,Categories,Images
5100.1,Chenille Scarf Red x Black,1,1,79.00,Clothing,https://rrhandwovens.com/5100-1-scarf-red-x-black-chenille/
5102.4,Silk Scarf Azalea x Fine,1,1,99.00,Clothing,https://rrhandwovens.com/5102-4-scarf-azalea-x-fine-med-navy-silk/
6533,Mohair Hat,1,1,39.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
2148,Mohair Mitten,1,1,39.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
5104,Mohair Scarf,1,1,59.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
7108,Silk Cowl Canyons x Pacific,1,1,98.00,Clothing,https://rrhandwovens.com/7108-silk-cowl-canyons-x-pacific/
7144, Long Cowl Canyons Chenile  x Peacock Silk,1,1,89.00,Clothing,https://rrhandwovens.com/7144-long-cowl-canyons-chenill-x-peacock-silk/
5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,1,1,139.00,Clothing,https://rrhandwovens.com/5112-1-deflected-double-weave-2-tencel-alpaca-silk-scarf/
5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,1,1,79.00,Clothing,https://rrhandwovens.com/5112-6-forest-floor-x-grey-green-chenille/
</t>
<t tx="ekr.20210228045338.1">- Make Rebecca an admin.

- Sign in to stripe.
- Add contact page.
- Customize my-account page.
- Set tax and payment methods.
</t>
<t tx="ekr.20210302111935.5">def finalize(self, p):
    """Finalize p's path."""
    c = self.c
    aList = g.get_directives_dict_list(p)
    path = self.c.scanAtPathDirectives(aList)
    path = c.expand_path_expression(path)  # #1341.
    fn = p.anyAtFileNodeName()
    fn = c.expand_path_expression(fn)  # #1341.
    return g.os_path_finalize_join(path, fn)
</t>
<t tx="ekr.20210305085324.1">@language rest
@wrap

ekr-scripting branch

https://github.com/leo-editor/leo-editor/issues/1715

Test on Rust

@language python
@nosearch
</t>
<t tx="ekr.20210305133229.1">def execute_external_language_script(self,
    error_regex = None,
    language_command = None,
    script_language = None,
):
    """
    A general-purpose helper that composes and runs a Leonine script for
    languages other than python.
    
    command:         The external command that runs the language processor.
    error_regex:     Optional regular expression matching error messages.
    regex_flags:     Optional flags for the regular expression.
    script_language: The name of the language.
    """
    ### How to specify file name?
    c = self
</t>
<t tx="ekr.20210309083845.1">"""
Issue https://github.com/leo-editor/leo-editor/issues/1789
"""
g.cls()
import glob

def munge(s):
    return s.replace('\\','/').lower()
    
ignore = [
    # Core...
    'format-code.py',       # Script.
    'leoTangle.py',         # To be deleted.
    # External...
    'leoftsindex.py',       # User contributed.
    'sax2db.py',            # User contributed.
    'stringlist.py',        # User contributed.
    # Plugins...
    'baseNativeTree.py',    # No longer used. To be deleted?
    'leofts.py',            # User contributed.
    'qt_main.py',           # Created by Qt designer. Not used.
    'rst3.py',              # To be deleted?
]
ignore = [munge(z) for z in ignore]
# Find all paths for @&lt;file&gt; nodes.
seen = {}
for p in c.all_positions():
    if p.isAnyAtFileNode():
        path = munge(g.fullPath(c, p))
        seen [path] = path
# Check all .py files.  
for module in ('core', 'external', 'plugins'):
    print(f"checking {module}...")
    pat = g.os_path_finalize_join(g.app.loadDir, '..', module, '*.py')
    paths = glob.glob(pat)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    paths = [munge(z) for z in paths]
    # g.printObj(paths, tag=f"\n{len(paths)} files in {module}")
    for path in paths:
        if path not in seen and g.shortFileName(path) not in ignore:
            print(f"Missing: {path}")
    print('')
</t>
<t tx="ekr.20210314092447.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1846

@language python
@nosearch
</t>
<t tx="ekr.20210314093517.1"></t>
<t tx="ekr.20210323144348.1"></t>
<t tx="ekr.20210326065206.1">@nosearch

# Ignore Case, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210326070421.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1868

@language python
@nosearch
</t>
<t tx="ekr.20210329175515.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1873

@language python
@nosearch
</t>
<t tx="ekr.20210329182132.1">@nosearch

# Word, Ignore Case, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210329182330.1"></t>
<t tx="ekr.20210329182544.1">@nosearch

# Word, Ignore Case, Head, Body

# found 10 nodes</t>
<t tx="ekr.20210329182640.1">@nosearch

# Word, Ignore Case, Head, Body

# found 32 nodes</t>
<t tx="ekr.20210329183955.1">@nosearch

# Word, Ignore Case, Head, Body

# found 7 nodes</t>
<t tx="ekr.20210330170027.1"></t>
<t tx="ekr.20210330170105.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1875

pep8 naming conventions: https://www.python.org/dev/peps/pep-0008/#naming-conventions

@language python
@nosearch
</t>
<t tx="ekr.20210402073104.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1874

@language python
@nosearch
</t>
<t tx="ekr.20210407010154.1">g.cls()
from leo.core.leoQtWrapper import *
import leo.core.leoQtWrapper as m
# g.printObj(sorted(z for z in dir(m) if not z.startswith('_')))
if 1:
    for z in sorted(dir()):
        if z.startswith('_'):
            continue
        val = getattr(m, z, None) 
        if val is None:
            continue
        if repr(val).startswith('&lt;module'):
            val = val.__class__.__name__
        print(f"{z:&gt;20}: {val}")
</t>
<t tx="ekr.20210407010904.1"></t>
<t tx="ekr.20210407010914.1"></t>
<t tx="ekr.20210407011013.1"></t>
<t tx="ekr.20210408005222.1">@nosearch

# \.[A-Z][A-Za-z]+\.[A-Z]

# Regex, Head, Body

# found 55 nodes</t>
<t tx="ekr.20210408073917.1">@nowrap

#
# Inject old-style enums...
if 0:  # A bad idea in the long run.
    # Much better to make qt version dependencies visible in the code.
    #
    # Qt.ContextMenuPolicy
    QtCore.Qt.ActionsContextMenu = QtCore.Qt.ContextMenuPolicy.ActionsContextMenu
    QtCore.Qt.CustomContextMenu = QtCore.Qt.ContextMenuPolicy.CustomContextMenu
    #
    # Qt.ItemFlags
    QtCore.Qt.ItemIsEditable = QtCore.Qt.ItemFlags.ItemIsEditable
    # 
    # Qt.Orientations.
    QtCore.Qt.Horizontal = QtCore.Qt.Orientations.Horizontal
    QtCore.Qt.Vertical = QtCore.Qt.Orientations.Vertical
    #
    # Qt.ScrollBarPolicy.
    QtCore.Qt.ScrollBarAlwaysOff = QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff
    QtCore.Qt.ScrollBarAsNeeded = QtCore.Qt.ScrollBarPolicy.ScrollBarAsNeeded
    #
    # Qt.TextInteractionFlags.
    QtCore.Qt.LinksAccessibleByMouse = QtCore.Qt.TextInteractionFlags.LinksAccessibleByMouse
    QtCore.Qt.TextEditable = QtCore.Qt.TextInteractionFlags.TextEditable
    QtCore.Qt.TextSelectableByMouse = QtCore.Qt.TextInteractionFlags.TextSelectableByMouse
    #
    # Qt.ToolBarAreas.
    QtCore.Qt.BottomToolBarArea = QtCore.Qt.ToolBarAreas.BottomToolBarArea
    QtCore.Qt.LeftToolBarArea = QtCore.Qt.ToolBarAreas.LeftToolBarArea
    QtCore.Qt.RightToolBarArea = QtCore.Qt.ToolBarAreas.RightToolBarArea
    QtCore.Qt.TopToolBarArea = QtCore.Qt.ToolBarAreas.TopToolBarArea
    #
    # QAbstractItemView.SelectionMode &amp; QAbstractItemView.SelectionBehavior.
    QtWidgets.QAbstractItemView.ExtendedSelection = QtWidgets.QAbstractItemView.SelectionMode.ExtendedSelection
    QtWidgets.QAbstractItemView.SelectRows = QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows
    #
    # QComboBox.
    QtWidgets.QComboBox.AdjustToContents = QtWidgets.QComboBox.SizeAdjustPolicy.AdjustToContents
    #
    # QDialog.
    QtWidgets.QDialog.exec_ = QtWidgets.QDialog.exec
    #
    # QtConst.
    QtConst.ItemIsEditable = QtConst.ItemFlags.ItemIsEditable
    #
    # QEvent.Type.
    QtCore.QEvent.FocusIn = QtCore.QEvent.Type.FocusIn
    QtCore.QEvent.FocusOut = QtCore.QEvent.Type.FocusOut
    QtCore.QEvent.KeyPress = QtCore.QEvent.Type.KeyPress
    QtCore.QEvent.KeyRelease = QtCore.QEvent.Type.KeyRelease
    QtCore.QEvent.ShortcutOverride = QtCore.QEvent.Type.ShortcutOverride
    QtCore.QEvent.WindowActivate = QtCore.QEvent.Type.WindowActivate
    QtCore.QEvent.WindowDeactivate = QtCore.QEvent.Type.WindowDeactivate
    #
    # QFont.Weight
    QtGui.QFont.Black = QtGui.QFont.Weight.Black
    QtGui.QFont.Bold = QtGui.QFont.Weight.Bold
    QtGui.QFont.DemiBold = QtGui.QFont.Weight.DemiBold
    QtGui.QFont.Light = QtGui.QFont.Weight.Light
    QtGui.QFont.Normal = QtGui.QFont.Weight.Normal
    #
    # QFrame.Shadow &amp; QFrame.Shape
    QtWidgets.QFrame.Plain = QtWidgets.QFrame.Shadow.Plain
    QtWidgets.QFrame.NoFrame = QtWidgets.QFrame.Shape.NoFrame
    #
    # QImage.Format
    QtGui.QImage.Format_ARGB32_Premultiplied = QtGui.QImage.Format.Format_ARGB32_Premultiplied
    #
    # QMessageBox.Icon, ButtonRole &amp; exec
    QtWidgets.QMessageBox.Information = QtWidgets.QMessageBox.Icon.Information
    QtWidgets.QMessageBox.YesRole = QtWidgets.QMessageBox.ButtonRole.YesRole
    #
    # QSizePolicy.Policy.
    QtWidgets.QSizePolicy.Expanding = QtWidgets.QSizePolicy.Policy.Expanding
    QtWidgets.QSizePolicy.Fixed = QtWidgets.QSizePolicy.Policy.Fixed
    QtWidgets.QSizePolicy.Ignored = QtWidgets.QSizePolicy.Policy.Ignored
    QtWidgets.QSizePolicy.Minimum = QtWidgets.QSizePolicy.Policy.Minimum
    QtWidgets.QSizePolicy.MinimumExpanding = QtWidgets.QSizePolicy.Policy.MinimumExpanding
    QtWidgets.QSizePolicy.Preferred = QtWidgets.QSizePolicy.Policy.Preferred
    #
    # QTextCharFormat.UnderlineStyle
    QtGui.QTextCharFormat.NoUnderline = QtGui.QTextCharFormat.UnderlineStyle.NoUnderline
    #
    # QTextCursor.MoveOperation.
    QtGui.QTextCursor.End = QtGui.QTextCursor.MoveOperation.End
    #
    # QTextOption.WrapMode.
    QtGui.QTextOption.NoWrap = QtGui.QTextOption.WrapMode.NoWrap
    QtGui.QTextOption.WrapAtWordBoundaryOrAnywhere = QtGui.QTextOption.WrapMode.WrapAtWordBoundaryOrAnywhere
    #
    # QTreeWidgetItem.ChildIndicatorPolicy
    QtWidgets.QTreeWidgetItem.DontShowIndicatorWhenChildless = QtWidgets.QTreeWidgetItem.ChildIndicatorPolicy.DontShowIndicatorWhenChildless</t>
<t tx="ekr.20210409084100.1">from leo.core.leoQt import isQt6, QtCore, QtWidgets
import datetime
title = "Hi"
msg = message = "Message"
version = 'Version'
theCopyright = 'CopyRight'
email = 'edreamleo@gmail.com'
url = 'leo-editor.com'
yesMessage = 'Yes'
noMessage = 'No'
yesToAllMessage = 'Yes To All'
cancelMessage = 'Cancel'
defaultButton = 'Yes'
init = None
step_min = None
# -----

QDialog = QtWidgets.QDialog
QDialogButtonBox = QtWidgets.QDialogButtonBox
DialogCode = QDialog.DialogCode if isQt6 else QDialog
StandardButtons = QDialogButtonBox.StandardButtons if isQt6 else QDialogButtonBox
        
class DateTimeEditStepped(QtWidgets.QDateTimeEdit):
    """QDateTimeEdit which allows you to set minimum steps on fields, e.g.
      DateTimeEditStepped(parent, {QtWidgets.QDateTimeEdit.MinuteSection: 5})
    for a minimum 5 minute increment on the minute field.
    """

    def __init__(self, parent=None, init=None, step_min=None):
        if step_min is None: step_min = {}
        self.step_min = step_min
        if init:
            super().__init__(init, parent)
        else:
            super().__init__(parent)

    def stepBy(self, step):
        cs = self.currentSection()
        if cs in self.step_min and abs(step) &lt; self.step_min[cs]:
            step = self.step_min[cs] if step &gt; 0 else -self.step_min[cs]
        QtWidgets.QDateTimeEdit.stepBy(self, step)


class Calendar(QtWidgets.QDialog):

    def __init__(self,
        parent=None,
        message='Select Date/Time',
        init=None,
        step_min=None
    ):
        if step_min is None: step_min = {}
        super().__init__(parent)
        layout = QtWidgets.QVBoxLayout()
        self.setLayout(layout)
        layout.addWidget(QtWidgets.QLabel(message))
        self.dt = DateTimeEditStepped(init=init, step_min=step_min)
        self.dt.setCalendarPopup(True)
        layout.addWidget(self.dt)
        buttonBox = QtWidgets.QDialogButtonBox(StandardButtons.Ok | StandardButtons.Cancel)
        layout.addWidget(buttonBox)
        buttonBox.accepted.connect(self.accept)
        buttonBox.rejected.connect(self.reject)

if step_min is None: step_min = {}
b = Calendar
if not init:
    init = datetime.datetime.now()
d = b(c.frame.top, message=message, init=init, step_min=step_min)
d.setStyleSheet(c.active_stylesheet)
d.setWindowTitle(title)
try:
    c.in_qt_dialog = True
    val = d.exec() if isQt6 else d.exec_()
finally:
    c.in_qt_dialog = False
if val == DialogCode.Accepted:
    print(d.dt.dateTime().toPyDateTime())
else:
    print('Cancel')</t>
<t tx="ekr.20210409093413.1">from leo.core.leoQt import isQt6, QtCore

# ---
MouseButtons = QtCore.Qt.MouseButtons if isQt6 else QtCore.Qt
button = MouseButtons.NoButton
table = (
    (MouseButtons.NoButton, 'no button'),
    (MouseButtons.LeftButton, 'left-button'),
    (MouseButtons.RightButton, 'right-button'),
    (MouseButtons.MiddleButton, 'middle-button'),
)
for val, s in table:
    if button == val:
        kind = s
        break
else:
    kind = f"unknown: {repr(button)}"
print(kind)</t>
<t tx="ekr.20210409094247.1">from leo.core.leoQt import isQt6, QtCore
# ---
WindowFlags = QtCore.Qt.WindowFlags if isQt6 else QtCore.Qt
print(WindowFlags.Popup)
# self.setWindowFlags(WindowFlags.Popup | self.windowFlags())</t>
<t tx="ekr.20210409094847.1">from leo.core.leoQt import isQt6, QtCore
# ---
Alignment = QtCore.Qt.Alignment if isQt6 else QtCore.Qt
print(Alignment.AlignLeft)</t>
<t tx="ekr.20210409095222.1"></t>
<t tx="ekr.20210409200922.1">Alignment = QtCore.Qt.Alignment if isQt6 else QtCore.Qt
ButtonRole = QtWidgets.QMessageBox.ButtonRole if isQt6 else QtWidgets.QMessageBox
ContextMenuPolicy = QtCore.Qt.ContextMenuPolicy if isQt6 else QtCore.Qt
ControlTypes = QtWidgets.QSizePolicy.ControlTypes if isQt6 else QtWidgets.QSizePolicy
DialogCode = QtWidgets.QDialog.DialogCode if isQt6 else QtWidgets.QDialog
DropActions = QtCore.Qt.DropActions if isQt6 else QtCore.Qt
EndEditHint = QtWidgets.QAbstractItemDelegate.EndEditHint if isQt6 else QtWidgets.QAbstractItemDelegate
FocusPolicy = QtCore.Qt.FocusPolicy if isQt6 else QtCore.Qt
FocusReason = QtCore.Qt.FocusReason if isQt6 else QtCore.Qt
Format = QtGui.QImage.Format if isQt6 else QtGui.QImage
GlobalColor = QtCore.Qt.GlobalColor if isQt6 else QtCore.Qt
Icon = QtWidgets.QMessageBox.Icon if isQt6 else QtWidgets.QMessageBox
Information = QtWidgets.QMessageBox.Icon.Information if isQt6 else QtWidgets.QMessageBox
ItemFlags = QtCore.Qt.ItemFlags if isQt6 else QtCore.Qt
Key = QtCore.Qt.Key if isQt6 else QtCore.Qt
KeyboardModifiers = QtCore.Qt.KeyboardModifiers if isQt6 else QtCore.Qt
Modifiers = QtCore.Qt.KeyboardModifiers if isQt6 else QtCore.Qt
MouseButtons = QtCore.Qt.MouseButtons if isQt6 else QtCore.Qt
MoveMode = QtGui.QTextCursor.MoveMode if isQt6 else QtGui.QTextCursor
MoveOperation = QtGui.QTextCursor.MoveOperation if isQt6 else QtGui.QTextCursor
Orientations = QtCore.Qt.Orientations if isQt6 else QtCore.Qt
Policy = QtWidgets.QSizePolicy.Policy if isQt6 else QtWidgets.QSizePolicy
QAction = QtGui.QAction if isQt6 else QtWidgets.QAction
QStyle = QtWidgets.QStyle.StandardPixmap if isQt6 else QtWidgets.QStyle
ScrollBarPolicy = QtCore.Qt.ScrollBarPolicy if isQt6 else QtCore.Qt
SelectionBehavior = QtWidgets.QAbstractItemView.SelectionBehavior if isQt6 else QtWidgets.QAbstractItemView
SelectionMode = QtWidgets.QAbstractItemView.SelectionMode if isQt6 else QtWidgets.QAbstractItemView
Shadow = QtWidgets.QFrame.Shadow if isQt6 else QtWidgets.QFrame
Shape = QtWidgets.QFrame.Shape if isQt6 else QtWidgets.QFrame 
SizeAdjustPolicy = QtWidgets.QComboBox.SizeAdjustPolicy if isQt6 else QtWidgets.QComboBox
SliderAction = QtWidgets.QAbstractSlider.SliderAction if isQt6 else QtWidgets.QAbstractSlider
StandardButtons = QDialogButtonBox.StandardButtons if isQt6 else QDialogButtonBox
StandardPixmap = QtWidgets.QStyle.StandardPixmap if isQt6 else QtWidgets.QStyle
TextInteractionFlags = QtCore.Qt.TextInteractionFlags if isQt6 else QtCore.Qt
ToolBarAreas = QtCore.Qt.ToolBarAreas if isQt6 else QtCore.Qt
Type = QtCore.QEvent.Type if isQt6 else QtCore.QEvent
UnderlineStyle = QtGui.QTextCharFormat.UnderlineStyle if isQt6 else QtGui.QTextCharFormat
Weight = QtGui.QFont.Weight if isQt6 else QtGui.QFont
WindowFlags = QtCore.Qt.WindowFlags if isQt6 else QtCore.Qt
WindowStates = QtCore.Qt.WindowStates if isQt6 else QtCore.Qt
WrapMode = QtGui.QTextOption.WrapMode if isQt6 else QtGui.QTextOption
</t>
<t tx="ekr.20210411033752.1"></t>
<t tx="ekr.20210411043344.1"></t>
<t tx="ekr.20210412103249.1">from leo.core.leoQt import isQt6, QtWidgets

Shadow = QtWidgets.QFrame.Shadow.Sunken if isQt6 else self.Sunken
print(Shadow.Sunken)</t>
<t tx="ekr.20210415172224.1">@nosearch

# Regex, Body

# found 53 nodes</t>
<t tx="ekr.20210420094838.1"></t>
<t tx="ekr.20210423065125.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1766

@language python
@nosearch
</t>
<t tx="ekr.20210427165525.1">g.cls()
import os
leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
os.chdir(leo_editor_dir)
test = '' # Run all tests.
commands = f"python -m unittest leo.core.leoExternalFiles.TestExternalFiles{test}"
g.execute_shell_commands(commands, trace=False)
</t>
<t tx="ekr.20210428094855.1">"""Run py-cov on leoExternalFiles.py"""
g.cls()
import os
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
command = prolog + r"leo.core.leoExternalFiles leo\core\leoExternalFiles.py"
g.execute_shell_commands(command)
</t>
<t tx="ekr.20210429042712.1"></t>
<t tx="ekr.20210429042717.1">g.cls()
import os
leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
os.chdir(leo_editor_dir)
test = '' # Run all tests.
# test = '.test_bug_1889'
commands = f"python -m unittest leo.core.leoAtFile.TestAtFile{test}"
g.execute_shell_commands(commands, trace=False)
</t>
<t tx="ekr.20210429045101.1">g.cls()
fc = c.fileCommands
d = fc.gnxDict
for key in sorted(d.keys()):
    v = d.get(key)
    if v.h.lower() == 'newheadline':
        print('in dict', key, v)
        for p in c.all_positions():
            if p.v == v:
                print(p)
        else:
            print('no position for', v)</t>
<t tx="ekr.20210429045731.2">"""Run unittest on leoserver.py: good for debugging."""
g.cls()
import os
if c.changed:
    c.save()
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
g.execute_shell_commands('python -m unittest leo.core.leoFind')
</t>
<t tx="ekr.20210429045731.3">"""Run py-cov on leoserver.py"""
g.cls()
import os
if c.changed:
    c.save()
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
command = prolog + r"leo.core.leoFind leo\core\leoFind.py"
g.execute_shell_commands(command)
</t>
<t tx="ekr.20210429050253.1"># https://github.com/leo-editor/leo-editor/issues/1781
# g.cls()
from leo.commands import editFileCommands
import importlib
importlib.reload(efc)
fn = 'git_diff_test.leo'
rev1, rev2 = '1ae08a66', 'HEAD'  # 'HEAD@{1}', 'HEAD@{0}'
x = efc.GitDiffController(c)
x.set_directory(None)
x.root = x.create_root(rev1, rev2)
x.diff_file(fn, rev1=rev1, rev2=rev2)
c.redraw()
</t>
<t tx="ekr.20210429050349.2">g.cls()
import time
if c.changed:
    c.save()
g.execute_shell_commands('start cmd /k "python leoserver.py"')
time.sleep(0.5)
g.execute_shell_commands('start cmd /k "python leoclient.py"')
if 0:
    time.sleep(8)
    g.execute_shell_commands(r'moz c:\test\index.html')

</t>
<t tx="ekr.20210429050349.3">"""Run unittest on leoserver.py: good for debugging."""
g.cls()
import os
if c.changed:
    c.save()
leo_dir = os.path.join(g.app.loadDir, '..', '..')
assert os.path.exists(leo_dir), repr(leo_dir)
os.chdir(leo_dir)
# leoserver.main detects and removes the --unittest command-line arg.
g.execute_shell_commands('python -m leo.core.leoserver --unittest')
</t>
<t tx="ekr.20210429050349.4">"""Run py-cov on leoserver.py"""
g.cls()
import os
if c.changed:
    c.save()
leo_dir = os.path.join(g.app.loadDir, '..', '..')
assert os.path.exists(leo_dir), repr(leo_dir)
os.chdir(leo_dir)
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
command = prolog + r"leo.core.leoserver leo\core\leoserver.py"
g.execute_shell_commands(command)
</t>
<t tx="ekr.20210429050530.1">g.cls()
import importlib
import leo.commands.editFileCommands as editFileCommands

if c.isChanged():
    c.save()

importlib.reload(editFileCommands)

path = r'c:\test\atRoot.leo'
hidden_c = g.createHiddenCommander(path)
editFileCommands.ConvertAtRoot().convert_file(hidden_c)
print('done')</t>
<t tx="ekr.20210429055538.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1811

@language python
@nosearch
</t>
<t tx="ekr.20210429063120.1">- Hypothesis and pydantic.
- Finish rust book.</t>
<t tx="ekr.20210429064706.1"></t>
<t tx="ekr.20210429152304.1"></t>
<t tx="ekr.20210429152458.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1914

- import-file fails for external files.

Post:
- We aren't going back.
- A big collapse.
- weird code in at.scanAllDirectives needs more testing.

@language python
@nosearch</t>
<t tx="ekr.20210430131246.1">@nosearch</t>
<t tx="ekr.20210501061105.1"></t>
<t tx="ekr.20210501063144.1"></t>
<t tx="ekr.20210501064359.1">def writeOneAtCleanNode(self, root):
    """Write one @clean file..
    root is the position of an @clean node.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root)
        at.sentinels = False
        if not fileName or not at.precheck(fileName, root):
            return
        at.outputList = []
        at.putFile(root, sentinels=False)
        at.warnAboutOrphandAndIgnoredNodes()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20210501064805.1">@language rest
@wrap

- (done) kind kwarg.
- (done) atEdit kwarg.
- (done) atShadow kwarg.
- (done) forcePythonSentinels kwarg.

@language python
@nosearch
</t>
<t tx="ekr.20210501065352.1">def writeOneAtNosentNode(self, root):
    """Write one @nosent node.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root)
        at.sentinels = False
        if not fileName or not at.precheck(fileName, root):
            return
        at.outputList = []
        at.putFile(root, sentinels=False)
        at.warnAboutOrphandAndIgnoredNodes()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20210501071034.1">@nosearch

# Word, Ignore Case, Head, Body

# found 14 nodes</t>
<t tx="ekr.20210501073124.1">@nosearch

# Word, Ignore Case, Head, Body

# found 10 nodes</t>
<t tx="ekr.20210501073131.1">@language rest
@wrap

- (done) atShadow kwarg.
- (done) perfectImportRoot kwarg.

@language python
@nosearch
</t>
<t tx="ekr.20210501075610.1">def writeOneAtFileNode(self, root):
    """Write @file or @thin file."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root)
        at.sentinels = True
        if not fileName or not at.precheck(fileName, root):
            # Raise dialog warning of data loss.
            at.addToOrphanList(root)
            return
        at.outputList = []
        at.putFile(root, sentinels=True)
        at.warnAboutOrphandAndIgnoredNodes()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20210501080357.1"></t>
<t tx="ekr.20210501080424.1"></t>
<t tx="ekr.20210501094953.1">gnx: ekr.20201012111338.2
unl: Declarations (leo_cloud.py)
gnx: ekr.20201012111338.3
unl: init (leo_cloud.py)
gnx: ekr.20201012111338.4
unl: onCreate (leo_cloud.py)
gnx: ekr.20201012111338.5
unl: onSave (leo_cloud.py)
gnx: ekr.20201012111338.6
unl: lc_read_current (leo_cloud.py)
gnx: ekr.20201012111338.7
unl: lc_write_current (leo_cloud.py)
gnx: ekr.20201012111338.8
unl: class LeoCloudIOBase
gnx: ekr.20201012111338.9
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.__init__
gnx: ekr.20201012111338.10
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.get_subtree
gnx: ekr.20201012111338.11
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.put_subtree
gnx: ekr.20201012111338.12
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)
gnx: ekr.20201012111338.13
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.14
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.15
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.16
unl: class LeoCloudIOGit(LeoCloudIOBase)
gnx: ekr.20201012111338.17
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.18
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase)._run_git
gnx: ekr.20201012111338.19
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.20
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.21
unl: class LeoCloud
gnx: ekr.20201012111338.22
unl: class LeoCloud--&gt;LeoCloud.__init__
gnx: ekr.20201012111338.23
unl: class LeoCloud--&gt;LeoCloud.bg_check
gnx: ekr.20201012111338.24
unl: class LeoCloud--&gt;LeoCloud.bg_post_process
gnx: ekr.20201012111338.25
unl: class LeoCloud--&gt;LeoCloud.find_at_leo_cloud
gnx: ekr.20201012111338.26
unl: class LeoCloud--&gt;LeoCloud._find_clouds_recursive
gnx: ekr.20201012111338.27
unl: class LeoCloud--&gt;LeoCloud.find_clouds
gnx: ekr.20201012111338.28
unl: class LeoCloud--&gt;LeoCloud._from_dict_recursive
gnx: ekr.20201012111338.29
unl: class LeoCloud--&gt;LeoCloud.from_dict
gnx: ekr.20201012111338.30
unl: class LeoCloud--&gt;LeoCloud.io_from_node
gnx: ekr.20201012111338.31
unl: class LeoCloud--&gt;LeoCloud.kw_from_node
gnx: ekr.20201012111338.32
unl: class LeoCloud--&gt;LeoCloud.load_clouds
gnx: ekr.20201012111338.33
unl: class LeoCloud--&gt;LeoCloud.read_current
gnx: ekr.20201012111338.34
unl: class LeoCloud--&gt;LeoCloud.recursive_hash
gnx: ekr.20201012111338.35
unl: class LeoCloud--&gt;LeoCloud.save_clouds
gnx: ekr.20201012111338.36
unl: class LeoCloud--&gt;LeoCloud.subtree_changed
gnx: ekr.20201012111338.37
unl: class LeoCloud--&gt;LeoCloud._to_json_serial
gnx: ekr.20201012111338.38
unl: class LeoCloud--&gt;LeoCloud.to_json
gnx: ekr.20201012111338.39
unl: class LeoCloud--&gt;LeoCloud._to_dict_recursive
gnx: ekr.20201012111338.40
unl: class LeoCloud--&gt;LeoCloud.to_dict
gnx: ekr.20201012111338.41
unl: class LeoCloud--&gt;LeoCloud._ua_clean
gnx: ekr.20201012111338.42
unl: class LeoCloud--&gt;LeoCloud.write_current
</t>
<t tx="ekr.20210501094953.2">gnx: ekr.20201012111338.43
unl: Declarations (leo_cloud_server.py)
</t>
<t tx="ekr.20210501132005.1">@nosearch

# Word, Ignore Case, Head, Body

# found 15 nodes</t>
<t tx="ekr.20210501132131.1">@language rest
@wrap

- (Done) remove forcePythonSentinels kwarg.
- (Done) remove importing kwarg.
- (Done) remove reading kwarg.
- (Done) remove at.importing ivar.

- (??) importFileName kwarg??

@language python
@nosearch</t>
<t tx="ekr.20210501141946.1">@nosearch

# Word, Ignore Case, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210501142120.1"></t>
<t tx="ekr.20210502082820.1">@nosearch

# Word, Ignore Case, Body
</t>
<t tx="ekr.20210502085613.1"></t>
<t tx="ekr.20210502094003.1">@nosearch

# Word, Ignore Case, Head, Body

# found 1 nodes</t>
<t tx="ekr.20210502131533.1">git diff revs: 7aa7adfe HEAD

@ignore
@nosearch

### Summary.

- Delete several unused methods.
- Delete support for @root* directives.
- Delete many evil kwargs and unnecessary ivars.</t>
<t tx="ekr.20210502131534.1">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -83,7 +83,6 @@
         at = self
         c = at.c
         at.at_auto_encoding = c.config.default_at_auto_file_encoding
-        at.default_directory = None
         at.encoding = c.config.default_derived_file_encoding
         at.endSentinelComment = ""
         at.errors = 0
@@ -99,11 +98,7 @@
         at.tab_width = c.tab_width or -4
         at.writing_to_shadow_directory = False
     #@+node:ekr.20041005105605.13: *4* at.initReadIvars
-    def initReadIvars(self, root, fileName,
-        importFileName=None,
-        perfectImportRoot=None,
-        atShadow=False,
-    ):
+    def initReadIvars(self, root, fileName):
         at = self
         at.initCommonIvars()
         at.bom_encoding = None
@@ -125,7 +120,6 @@
         at.endSentinelNodeStack = []
             # Used only when readVersion5.
         at.fromString = False
-        at.importing = bool(importFileName)
         at.importRootSeen = False
         at.indentStack = []
         at.lastLines = []  # The lines after @-leo
@@ -140,18 +134,15 @@
         at.lineNumber = 0  # New in Leo 4.4.8.
         at.out = None
         at.outStack = []
-        at.perfectImportRoot = perfectImportRoot
         at.read_i = 0
         at.read_lines = []
         at.readVersion = ''
             # New in Leo 4.8: "4" or "5" for new-style thin files.
         at.readVersion5 = False
-            # synonym for at.readVersion &gt;= '5' and not atShadow.
+            # synonym for at.readVersion &gt;= '5'
         at.root = root
         at.rootSeen = False
-        at.atShadow = atShadow
-        at.targetFileName = fileName
-            # For at.writeError only.
+        at.targetFileName = fileName  # For at.writeError only.
         at.tnodeList = []
             # Needed until old-style @file nodes are no longer supported.
         at.tnodeListIndex = 0
@@ -161,14 +152,7 @@
         at.thinNodeStack = []  # Entries are vnodes.
         at.updateWarningGiven = False
     #@+node:ekr.20041005105605.15: *4* at.initWriteIvars
-    def initWriteIvars(self, root, targetFileName,
-        atEdit=False,
-        atShadow=False,
-        defaultDirectory=None,
-        forcePythonSentinels=False,
-        kind=None,
-        sentinels=True,
-    ):
+    def initWriteIvars(self, root):
         """
         Compute default values of all write-related ivars.
         Return the finalized name of the output file.
@@ -180,32 +164,22 @@
         assert at.underindentEscapeString is not None
         #
         # Copy args
-        at.kind = kind
-        at.atEdit = atEdit
-            # Used only by putBody.
-        at.atShadow = atShadow
         at.root = root
-        at.sentinels = sentinels
+        at.sentinels = True
         #
         # Override initCommonIvars.
-        if forcePythonSentinels:
-            at.endSentinelComment = None
-            at.startSentinelComment = "#"
         if g.app.unitTesting:
             at.output_newline = '\n'
         #
         # Set other ivars.
-        at.force_newlines_in_at_nosent_bodies = c.config.getBool(
-            'force-newlines-in-at-nosent-bodies')
+        at.force_newlines_in_at_nosent_bodies = c.config.getBool('force-newlines-in-at-nosent-bodies')
             # For at.putBody only.
         at.outputList = []
             # For stream output.
-        targetFileName = os.path.expanduser(targetFileName or '')  # #1900.
-        at.targetFileName = targetFileName 
+        at.targetFileName = targetFileName = root.anyAtFileNodeName() or ''  # #1914.
             # For at.writeError only.
-        at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
+        d = at.scanAllDirectives(root)
             # Sets the following ivars:
-                # at.default_directory
                 # at.encoding
                 # at.explicitLineEnding
                 # at.language
@@ -214,8 +188,7 @@
                 # at.tab_width
         #
         # Overrides of at.scanAllDirectives...
-        if defaultDirectory:
-            at.default_directory = defaultDirectory
+        defaultDirectory = d.get('path')  # #1914
         if at.language == 'python':
             # Encoding directive overrides everything else.
             encoding = g.getPythonEncodingFromString(root.b)
@@ -231,12 +204,12 @@
         # Return the finalized file name.
         # #1341 and #1450.
         make_dirs = c and c.config and c.config.create_nonexistent_directories
-        if at.default_directory:
-            at.default_directory = c.expand_path_expression(at.default_directory)
+        if defaultDirectory:
+            defaultDirectory = c.expand_path_expression(defaultDirectory)
             if make_dirs:
-                ok = g.makeAllNonExistentDirectories(at.default_directory)
+                ok = g.makeAllNonExistentDirectories(defaultDirectory)
                 if not ok:
-                    g.error(f"Did not create default directory: {at.default_directory}")
+                    g.error(f"Did not create default directory: {defaultDirectory}")
                     return None
         # #1341 and #1450.
         targetFileName = c.expand_path_expression(targetFileName)
@@ -248,8 +221,7 @@
                     g.trace(f"Did not create {theDir} for {targetFileName}")
                     return None
         # #1341.
-        return g.os_path_realpath(
-            g.os_path_finalize_join(at.default_directory, targetFileName))
+        return g.os_path_realpath(g.os_path_finalize_join(defaultDirectory, targetFileName))
     #@+node:ekr.20041005105605.17: *3* at.Reading
     #@+node:ekr.20041005105605.18: *4* at.Reading (top level)
     #@+node:ekr.20070919133659: *5* at.checkExternalFile
@@ -280,8 +252,9 @@
         This will be the private file for @shadow nodes.
         """
         at, c = self, self.c
+        is_at_shadow = self.root.isAtShadowFileNode()
         if fromString:
-            if at.atShadow:
+            if is_at_shadow:
                 return at.error(
                     'can not call at.read from string for @shadow files')
             at.initReadLine(fromString)
@@ -292,7 +265,7 @@
             # Returns full path, including file name.
         at.setPathUa(at.root, fn)
             # Remember the full path to this node.
-        if at.atShadow:
+        if is_at_shadow:
             fn = at.openAtShadowFileForReading(fn)
             if not fn:
                 return None, None
@@ -328,9 +301,7 @@
         x.updatePublicAndPrivateFiles(at.root, fn, shadow_fn)
         return shadow_fn
     #@+node:ekr.20041005105605.21: *5* at.read &amp; helpers
-    def read(self, root, importFileName=None,
-        fromString=None, atShadow=False, force=False
-    ):
+    def read(self, root, fromString=None):
         """Read an @thin or @file tree."""
         at, c = self, self.c
         fileName = g.fullPath(c, root)  # #1341. #1889.
@@ -340,8 +311,7 @@
         at.rememberReadPath(g.fullPath(c, root), root)
             # Fix bug 760531: always mark the root as read, even if there was an error.
             # Fix bug 889175: Remember the full fileName.
-        at.initReadIvars(root, fileName,
-            importFileName=importFileName, atShadow=atShadow)
+        at.initReadIvars(root, fileName)
         at.fromString = fromString
         if at.errors:
             return False
@@ -356,9 +326,8 @@
         elif not fileName and not fromString and not file_s:
             return False
         root.clearVisitedInTree()
-        at.scanAllDirectives(root, importing=at.importing, reading=True)
+        at.scanAllDirectives(root)
             # Sets the following ivars:
-                # at.default_directory
                 # at.encoding: **changed later** by readOpenFile/at.scanHeader.
                 # at.explicitLineEnding
                 # at.language
@@ -516,9 +485,9 @@
         '''Read the @&lt;file&gt; node at p.'''
         at, c, fileName = self, self.c, p.anyAtFileNodeName()
         if p.isAtThinFileNode() or p.isAtFileNode():
-            at.read(p, force=force)
+            at.read(p)
         elif p.isAtAutoNode():
-            at.readOneAtAutoNode(fileName, p)
+            at.readOneAtAutoNode(p)
         elif p.isAtEditNode():
             at.readOneAtEditNode(fileName, p)
         elif p.isAtShadowFileNode():
@@ -541,12 +510,10 @@
             else:
                 p.moveToThreadNext()
     #@+node:ekr.20070909100252: *5* at.readOneAtAutoNode
-    def readOneAtAutoNode(self, fileName, p):
+    def readOneAtAutoNode(self, p):
         '''Read an @auto file into p. Return the *new* position.'''
         at, c, ic = self, self.c, self.c.importCommands
-        # #1521 &amp; #1341.
-        fileName = g.fullPath(c, p)
-        at.default_directory = g.os_path_dirname(fileName)
+        fileName = g.fullPath(c, p)  # #1521, #1341, #1914.
         if not g.os_path_exists(fileName):
             g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
             return p
@@ -557,15 +524,10 @@
         try:
             # For #451: return p.
             old_p = p.copy()
-            at.scanAllDirectives(
-                p,
-                forcePythonSentinels=False,
-                importing=True,
-                reading=True,
-            )
+            at.scanAllDirectives(p)
             p.v.b = ''  # Required for @auto API checks.
             p.v._deleteAllChildren()
-            p = ic.createOutline(fileName, parent=p.copy())
+            p = ic.createOutline(parent=p.copy())
             # Do *not* select a postion here.
             # That would improperly expand nodes.
                 # c.selectPosition(p)
@@ -591,7 +553,6 @@
         ic = c.importCommands
         # #1521
         fn = g.fullPath(c, p)
-        at.default_directory = g.os_path_dirname(fn)
         junk, ext = g.os_path_splitext(fn)
         # Fix bug 889175: Remember the full fileName.
         at.rememberReadPath(fn, p)
@@ -620,7 +581,6 @@
         at, c = self, self.c
         # #1521 &amp; #1341.
         fn = g.fullPath(c, p)
-        at.default_directory = g.os_path_dirname(fn)
         junk, ext = g.os_path_splitext(fn)
         # Remember the full fileName.
         at.rememberReadPath(fn, p)
@@ -711,9 +671,7 @@
                 f"can not happen: fn: {fn} != atShadowNodeName: "
                 f"{p.atShadowFileNodeName()}")
             return
-        # #1521 &amp; #1341.
-        fn = g.fullPath(c, p)
-        at.default_directory = g.os_path_dirname(fn)
+        fn = g.fullPath(c, p)  # #1521 &amp; #1341.
         # #889175: Remember the full fileName.
         at.rememberReadPath(fn, p)
         shadow_fn = x.shadowPathName(fn)
@@ -722,29 +680,32 @@
         while p.hasChildren():
             p.firstChild().doDelete()
         if shadow_exists:
-            at.read(p, atShadow=True, force=force)
+            at.read(p)
         else:
-            ok = at.importAtShadowNode(fn, p)
+            ok = at.importAtShadowNode(p)
             if ok:
                 # Create the private file automatically.
                 at.writeOneAtShadowNode(p)
     #@+node:ekr.20080712080505.1: *6* at.importAtShadowNode
-    def importAtShadowNode(self, fn, p):
-        at = self; c = at.c; ic = c.importCommands
+    def importAtShadowNode(self, p):
+        c, ic =self.c, self.c.importCommands
+        fn = g.fullPath(c, p)  # #1521, #1341, #1914.
+        if not g.os_path_exists(fn):
+            g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
+            return p
         # Delete all the child nodes.
         while p.hasChildren():
             p.firstChild().doDelete()
         # Import the outline, exactly as @auto does.
-        ic.createOutline(fn, parent=p.copy(), atShadow=True)
+        ic.createOutline(parent=p.copy())
         if ic.errors:
             g.error('errors inhibited read @shadow', fn)
         if ic.errors or not g.os_path_exists(fn):
             p.clearDirty()
-        # else: g.doHook('after-shadow', p = p)
         return ic.errors == 0
     #@+node:ekr.20180622110112.1: *4* at.fast_read_into_root
     def fast_read_into_root(self, c, contents, gnx2vnode, path, root):
-        """A convenience wrapper for FastAtReAD.read_into_root()"""
+        """A convenience wrapper for FastAtRead.read_into_root()"""
         return FastAtRead(c, gnx2vnode).read_into_root(contents, path, root)
     #@+node:ekr.20041005105605.116: *4* at.Reading utils...
     #@+node:ekr.20041005105605.119: *5* at.createImportedNode
@@ -985,6 +946,32 @@
         c.init_error_dialogs()
         at.writeAtAutoNodesHelper(writeDirtyOnly=True)
         c.raise_error_dialogs(kind='write')
+    #@+node:ekr.20190109163934.24: *7* at.writeAtAutoNodesHelper
+    def writeAtAutoNodesHelper(self, writeDirtyOnly=True):
+        """Write @auto nodes in the selected outline"""
+        at = self; c = at.c
+        p = c.p; after = p.nodeAfterTree()
+        found = False
+        while p and p != after:
+            if (
+                p.isAtAutoNode() and not p.isAtIgnoreNode() and
+                (p.isDirty() or not writeDirtyOnly)
+            ):
+                ok = at.writeOneAtAutoNode(p)
+                if ok:
+                    found = True
+                    p.moveToNodeAfterTree()
+                else:
+                    p.moveToThreadNext()
+            else:
+                p.moveToThreadNext()
+        if not g.unitTesting:
+            if found:
+                g.es("finished")
+            elif writeDirtyOnly:
+                g.es("no dirty @auto nodes in the selected tree")
+            else:
+                g.es("no @auto nodes in the selected tree")
     #@+node:ekr.20080711093251.3: *6* at.writeAtShadowNodes &amp; writeDirtyAtShadowNodes &amp; helpers
     @cmd('write-at-shadow-nodes')
     def writeAtShadowNodes(self, event=None):
@@ -1177,22 +1164,23 @@
             at.writePathChanged(p)
         except IOError:
             return
-        # Tricky: @ignore not recognised in @asis nodes.
-        if p.isAtAsisFileNode():
-            at.asisWrite(p)
-        elif p.isAtAutoNode():
-            at.writeOneAtAutoNode(p)
-            # Do *not* clear the dirty bits the entries in @persistence tree here!
-        elif p.isAtCleanNode():
-            at.write('@clean', p, sentinels=False)
-        elif p.isAtNoSentFileNode():
-            at.write('@nosent', p, sentinels=False)
-        elif p.isAtEditNode():
-            at.writeOneAtEditNode(p)
-        elif p.isAtShadowFileNode():
-            at.writeOneAtShadowNode(p)
-        elif p.isAtThinFileNode() or p.isAtFileNode():
-            at.write('@file', p)
+        table = (
+            (p.isAtAsisFileNode, at.asisWrite),
+            (p.isAtAutoNode, at.writeOneAtAutoNode),
+            (p.isAtCleanNode, at.writeOneAtCleanNode),
+            (p.isAtEditNode, at.writeOneAtEditNode),
+            (p.isAtFileNode, at.writeOneAtFileNode),
+            (p.isAtNoSentFileNode, at.writeOneAtNosentNode),
+            (p.isAtShadowFileNode, at.writeOneAtShadowNode),
+            (p.isAtThinFileNode, at.writeOneAtFileNode),
+        )
+        for pred, func in table:
+            if pred():
+                func(p)
+                break
+        else:
+            g.trace(f"Can not happen: {p.h}")
+            return
         #
         # Clear the dirty bits in all descendant nodes.
         # The persistence data may still have to be written.
@@ -1262,7 +1250,7 @@
         try:
             c.endEditing()
             c.init_error_dialogs()
-            fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
+            fileName = at.initWriteIvars(root)
             # #1450.
             if not fileName or not at.precheck(fileName, root):
                 at.addToOrphanList(root)
@@ -1301,45 +1289,13 @@
         s = p.b
         if s:
             put(s)
-    #@+node:ekr.20041005105605.144: *6* at.write
-    def write(self, kind, root, sentinels=True):
-        """Write a 4.x derived file.
-        root is the position of an @&lt;file&gt; node.
-        sentinels will be False for @clean and @nosent nodes.
-        """
-        at, c = self, self.c
-        try:
-            c.endEditing()
-            fileName = at.initWriteIvars(
-                root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
-            if not fileName or not at.precheck(fileName, root):
-                if sentinels:
-                    # Raise dialog warning of data loss.
-                    at.addToOrphanList(root)
-                else:
-                    # #1450: No danger of data loss.
-                    pass
-                return
-            at.outputList = []
-            at.putFile(root, sentinels=sentinels)
-            at.warnAboutOrphandAndIgnoredNodes()
-            if at.errors:
-                g.es("not written:", g.shortFileName(fileName))
-                at.addToOrphanList(root)
-            else:
-                contents = ''.join(at.outputList)
-                at.replaceFile(contents, at.encoding, fileName, root)
-        except Exception:
-            if hasattr(self.root.v, 'tnodeList'):
-                delattr(self.root.v, 'tnodeList')
-            at.writeException(fileName, root)
     #@+node:ekr.20041005105605.151: *6* at.writeMissing &amp; helper
     def writeMissing(self, p):
         at, c = self, self.c
         writtenFiles = False
         c.init_error_dialogs()
         # #1450.
-        at.initWriteIvars(root=p.copy(), targetFileName='')
+        at.initWriteIvars(root=p.copy())
         p = p.copy()
         after = p.nodeAfterTree()
         while p and p != after:  # Don't use iterator.
@@ -1348,9 +1304,7 @@
             ):
                 fileName = p.anyAtFileNodeName()
                 if fileName:
-                    fileName = c.expand_path_expression(fileName)  # #1341
-                    fileName = g.os_path_finalize_join(
-                        at.default_directory, fileName)  # #1341
+                    fileName = g.fullPath(c, p)  # #1914.
                     if at.precheck(fileName, p):
                         at.writeMissingNode(p)
                         writtenFiles = True
@@ -1371,16 +1325,21 @@
     def writeMissingNode(self, p):
 
         at = self
-        if p.isAtAsisFileNode():
-            at.asisWrite(p)
-        elif p.isAtNoSentFileNode():
-            at.write('@nosent', p, sentinels=False)
-        elif p.isAtFileNode():
-            at.write('@file', p)
-        elif p.isAtAutoNode() or p.isAtAutoRstNode():
-            g.es('Can not write missing @auto node', p.h, color='red')
-        else:
-            g.trace('can not happen: unknown @file node')
+        table = (
+            (p.isAtAsisFileNode, at.asisWrite),
+            (p.isAtAutoNode, at.writeOneAtAutoNode),
+            (p.isAtCleanNode, at.writeOneAtCleanNode),
+            (p.isAtEditNode, at.writeOneAtEditNode),
+            (p.isAtFileNode, at.writeOneAtFileNode),
+            (p.isAtNoSentFileNode, at.writeOneAtNosentNode),
+            (p.isAtShadowFileNode, at.writeOneAtShadowNode),
+            (p.isAtThinFileNode, at.writeOneAtFileNode),
+        )
+        for pred, func in table:
+            if pred():
+                func(p)
+                return
+        g.trace(f"Can not happen unknown @&lt;file&gt; kind: {p.h}")
     #@+node:ekr.20070806141607: *6* at.writeOneAtAutoNode &amp; helpers
     def writeOneAtAutoNode(self, p):
         '''
@@ -1394,10 +1353,8 @@
             c.endEditing()
             if not p.atAutoNodeName():
                 return False
-            fileName = at.initWriteIvars(root, p.atAutoNodeName(),
-                defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
-                sentinels=False,
-            )
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
             # #1450.
             if not fileName or not at.precheck(fileName, root):
                 at.addToOrphanList(root)
@@ -1415,32 +1372,6 @@
         except Exception:
             at.writeException(fileName, root)
             return False
-    #@+node:ekr.20190109163934.24: *7* at.writeAtAutoNodesHelper
-    def writeAtAutoNodesHelper(self, writeDirtyOnly=True):
-        """Write @auto nodes in the selected outline"""
-        at = self; c = at.c
-        p = c.p; after = p.nodeAfterTree()
-        found = False
-        while p and p != after:
-            if (
-                p.isAtAutoNode() and not p.isAtIgnoreNode() and
-                (p.isDirty() or not writeDirtyOnly)
-            ):
-                ok = at.writeOneAtAutoNode(p)
-                if ok:
-                    found = True
-                    p.moveToNodeAfterTree()
-                else:
-                    p.moveToThreadNext()
-            else:
-                p.moveToThreadNext()
-        if not g.unitTesting:
-            if found:
-                g.es("finished")
-            elif writeDirtyOnly:
-                g.es("no dirty @auto nodes in the selected tree")
-            else:
-                g.es("no @auto nodes in the selected tree")
     #@+node:ekr.20140728040812.17993: *7* at.dispatch &amp; helpers
     def dispatch(self, ext, p):
         """Return the correct writer function for p, an @auto node."""
@@ -1486,6 +1417,31 @@
             return writer_for_ext_cb
 
         return None
+    #@+node:ekr.20210501064359.1: *6* at.writeOneAtCleanNode
+    def writeOneAtCleanNode(self, root):
+        """Write one @clean file..
+        root is the position of an @clean node.
+        """
+        at, c = self, self.c
+        try:
+            c.endEditing()
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
+            if not fileName or not at.precheck(fileName, root):
+                return
+            at.outputList = []
+            at.putFile(root, sentinels=False)
+            at.warnAboutOrphandAndIgnoredNodes()
+            if at.errors:
+                g.es("not written:", g.shortFileName(fileName))
+                at.addToOrphanList(root)
+            else:
+                contents = ''.join(at.outputList)
+                at.replaceFile(contents, at.encoding, fileName, root)
+        except Exception:
+            if hasattr(self.root.v, 'tnodeList'):
+                delattr(self.root.v, 'tnodeList')
+            at.writeException(fileName, root)
     #@+node:ekr.20090225080846.5: *6* at.writeOneAtEditNode
     def writeOneAtEditNode(self, p):
         '''Write one @edit node.'''
@@ -1500,11 +1456,8 @@
                 g.error('@edit nodes must not have children')
                 g.es('To save your work, convert @edit to @auto, @file or @clean')
                 return False
-            fileName = at.initWriteIvars(root, p.atEditNodeName(),
-                atEdit=True,
-                defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
-                sentinels=False,
-            )
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
             # #1450.
             if not fileName or not at.precheck(fileName, root):
                 at.addToOrphanList(root)
@@ -1517,6 +1470,57 @@
         except Exception:
             at.writeException(fileName, root)
             return False
+    #@+node:ekr.20210501075610.1: *6* at.writeOneAtFileNode
+    def writeOneAtFileNode(self, root):
+        """Write @file or @thin file."""
+        at, c = self, self.c
+        try:
+            c.endEditing()
+            fileName = at.initWriteIvars(root)
+            at.sentinels = True
+            if not fileName or not at.precheck(fileName, root):
+                # Raise dialog warning of data loss.
+                at.addToOrphanList(root)
+                return
+            at.outputList = []
+            at.putFile(root, sentinels=True)
+            at.warnAboutOrphandAndIgnoredNodes()
+            if at.errors:
+                g.es("not written:", g.shortFileName(fileName))
+                at.addToOrphanList(root)
+            else:
+                contents = ''.join(at.outputList)
+                at.replaceFile(contents, at.encoding, fileName, root)
+        except Exception:
+            if hasattr(self.root.v, 'tnodeList'):
+                delattr(self.root.v, 'tnodeList')
+            at.writeException(fileName, root)
+    #@+node:ekr.20210501065352.1: *6* at.writeOneAtNosentNode
+    def writeOneAtNosentNode(self, root):
+        """Write one @nosent node.
+        root is the position of an @&lt;file&gt; node.
+        sentinels will be False for @clean and @nosent nodes.
+        """
+        at, c = self, self.c
+        try:
+            c.endEditing()
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
+            if not fileName or not at.precheck(fileName, root):
+                return
+            at.outputList = []
+            at.putFile(root, sentinels=False)
+            at.warnAboutOrphandAndIgnoredNodes()
+            if at.errors:
+                g.es("not written:", g.shortFileName(fileName))
+                at.addToOrphanList(root)
+            else:
+                contents = ''.join(at.outputList)
+                at.replaceFile(contents, at.encoding, fileName, root)
+        except Exception:
+            if hasattr(self.root.v, 'tnodeList'):
+                delattr(self.root.v, 'tnodeList')
+            at.writeException(fileName, root)
     #@+node:ekr.20080711093251.5: *6* at.writeOneAtShadowNode &amp; helpers
     def writeOneAtShadowNode(self, p, testing=False):
         '''
@@ -1535,15 +1539,11 @@
             self.adjustTargetLanguage(fn)
                 # A hack to support unknown extensions. May set c.target_language.
             full_path = g.fullPath(c, p)
-            at.initWriteIvars(root, None,
-                atShadow=True,
-                defaultDirectory=g.os_path_dirname(full_path),
-                forcePythonSentinels=True,
-                    # Force python sentinels to suppress an error message.
-                    # The actual sentinels will be set below.
-            )
-            at.default_directory = g.os_path_dirname(full_path)
-                # Override.
+            at.initWriteIvars(root)
+            # Force python sentinels to suppress an error message.
+            # The actual sentinels will be set below.
+            at.endSentinelComment = None
+            at.startSentinelComment = "#"
             # Make sure we can compute the shadow directory.
             private_fn = x.shadowPathName(full_path)
             if not private_fn:
@@ -1612,7 +1612,7 @@
         at, c = self, self.c
         try:
             c.endEditing()
-            fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
+            fileName = at.initWriteIvars(root)
             at.outputList = []
             for p in root.self_and_subtree(copy=False):
                 at.writeAsisNode(p)
@@ -1626,7 +1626,8 @@
         at, c = self, self.c
         try:
             c.endEditing()
-            fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
             # #1450.
             if not fileName:
                 at.addToOrphanList(root)
@@ -1645,8 +1646,8 @@
                 g.error('@edit nodes must not have children')
                 g.es('To save your work, convert @edit to @auto, @file or @clean')
                 return False
-            fileName = at.initWriteIvars(
-                root, root.atEditNodeName(), atEdit=True, sentinels=False)
+            fileName = at.initWriteIvars(root)
+            at.sentinels = False
             # #1450.
             if not fileName:
                 at.addToOrphanList(root)
@@ -1664,7 +1665,8 @@
         at, c = self, self.c
         try:
             c.endEditing()
-            at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
+            at.initWriteIvars(root)
+            at.sentinels = sentinels
             at.outputList = []
             at.putFile(root, sentinels=sentinels)
             assert root == at.root, 'write'
@@ -1684,19 +1686,19 @@
     #@+node:ekr.20050506084734: *6* at.stringToString
     def stringToString(self, root, s, forcePythonSentinels=True, sentinels=True):
         """
-        Write a 4.x derived file from a string.
+        Write an external file from a string.
 
         This is at.write specialized for scripting.
         """
         at, c = self, self.c
         try:
             c.endEditing()
-            at.initWriteIvars(
-                root,
-                targetFileName="&lt;string-file&gt;",
-                forcePythonSentinels=forcePythonSentinels,
-                sentinels=sentinels,
-            )
+            at.initWriteIvars(root)
+            if forcePythonSentinels:
+                at.endSentinelComment = None
+                at.startSentinelComment = "#"
+                at.language = "python"
+            at.sentinels = sentinels
             at.outputList = []
             at.putFile(root, fromString=s, sentinels=sentinels)
             contents = '' if at.errors else ''.join(at.outputList)
@@ -1968,6 +1970,7 @@
         """Put a line containing one or more references."""
         at = self
         ref = at.findReference(name, p)
+        is_clean = at.root.h.startswith('@clean')
         if not ref:
             if hasattr(at, 'allow_undefined_refs'):
                 # Allow apparent section reference: just write the line.
@@ -1984,7 +1987,7 @@
             i = n2
             n_refs += 1
             name, n1, n2 = at.findSectionName(s, i)
-            if self.kind == '@clean' and n_refs &gt; 1:
+            if is_clean and n_refs &gt; 1:
                 # #1232: allow only one section reference per line in @clean.
                 i1, i2 = g.getLine(s, i)
                 line = s[i1:i2].rstrip()
@@ -2257,8 +2260,10 @@
     def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
         """Perform python-related checks on root."""
         at = self
-        if contents and fileName and fileName.endswith(
-            '.py') and at.checkPythonCodeOnWrite:
+        if (
+            contents and fileName and fileName.endswith('.py')
+            and at.checkPythonCodeOnWrite
+        ):
             # It's too slow to check each node separately.
             if pyflakes_errors_only:
                 ok = True
@@ -2929,103 +2934,64 @@
         aSet.add(p.h)
         d[fn] = aSet
     #@+node:ekr.20080923070954.4: *4* at.scanAllDirectives
-    def scanAllDirectives(self,
-        p,
-        forcePythonSentinels=False,
-        importing=False,
-        issuePathWarning=False,
-        reading=False,
-    ):
+    def scanAllDirectives(self, p):
         '''
         Scan p and p's ancestors looking for directives,
         setting corresponding AtFile ivars.
         '''
         at, c = self, self.c
-        g.app.atPathInBodyWarning = None
-        #@+&lt;&lt; set ivars &gt;&gt;
-        #@+node:ekr.20080923070954.14: *5* &lt;&lt; Set ivars &gt;&gt; (at.scanAllDirectives)
-        at.page_width = c.page_width
-        at.tab_width = c.tab_width
-        at.default_directory = None  # 8/2: will be set later.
-        if c.target_language:
-            c.target_language = c.target_language.lower()
-        delims = g.set_delims_from_language(c.target_language)
-        at.language = c.target_language
-        at.encoding = c.config.default_derived_file_encoding
-        at.output_newline = g.getOutputNewline(c=c)  # Init from config settings.
-        #@-&lt;&lt; set ivars &gt;&gt;
-        lang_dict = {'language': at.language, 'delims': delims,}
-        table = (
-            ('encoding', at.encoding, g.scanAtEncodingDirectives),
-            # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
-            ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
-            ('lineending', None, g.scanAtLineendingDirectives),
-            ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
-            ('path', None, c.scanAtPathDirectives),
-            ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
-        )
-        # Set d by scanning all directives.
-        aList = g.get_directives_dict_list(p)
-        d = {}
-        for key, default, func in table:
-            val = func(aList)
-            d[key] = default if val is None else val
-        # Post process.
-        lineending = d.get('lineending')
-        lang_dict = d.get('lang-dict')
+        d = c.scanAllDirectives(p)
+        #
+        # Language &amp; delims: Do *not* use the default language returned by c.scanAllDirectives.
+        lang_dict = d.get('lang-dict') or {}
         if lang_dict:
             delims = lang_dict.get('delims')
-            at.language = lang_dict.get('language')
+            language = lang_dict.get('language')
         else:
             # No language directive.  Look for @&lt;file&gt; nodes.
+            language = d.get('language')
+            delims = g.set_delims_from_language(language)
+        if not language:  # Defensive code.
             language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
-            delims = g.set_delims_from_language(language)
-        at.encoding = d.get('encoding')
+        at.language = language
+        #@+&lt;&lt; Set comment strings from delims &gt;&gt;
+        #@+node:ekr.20080923070954.13: *5* &lt;&lt; Set comment strings from delims &gt;&gt; (at.scanAllDirectives)
+        delim1, delim2, delim3 = delims
+        # Use single-line comments if we have a choice.
+        # delim1,delim2,delim3 now correspond to line,start,end
+        if delim1:
+            at.startSentinelComment = delim1
+            at.endSentinelComment = ""  # Must not be None.
+        elif delim2 and delim3:
+            at.startSentinelComment = delim2
+            at.endSentinelComment = delim3
+        else:  # Emergency!
+            #
+            # Issue an error only if at.language has been set.
+            # This suppresses a message from the markdown importer.
+            if not g.app.unitTesting and at.language:
+                g.trace(repr(at.language), g.callers())
+                g.es_print("unknown language: using Python comment delimiters")
+                g.es_print("c.target_language:", c.target_language)
+            at.startSentinelComment = "#"  # This should never happen!
+            at.endSentinelComment = ""
+        #@-&lt;&lt; Set comment strings from delims &gt;&gt;
+        #
+        # Easy cases
+        at.encoding = d.get('encoding') or c.config.default_derived_file_encoding
+        lineending = d.get('lineending')
         at.explicitLineEnding = bool(lineending)
         at.output_newline = lineending or g.getOutputNewline(c=c)
-        at.page_width = d.get('pagewidth')
-        at.default_directory = d.get('path')
-        at.tab_width = d.get('tabwidth')
-        if not importing and not reading:
-            # Don't override comment delims when reading!
-            #@+&lt;&lt; set comment strings from delims &gt;&gt;
-            #@+node:ekr.20080923070954.13: *5* &lt;&lt; Set comment strings from delims &gt;&gt; (at.scanAllDirectives)
-            if forcePythonSentinels:
-                # Force Python language.
-                delim1, delim2, delim3 = g.set_delims_from_language("python")
-                self.language = "python"
-            else:
-                delim1, delim2, delim3 = delims
-            # Use single-line comments if we have a choice.
-            # delim1,delim2,delim3 now correspond to line,start,end
-            if delim1:
-                at.startSentinelComment = delim1
-                at.endSentinelComment = ""  # Must not be None.
-            elif delim2 and delim3:
-                at.startSentinelComment = delim2
-                at.endSentinelComment = delim3
-            else:  # Emergency!
-                #
-                # Issue an error only if at.language has been set.
-                # This suppresses a message from the markdown importer.
-                if not g.app.unitTesting and at.language:
-                    g.trace(repr(at.language), g.callers())
-                    g.es_print("unknown language: using Python comment delimiters")
-                    g.es_print("c.target_language:", c.target_language)
-                at.startSentinelComment = "#"  # This should never happen!
-                at.endSentinelComment = ""
-            #@-&lt;&lt; set comment strings from delims &gt;&gt;
-        # For unit testing.
-        d = {
-            "all": all,
+        at.page_width = d.get('pagewidth') or c.page_width
+        at.tab_width = d.get('tabwidth') or c.tab_width
+        return {
             "encoding": at.encoding,
             "language": at.language,
             "lineending": at.output_newline,
             "pagewidth": at.page_width,
-            "path": at.default_directory,
+            "path": d.get('path'),
             "tabwidth": at.tab_width,
         }
-        return d
     #@+node:ekr.20120110174009.9965: *4* at.shouldPromptForDangerousWrite
     def shouldPromptForDangerousWrite(self, fn, p):
         '''
@language python
</t>
<t tx="ekr.20210502131534.10"></t>
<t tx="ekr.20210502131534.11">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -7,7 +7,6 @@
     at = self
     c = at.c
     at.at_auto_encoding = c.config.default_at_auto_file_encoding
-    at.default_directory = None
     at.encoding = c.config.default_derived_file_encoding
     at.endSentinelComment = ""
     at.errors = 0
@language python
</t>
<t tx="ekr.20210502131534.12">def initCommonIvars(self):
    """
    Init ivars common to both reading and writing.

    The defaults set here may be changed later.
    """
    at = self
    c = at.c
    at.at_auto_encoding = c.config.default_at_auto_file_encoding
    at.default_directory = None
    at.encoding = c.config.default_derived_file_encoding
    at.endSentinelComment = ""
    at.errors = 0
    at.inCode = True
    at.indent = 0  # The unit of indentation is spaces, not tabs.
    at.language = None
    at.output_newline = g.getOutputNewline(c=c)
    at.page_width = None
    at.raw = False  # True: in @raw mode
    at.root = None  # The root (a position) of tree being read or written.
    at.startSentinelComment = ""
    at.startSentinelComment = ""
    at.tab_width = c.tab_width or -4
    at.writing_to_shadow_directory = False
</t>
<t tx="ekr.20210502131534.13">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,8 +1,4 @@
-def initReadIvars(self, root, fileName,
-    importFileName=None,
-    perfectImportRoot=None,
-    atShadow=False,
-):
+def initReadIvars(self, root, fileName):
     at = self
     at.initCommonIvars()
     at.bom_encoding = None
@@ -24,7 +20,6 @@
     at.endSentinelNodeStack = []
         # Used only when readVersion5.
     at.fromString = False
-    at.importing = bool(importFileName)
     at.importRootSeen = False
     at.indentStack = []
     at.lastLines = []  # The lines after @-leo
@@ -39,18 +34,15 @@
     at.lineNumber = 0  # New in Leo 4.4.8.
     at.out = None
     at.outStack = []
-    at.perfectImportRoot = perfectImportRoot
     at.read_i = 0
     at.read_lines = []
     at.readVersion = ''
         # New in Leo 4.8: "4" or "5" for new-style thin files.
     at.readVersion5 = False
-        # synonym for at.readVersion &gt;= '5' and not atShadow.
+        # synonym for at.readVersion &gt;= '5'
     at.root = root
     at.rootSeen = False
-    at.atShadow = atShadow
-    at.targetFileName = fileName
-        # For at.writeError only.
+    at.targetFileName = fileName  # For at.writeError only.
     at.tnodeList = []
         # Needed until old-style @file nodes are no longer supported.
     at.tnodeListIndex = 0
@language python
</t>
<t tx="ekr.20210502131534.14">def initReadIvars(self, root, fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):
    at = self
    at.initCommonIvars()
    at.bom_encoding = None
        # The encoding implied by any BOM (set by g.stripBOM)
    at.cloneSibCount = 0
        # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
    at.correctedLines = 0
        # For perfect import.
    at.docOut = []  # The doc part being accumulated.
    at.done = False  # True when @-leo seen.
    at.endSentinelIndentStack = []
        # Restored indentation for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelStack = []
        # Contains entries for +node sentinels only when not readVersion5
    at.endSentinelLevelStack = []
        # The saved level, len(at.thinNodeStack), for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelNodeStack = []
        # Used only when readVersion5.
    at.fromString = False
    at.importing = bool(importFileName)
    at.importRootSeen = False
    at.indentStack = []
    at.lastLines = []  # The lines after @-leo
    at.lastRefNode = None
        # The previous reference node, for at.readAfterRef.
        # No stack is needed because -&lt;&lt; sentinels restore at.v
        # to the node needed by at.readAfterRef.
    at.lastThinNode = None
        # The last thin node at this level.
        # Used by createThinChild4.
    at.leadingWs = ""
    at.lineNumber = 0  # New in Leo 4.4.8.
    at.out = None
    at.outStack = []
    at.perfectImportRoot = perfectImportRoot
    at.read_i = 0
    at.read_lines = []
    at.readVersion = ''
        # New in Leo 4.8: "4" or "5" for new-style thin files.
    at.readVersion5 = False
        # synonym for at.readVersion &gt;= '5' and not atShadow.
    at.root = root
    at.rootSeen = False
    at.atShadow = atShadow
    at.targetFileName = fileName
        # For at.writeError only.
    at.tnodeList = []
        # Needed until old-style @file nodes are no longer supported.
    at.tnodeListIndex = 0
    at.v = None
    at.vStack = []  # Stack of at.v values.
    at.thinChildIndexStack = []  # number of siblings at this level.
    at.thinNodeStack = []  # Entries are vnodes.
    at.updateWarningGiven = False
</t>
<t tx="ekr.20210502131534.15">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,11 +1,4 @@
-def initWriteIvars(self, root, targetFileName,
-    atEdit=False,
-    atShadow=False,
-    defaultDirectory=None,
-    forcePythonSentinels=False,
-    kind=None,
-    sentinels=True,
-):
+def initWriteIvars(self, root):
     """
     Compute default values of all write-related ivars.
     Return the finalized name of the output file.
@@ -17,32 +10,22 @@
     assert at.underindentEscapeString is not None
     #
     # Copy args
-    at.kind = kind
-    at.atEdit = atEdit
-        # Used only by putBody.
-    at.atShadow = atShadow
     at.root = root
-    at.sentinels = sentinels
+    at.sentinels = True
     #
     # Override initCommonIvars.
-    if forcePythonSentinels:
-        at.endSentinelComment = None
-        at.startSentinelComment = "#"
     if g.app.unitTesting:
         at.output_newline = '\n'
     #
     # Set other ivars.
-    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
-        'force-newlines-in-at-nosent-bodies')
+    at.force_newlines_in_at_nosent_bodies = c.config.getBool('force-newlines-in-at-nosent-bodies')
         # For at.putBody only.
     at.outputList = []
         # For stream output.
-    targetFileName = os.path.expanduser(targetFileName or '')  # #1900.
-    at.targetFileName = targetFileName 
+    at.targetFileName = targetFileName = root.anyAtFileNodeName() or ''  # #1914.
         # For at.writeError only.
-    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
+    d = at.scanAllDirectives(root)
         # Sets the following ivars:
-            # at.default_directory
             # at.encoding
             # at.explicitLineEnding
             # at.language
@@ -51,8 +34,7 @@
             # at.tab_width
     #
     # Overrides of at.scanAllDirectives...
-    if defaultDirectory:
-        at.default_directory = defaultDirectory
+    defaultDirectory = d.get('path')  # #1914
     if at.language == 'python':
         # Encoding directive overrides everything else.
         encoding = g.getPythonEncodingFromString(root.b)
@@ -68,12 +50,12 @@
     # Return the finalized file name.
     # #1341 and #1450.
     make_dirs = c and c.config and c.config.create_nonexistent_directories
-    if at.default_directory:
-        at.default_directory = c.expand_path_expression(at.default_directory)
+    if defaultDirectory:
+        defaultDirectory = c.expand_path_expression(defaultDirectory)
         if make_dirs:
-            ok = g.makeAllNonExistentDirectories(at.default_directory)
+            ok = g.makeAllNonExistentDirectories(defaultDirectory)
             if not ok:
-                g.error(f"Did not create default directory: {at.default_directory}")
+                g.error(f"Did not create default directory: {defaultDirectory}")
                 return None
     # #1341 and #1450.
     targetFileName = c.expand_path_expression(targetFileName)
@@ -85,5 +67,4 @@
                 g.trace(f"Did not create {theDir} for {targetFileName}")
                 return None
     # #1341.
-    return g.os_path_realpath(
-        g.os_path_finalize_join(at.default_directory, targetFileName))
+    return g.os_path_realpath(g.os_path_finalize_join(defaultDirectory, targetFileName))
@language python
</t>
<t tx="ekr.20210502131534.16">def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory=None,
    forcePythonSentinels=False,
    kind=None,
    sentinels=True,
):
    """
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    """
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.kind = kind
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.outputList = []
        # For stream output.
    targetFileName = os.path.expanduser(targetFileName or '')  # #1900.
    at.targetFileName = targetFileName 
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    # #1341 and #1450.
    make_dirs = c and c.config and c.config.create_nonexistent_directories
    if at.default_directory:
        at.default_directory = c.expand_path_expression(at.default_directory)
        if make_dirs:
            ok = g.makeAllNonExistentDirectories(at.default_directory)
            if not ok:
                g.error(f"Did not create default directory: {at.default_directory}")
                return None
    # #1341 and #1450.
    targetFileName = c.expand_path_expression(targetFileName)
    if targetFileName:
        theDir = g.os_path_dirname(targetFileName)
        if theDir and make_dirs:
            ok = g.makeAllNonExistentDirectories(theDir)
            if not ok:
                g.trace(f"Did not create {theDir} for {targetFileName}")
                return None
    # #1341.
    return g.os_path_realpath(
        g.os_path_finalize_join(at.default_directory, targetFileName))
</t>
<t tx="ekr.20210502131534.17">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -4,8 +4,9 @@
     This will be the private file for @shadow nodes.
     """
     at, c = self, self.c
+    is_at_shadow = self.root.isAtShadowFileNode()
     if fromString:
-        if at.atShadow:
+        if is_at_shadow:
             return at.error(
                 'can not call at.read from string for @shadow files')
         at.initReadLine(fromString)
@@ -16,7 +17,7 @@
         # Returns full path, including file name.
     at.setPathUa(at.root, fn)
         # Remember the full path to this node.
-    if at.atShadow:
+    if is_at_shadow:
         fn = at.openAtShadowFileForReading(fn)
         if not fn:
             return None, None
@language python
</t>
<t tx="ekr.20210502131534.18">def openFileForReading(self, fromString=False):
    """
    Open the file given by at.root.
    This will be the private file for @shadow nodes.
    """
    at, c = self, self.c
    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.initReadLine(fromString)
        return None, None
    #
    # Not from a string. Carefully read the file.
    fn = g.fullPath(c, at.root)
        # Returns full path, including file name.
    at.setPathUa(at.root, fn)
        # Remember the full path to this node.
    if at.atShadow:
        fn = at.openAtShadowFileForReading(fn)
        if not fn:
            return None, None
    assert fn
    try:
        s = at.readFileToUnicode(fn)
            # Sets at.encoding, regularizes whitespace and calls at.initReadLines.
        # #1466.
        if s is None:
            # The error has been given.
            at._file_bytes = g.toEncodedString('')
            return None, None
        at.warnOnReadOnlyFile(fn)
    except Exception:
        at.error(f"unexpected exception opening: '@file {fn}'")
        at._file_bytes = g.toEncodedString('')
        fn, s = None, None
    return fn, s
</t>
<t tx="ekr.20210502131534.19">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,6 +1,4 @@
-def read(self, root, importFileName=None,
-    fromString=None, atShadow=False, force=False
-):
+def read(self, root, fromString=None):
     """Read an @thin or @file tree."""
     at, c = self, self.c
     fileName = g.fullPath(c, root)  # #1341. #1889.
@@ -10,8 +8,7 @@
     at.rememberReadPath(g.fullPath(c, root), root)
         # Fix bug 760531: always mark the root as read, even if there was an error.
         # Fix bug 889175: Remember the full fileName.
-    at.initReadIvars(root, fileName,
-        importFileName=importFileName, atShadow=atShadow)
+    at.initReadIvars(root, fileName)
     at.fromString = fromString
     if at.errors:
         return False
@@ -26,9 +23,8 @@
     elif not fileName and not fromString and not file_s:
         return False
     root.clearVisitedInTree()
-    at.scanAllDirectives(root, importing=at.importing, reading=True)
+    at.scanAllDirectives(root)
         # Sets the following ivars:
-            # at.default_directory
             # at.encoding: **changed later** by readOpenFile/at.scanHeader.
             # at.explicitLineEnding
             # at.language
@language python
</t>
<t tx="ekr.20210502131534.20">def read(self, root, importFileName=None,
    fromString=None, atShadow=False, force=False
):
    """Read an @thin or @file tree."""
    at, c = self, self.c
    fileName = g.fullPath(c, root)  # #1341. #1889.
    if not fileName:
        at.error("Missing file name. Restoring @file tree from .leo file.")
        return False
    at.rememberReadPath(g.fullPath(c, root), root)
        # Fix bug 760531: always mark the root as read, even if there was an error.
        # Fix bug 889175: Remember the full fileName.
    at.initReadIvars(root, fileName,
        importFileName=importFileName, atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        return False
    fileName, file_s = at.openFileForReading(fromString=fromString)
    # #1798:
    if file_s is None:
        return False
    #
    # Set the time stamp.
    if fileName:
        c.setFileTimeStamp(fileName)
    elif not fileName and not fromString and not file_s:
        return False
    root.clearVisitedInTree()
    at.scanAllDirectives(root, importing=at.importing, reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **changed later** by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    gnx2vnode = c.fileCommands.gnxDict
    contents = fromString or file_s
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    root.clearDirty()
    return True
</t>
<t tx="ekr.20210502131534.21">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -2,9 +2,9 @@
     '''Read the @&lt;file&gt; node at p.'''
     at, c, fileName = self, self.c, p.anyAtFileNodeName()
     if p.isAtThinFileNode() or p.isAtFileNode():
-        at.read(p, force=force)
+        at.read(p)
     elif p.isAtAutoNode():
-        at.readOneAtAutoNode(fileName, p)
+        at.readOneAtAutoNode(p)
     elif p.isAtEditNode():
         at.readOneAtEditNode(fileName, p)
     elif p.isAtShadowFileNode():
@language python
</t>
<t tx="ekr.20210502131534.22">def readFileAtPosition(self, force, p):
    '''Read the @&lt;file&gt; node at p.'''
    at, c, fileName = self, self.c, p.anyAtFileNodeName()
    if p.isAtThinFileNode() or p.isAtFileNode():
        at.read(p, force=force)
    elif p.isAtAutoNode():
        at.readOneAtAutoNode(fileName, p)
    elif p.isAtEditNode():
        at.readOneAtEditNode(fileName, p)
    elif p.isAtShadowFileNode():
        at.readOneAtShadowNode(fileName, p)
    elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        at.rememberReadPath(g.fullPath(c, p), p)
    elif p.isAtCleanNode():
        at.readOneAtCleanNode(p)
</t>
<t tx="ekr.20210502131534.23">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,9 +1,7 @@
-def readOneAtAutoNode(self, fileName, p):
+def readOneAtAutoNode(self, p):
     '''Read an @auto file into p. Return the *new* position.'''
     at, c, ic = self, self.c, self.c.importCommands
-    # #1521 &amp; #1341.
-    fileName = g.fullPath(c, p)
-    at.default_directory = g.os_path_dirname(fileName)
+    fileName = g.fullPath(c, p)  # #1521, #1341, #1914.
     if not g.os_path_exists(fileName):
         g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
         return p
@@ -14,15 +12,10 @@
     try:
         # For #451: return p.
         old_p = p.copy()
-        at.scanAllDirectives(
-            p,
-            forcePythonSentinels=False,
-            importing=True,
-            reading=True,
-        )
+        at.scanAllDirectives(p)
         p.v.b = ''  # Required for @auto API checks.
         p.v._deleteAllChildren()
-        p = ic.createOutline(fileName, parent=p.copy())
+        p = ic.createOutline(parent=p.copy())
         # Do *not* select a postion here.
         # That would improperly expand nodes.
             # c.selectPosition(p)
@language python
</t>
<t tx="ekr.20210502131534.24">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 &amp; #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20210502131534.25">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -4,7 +4,6 @@
     ic = c.importCommands
     # #1521
     fn = g.fullPath(c, p)
-    at.default_directory = g.os_path_dirname(fn)
     junk, ext = g.os_path_splitext(fn)
     # Fix bug 889175: Remember the full fileName.
     at.rememberReadPath(fn, p)
@language python
</t>
<t tx="ekr.20210502131534.26">def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    # #1521
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors='True')
    g.doHook('after-edit', p=p)
</t>
<t tx="ekr.20210502131534.27">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,6 @@
     at, c = self, self.c
     # #1521 &amp; #1341.
     fn = g.fullPath(c, p)
-    at.default_directory = g.os_path_dirname(fn)
     junk, ext = g.os_path_splitext(fn)
     # Remember the full fileName.
     at.rememberReadPath(fn, p)
@language python
</t>
<t tx="ekr.20210502131534.28">def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
</t>
<t tx="ekr.20210502131534.29">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -6,9 +6,7 @@
             f"can not happen: fn: {fn} != atShadowNodeName: "
             f"{p.atShadowFileNodeName()}")
         return
-    # #1521 &amp; #1341.
-    fn = g.fullPath(c, p)
-    at.default_directory = g.os_path_dirname(fn)
+    fn = g.fullPath(c, p)  # #1521 &amp; #1341.
     # #889175: Remember the full fileName.
     at.rememberReadPath(fn, p)
     shadow_fn = x.shadowPathName(fn)
@@ -17,9 +15,9 @@
     while p.hasChildren():
         p.firstChild().doDelete()
     if shadow_exists:
-        at.read(p, atShadow=True, force=force)
+        at.read(p)
     else:
-        ok = at.importAtShadowNode(fn, p)
+        ok = at.importAtShadowNode(p)
         if ok:
             # Create the private file automatically.
             at.writeOneAtShadowNode(p)
@language python
</t>
<t tx="ekr.20210502131534.30">def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        at.error(
            f"can not happen: fn: {fn} != atShadowNodeName: "
            f"{p.atShadowFileNodeName()}")
        return
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    # #889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
</t>
<t tx="ekr.20210502131534.31">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,13 +1,16 @@
-def importAtShadowNode(self, fn, p):
-    at = self; c = at.c; ic = c.importCommands
+def importAtShadowNode(self, p):
+    c, ic =self.c, self.c.importCommands
+    fn = g.fullPath(c, p)  # #1521, #1341, #1914.
+    if not g.os_path_exists(fn):
+        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
+        return p
     # Delete all the child nodes.
     while p.hasChildren():
         p.firstChild().doDelete()
     # Import the outline, exactly as @auto does.
-    ic.createOutline(fn, parent=p.copy(), atShadow=True)
+    ic.createOutline(parent=p.copy())
     if ic.errors:
         g.error('errors inhibited read @shadow', fn)
     if ic.errors or not g.os_path_exists(fn):
         p.clearDirty()
-    # else: g.doHook('after-shadow', p = p)
     return ic.errors == 0
@language python
</t>
<t tx="ekr.20210502131534.32">def importAtShadowNode(self, fn, p):
    at = self; c = at.c; ic = c.importCommands
    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()
    # Import the outline, exactly as @auto does.
    ic.createOutline(fn, parent=p.copy(), atShadow=True)
    if ic.errors:
        g.error('errors inhibited read @shadow', fn)
    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
    # else: g.doHook('after-shadow', p = p)
    return ic.errors == 0
</t>
<t tx="ekr.20210502131534.33">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,3 +1,3 @@
 def fast_read_into_root(self, c, contents, gnx2vnode, path, root):
-    """A convenience wrapper for FastAtReAD.read_into_root()"""
+    """A convenience wrapper for FastAtRead.read_into_root()"""
     return FastAtRead(c, gnx2vnode).read_into_root(contents, path, root)
@language python
</t>
<t tx="ekr.20210502131534.34">def fast_read_into_root(self, c, contents, gnx2vnode, path, root):
    """A convenience wrapper for FastAtReAD.read_into_root()"""
    return FastAtRead(c, gnx2vnode).read_into_root(contents, path, root)
</t>
<t tx="ekr.20210502131534.35">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -17,22 +17,23 @@
         at.writePathChanged(p)
     except IOError:
         return
-    # Tricky: @ignore not recognised in @asis nodes.
-    if p.isAtAsisFileNode():
-        at.asisWrite(p)
-    elif p.isAtAutoNode():
-        at.writeOneAtAutoNode(p)
-        # Do *not* clear the dirty bits the entries in @persistence tree here!
-    elif p.isAtCleanNode():
-        at.write('@clean', p, sentinels=False)
-    elif p.isAtNoSentFileNode():
-        at.write('@nosent', p, sentinels=False)
-    elif p.isAtEditNode():
-        at.writeOneAtEditNode(p)
-    elif p.isAtShadowFileNode():
-        at.writeOneAtShadowNode(p)
-    elif p.isAtThinFileNode() or p.isAtFileNode():
-        at.write('@file', p)
+    table = (
+        (p.isAtAsisFileNode, at.asisWrite),
+        (p.isAtAutoNode, at.writeOneAtAutoNode),
+        (p.isAtCleanNode, at.writeOneAtCleanNode),
+        (p.isAtEditNode, at.writeOneAtEditNode),
+        (p.isAtFileNode, at.writeOneAtFileNode),
+        (p.isAtNoSentFileNode, at.writeOneAtNosentNode),
+        (p.isAtShadowFileNode, at.writeOneAtShadowNode),
+        (p.isAtThinFileNode, at.writeOneAtFileNode),
+    )
+    for pred, func in table:
+        if pred():
+            func(p)
+            break
+    else:
+        g.trace(f"Can not happen: {p.h}")
+        return
     #
     # Clear the dirty bits in all descendant nodes.
     # The persistence data may still have to be written.
@language python
</t>
<t tx="ekr.20210502131534.36">def writeAllHelper(self, p, root):
    '''
    Write one file for at.writeAll.
    
    Do *not* write @auto files unless p == root.
    
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    if p.isAtIgnoreNode():
        # Should have been handled in findFilesToWrite.
        g.trace(f"Can not happen: {p.h} is an @ignore node")
        return
    try:
        at.writePathChanged(p)
    except IOError:
        return
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode():
        at.write('@clean', p, sentinels=False)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write('@file', p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()
</t>
<t tx="ekr.20210502131534.37">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,7 @@
     try:
         c.endEditing()
         c.init_error_dialogs()
-        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
+        fileName = at.initWriteIvars(root)
         # #1450.
         if not fileName or not at.precheck(fileName, root):
             at.addToOrphanList(root)
@language python
</t>
<t tx="ekr.20210502131534.38">def asisWrite(self, root):
    at, c = self, self.c
    try:
        c.endEditing()
        c.init_error_dialogs()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.outputList = []
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        if not at.errors:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        at.writeException(fileName, root)

silentWrite = asisWrite  # Compatibility with old scripts.
</t>
<t tx="ekr.20210502131534.39">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,7 @@
     writtenFiles = False
     c.init_error_dialogs()
     # #1450.
-    at.initWriteIvars(root=p.copy(), targetFileName='')
+    at.initWriteIvars(root=p.copy())
     p = p.copy()
     after = p.nodeAfterTree()
     while p and p != after:  # Don't use iterator.
@@ -12,9 +12,7 @@
         ):
             fileName = p.anyAtFileNodeName()
             if fileName:
-                fileName = c.expand_path_expression(fileName)  # #1341
-                fileName = g.os_path_finalize_join(
-                    at.default_directory, fileName)  # #1341
+                fileName = g.fullPath(c, p)  # #1914.
                 if at.precheck(fileName, p):
                     at.writeMissingNode(p)
                     writtenFiles = True
@language python
</t>
<t tx="ekr.20210502131534.40">def writeMissing(self, p):
    at, c = self, self.c
    writtenFiles = False
    c.init_error_dialogs()
    # #1450.
    at.initWriteIvars(root=p.copy(), targetFileName='')
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:  # Don't use iterator.
        if (
            p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode())
        ):
            fileName = p.anyAtFileNodeName()
            if fileName:
                fileName = c.expand_path_expression(fileName)  # #1341
                fileName = g.os_path_finalize_join(
                    at.default_directory, fileName)  # #1341
                if at.precheck(fileName, p):
                    at.writeMissingNode(p)
                    writtenFiles = True
                else:
                    at.addToOrphanList(p)
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if writtenFiles &gt; 0:
            g.es("finished")
        else:
            g.es("no @file node in the selected tree")
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20210502131534.41">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,13 +1,18 @@
 def writeMissingNode(self, p):
 
     at = self
-    if p.isAtAsisFileNode():
-        at.asisWrite(p)
-    elif p.isAtNoSentFileNode():
-        at.write('@nosent', p, sentinels=False)
-    elif p.isAtFileNode():
-        at.write('@file', p)
-    elif p.isAtAutoNode() or p.isAtAutoRstNode():
-        g.es('Can not write missing @auto node', p.h, color='red')
-    else:
-        g.trace('can not happen: unknown @file node')
+    table = (
+        (p.isAtAsisFileNode, at.asisWrite),
+        (p.isAtAutoNode, at.writeOneAtAutoNode),
+        (p.isAtCleanNode, at.writeOneAtCleanNode),
+        (p.isAtEditNode, at.writeOneAtEditNode),
+        (p.isAtFileNode, at.writeOneAtFileNode),
+        (p.isAtNoSentFileNode, at.writeOneAtNosentNode),
+        (p.isAtShadowFileNode, at.writeOneAtShadowNode),
+        (p.isAtThinFileNode, at.writeOneAtFileNode),
+    )
+    for pred, func in table:
+        if pred():
+            func(p)
+            return
+    g.trace(f"Can not happen unknown @&lt;file&gt; kind: {p.h}")
@language python
</t>
<t tx="ekr.20210502131534.42">def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtFileNode():
        at.write('@file', p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
</t>
<t tx="ekr.20210502131534.43">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -10,10 +10,8 @@
         c.endEditing()
         if not p.atAutoNodeName():
             return False
-        fileName = at.initWriteIvars(root, p.atAutoNodeName(),
-            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
-            sentinels=False,
-        )
+        fileName = at.initWriteIvars(root)
+        at.sentinels = False
         # #1450.
         if not fileName or not at.precheck(fileName, root):
             at.addToOrphanList(root)
@language python
</t>
<t tx="ekr.20210502131534.44">def writeOneAtAutoNode(self, p):
    '''
    Write p, an @auto node.
    File indices *must* have already been assigned.
    Return True if the node was written successfully.
    '''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        if not p.atAutoNodeName():
            return False
        fileName = at.initWriteIvars(root, p.atAutoNodeName(),
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        if c.persistenceController:
            c.persistenceController.update_before_write_foreign_file(root)
        contents = at.writeAtAutoContents(fileName, root)
        if contents is None:
            g.es("not written:", fileName)
            at.addToOrphanList(root)
            return False
        at.replaceFile(contents, at.encoding, fileName, root,
            ignoreBlankLines=root.isAtAutoRstNode())
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20210502131534.45">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -11,11 +11,8 @@
             g.error('@edit nodes must not have children')
             g.es('To save your work, convert @edit to @auto, @file or @clean')
             return False
-        fileName = at.initWriteIvars(root, p.atEditNodeName(),
-            atEdit=True,
-            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
-            sentinels=False,
-        )
+        fileName = at.initWriteIvars(root)
+        at.sentinels = False
         # #1450.
         if not fileName or not at.precheck(fileName, root):
             at.addToOrphanList(root)
@language python
</t>
<t tx="ekr.20210502131534.46">def writeOneAtEditNode(self, p):
    '''Write one @edit node.'''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        c.init_error_dialogs()
        if not p.atEditNodeName():
            return False
        if p.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(root, p.atEditNodeName(),
            atEdit=True,
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        contents = ''.join([s for s in g.splitLines(p.b)
            if at.directiveKind4(s, 0) == at.noDirective])
        at.replaceFile(contents, at.encoding, fileName, root)
        c.raise_error_dialogs(kind='write')
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20210502131534.47">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -15,15 +15,11 @@
         self.adjustTargetLanguage(fn)
             # A hack to support unknown extensions. May set c.target_language.
         full_path = g.fullPath(c, p)
-        at.initWriteIvars(root, None,
-            atShadow=True,
-            defaultDirectory=g.os_path_dirname(full_path),
-            forcePythonSentinels=True,
-                # Force python sentinels to suppress an error message.
-                # The actual sentinels will be set below.
-        )
-        at.default_directory = g.os_path_dirname(full_path)
-            # Override.
+        at.initWriteIvars(root)
+        # Force python sentinels to suppress an error message.
+        # The actual sentinels will be set below.
+        at.endSentinelComment = None
+        at.startSentinelComment = "#"
         # Make sure we can compute the shadow directory.
         private_fn = x.shadowPathName(full_path)
         if not private_fn:
@language python
</t>
<t tx="ekr.20210502131534.48">def writeOneAtShadowNode(self, p, testing=False):
    '''
    Write p, an @shadow node.
    File indices *must* have already been assigned.
    
    testing: set by unit tests to suppress the call to at.precheck.
    '''
    at, c = self, self.c
    root = p.copy()
    x = c.shadowController
    try:
        c.endEditing()  # Capture the current headline.
        fn = p.atShadowFileNodeName()
        assert fn, p.h
        self.adjustTargetLanguage(fn)
            # A hack to support unknown extensions. May set c.target_language.
        full_path = g.fullPath(c, p)
        at.initWriteIvars(root, None,
            atShadow=True,
            defaultDirectory=g.os_path_dirname(full_path),
            forcePythonSentinels=True,
                # Force python sentinels to suppress an error message.
                # The actual sentinels will be set below.
        )
        at.default_directory = g.os_path_dirname(full_path)
            # Override.
        # Make sure we can compute the shadow directory.
        private_fn = x.shadowPathName(full_path)
        if not private_fn:
            return False
        if not testing and not at.precheck(full_path, root):
            return False
        #
        # Bug fix: Leo 4.5.1:
        # use x.markerFromFileName to force the delim to match
        # what is used in x.propegate changes.
        marker = x.markerFromFileName(full_path)
        at.startSentinelComment, at.endSentinelComment = marker.getDelims()
        if g.app.unitTesting:
            ivars_dict = g.getIvarsDict(at)
        #
        # Write the public and private files to strings.

        def put(sentinels):
            at.outputList = []
            at.sentinels = sentinels
            at.putFile(root, sentinels=sentinels)
            return '' if at.errors else ''.join(at.outputList)

        at.public_s = put(False)
        at.private_s = put(True)
        at.warnAboutOrphandAndIgnoredNodes()
        if g.app.unitTesting:
            exceptions = ('public_s', 'private_s', 'sentinels', 'outputList')
            assert g.checkUnchangedIvars(at, ivars_dict, exceptions), 'writeOneAtShadowNode'
        if not at.errors:
            # Write the public and private files.
            x.makeShadowDirectory(full_path)
                # makeShadowDirectory takes a *public* file name.
            x.replaceFileWithString(at.encoding, private_fn, at.private_s)
            x.replaceFileWithString(at.encoding, full_path, at.public_s)
        at.checkPythonCode(contents=at.private_s, fileName=full_path, root=root,)
        if at.errors:
            g.error("not written:", full_path)
            at.addToOrphanList(root)
        else:
            root.clearDirty()
        return not at.errors
    except Exception:
        at.writeException(full_path, root)
        return False
</t>
<t tx="ekr.20210502131534.49">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,7 @@
     at, c = self, self.c
     try:
         c.endEditing()
-        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
+        fileName = at.initWriteIvars(root)
         at.outputList = []
         for p in root.self_and_subtree(copy=False):
             at.writeAsisNode(p)
@language python
</t>
<t tx="ekr.20210502131534.50">def atAsisToString(self, root):
    """Write the @asis node to a string."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        at.outputList = []
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        return '' if at.errors else ''.join(at.outputList)
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20210502131534.51">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,8 @@
     at, c = self, self.c
     try:
         c.endEditing()
-        fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
+        fileName = at.initWriteIvars(root)
+        at.sentinels = False
         # #1450.
         if not fileName:
             at.addToOrphanList(root)
@language python
</t>
<t tx="ekr.20210502131534.52">def atAutoToString(self, root):
    """Write the root @auto node to a string, and return it."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        return at.writeAtAutoContents(fileName, root) or ''
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20210502131534.53">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -7,8 +7,8 @@
             g.error('@edit nodes must not have children')
             g.es('To save your work, convert @edit to @auto, @file or @clean')
             return False
-        fileName = at.initWriteIvars(
-            root, root.atEditNodeName(), atEdit=True, sentinels=False)
+        fileName = at.initWriteIvars(root)
+        at.sentinels = False
         # #1450.
         if not fileName:
             at.addToOrphanList(root)
@language python
</t>
<t tx="ekr.20210502131534.54">def atEditToString(self, root):
    """Write one @edit node."""
    at, c = self, self.c
    try:
        c.endEditing()
        if root.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(
            root, root.atEditNodeName(), atEdit=True, sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        contents = ''.join([
            s for s in g.splitLines(root.b)
                if at.directiveKind4(s, 0) == at.noDirective])
        return contents
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20210502131534.55">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -3,7 +3,8 @@
     at, c = self, self.c
     try:
         c.endEditing()
-        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
+        at.initWriteIvars(root)
+        at.sentinels = sentinels
         at.outputList = []
         at.putFile(root, sentinels=sentinels)
         assert root == at.root, 'write'
@language python
</t>
<t tx="ekr.20210502131534.56">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.outputList = []
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        contents = '' if at.errors else ''.join(at.outputList)
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return contents
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20210502131534.57">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,18 +1,18 @@
 def stringToString(self, root, s, forcePythonSentinels=True, sentinels=True):
     """
-    Write a 4.x derived file from a string.
+    Write an external file from a string.
 
     This is at.write specialized for scripting.
     """
     at, c = self, self.c
     try:
         c.endEditing()
-        at.initWriteIvars(
-            root,
-            targetFileName="&lt;string-file&gt;",
-            forcePythonSentinels=forcePythonSentinels,
-            sentinels=sentinels,
-        )
+        at.initWriteIvars(root)
+        if forcePythonSentinels:
+            at.endSentinelComment = None
+            at.startSentinelComment = "#"
+            at.language = "python"
+        at.sentinels = sentinels
         at.outputList = []
         at.putFile(root, fromString=s, sentinels=sentinels)
         contents = '' if at.errors else ''.join(at.outputList)
@language python
</t>
<t tx="ekr.20210502131534.58">def stringToString(self, root, s, forcePythonSentinels=True, sentinels=True):
    """
    Write a 4.x derived file from a string.

    This is at.write specialized for scripting.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(
            root,
            targetFileName="&lt;string-file&gt;",
            forcePythonSentinels=forcePythonSentinels,
            sentinels=sentinels,
        )
        at.outputList = []
        at.putFile(root, fromString=s, sentinels=sentinels)
        contents = '' if at.errors else ''.join(at.outputList)
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if root:
            if hasattr(self.root.v, 'tnodeList'):
                delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return contents
    except Exception:
        at.exception("exception preprocessing script")
        return ''
</t>
<t tx="ekr.20210502131534.59">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -2,6 +2,7 @@
     """Put a line containing one or more references."""
     at = self
     ref = at.findReference(name, p)
+    is_clean = at.root.h.startswith('@clean')
     if not ref:
         if hasattr(at, 'allow_undefined_refs'):
             # Allow apparent section reference: just write the line.
@@ -18,7 +19,7 @@
         i = n2
         n_refs += 1
         name, n1, n2 = at.findSectionName(s, i)
-        if self.kind == '@clean' and n_refs &gt; 1:
+        if is_clean and n_refs &gt; 1:
             # #1232: allow only one section reference per line in @clean.
             i1, i2 = g.getLine(s, i)
             line = s[i1:i2].rstrip()
@language python
</t>
<t tx="ekr.20210502131534.6"></t>
<t tx="ekr.20210502131534.60">def putRefLine(self, s, i, n1, n2, name, p):
    """Put a line containing one or more references."""
    at = self
    ref = at.findReference(name, p)
    if not ref:
        if hasattr(at, 'allow_undefined_refs'):
            # Allow apparent section reference: just write the line.
            at.putCodeLine(s, i)
        return
    # Compute delta only once.
    junk, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    # Write the lead-in sentinel only once.
    at.putLeadInSentinel(s, i, n1, delta)
    self.putRefAt(name, ref, delta)
    n_refs = 0
    while 1:
        progress = i
        i = n2
        n_refs += 1
        name, n1, n2 = at.findSectionName(s, i)
        if self.kind == '@clean' and n_refs &gt; 1:
            # #1232: allow only one section reference per line in @clean.
            i1, i2 = g.getLine(s, i)
            line = s[i1:i2].rstrip()
            at.writeError(f"Too many section references:\n{line!s}")
            break
        if name:
            ref = at.findReference(name, p)
                # Issues error if not found.
            if ref:
                middle_s = s[i:n1]
                self.putAfterMiddleRef(middle_s, delta)
                self.putRefAt(name, ref, delta)
        else:
            break
        assert progress &lt; i
    self.putAfterLastRef(s, i, delta)
</t>
<t tx="ekr.20210502131534.61">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,8 +1,10 @@
 def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
     """Perform python-related checks on root."""
     at = self
-    if contents and fileName and fileName.endswith(
-        '.py') and at.checkPythonCodeOnWrite:
+    if (
+        contents and fileName and fileName.endswith('.py')
+        and at.checkPythonCodeOnWrite
+    ):
         # It's too slow to check each node separately.
         if pyflakes_errors_only:
             ok = True
@language python
</t>
<t tx="ekr.20210502131534.62">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20210502131534.63">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,60 +1,37 @@
-def scanAllDirectives(self,
-    p,
-    forcePythonSentinels=False,
-    importing=False,
-    issuePathWarning=False,
-    reading=False,
-):
+def scanAllDirectives(self, p):
     '''
     Scan p and p's ancestors looking for directives,
     setting corresponding AtFile ivars.
     '''
     at, c = self, self.c
-    g.app.atPathInBodyWarning = None
-    &lt;&lt; set ivars &gt;&gt;
-    lang_dict = {'language': at.language, 'delims': delims,}
-    table = (
-        ('encoding', at.encoding, g.scanAtEncodingDirectives),
-        # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
-        ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
-        ('lineending', None, g.scanAtLineendingDirectives),
-        ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
-        ('path', None, c.scanAtPathDirectives),
-        ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
-    )
-    # Set d by scanning all directives.
-    aList = g.get_directives_dict_list(p)
-    d = {}
-    for key, default, func in table:
-        val = func(aList)
-        d[key] = default if val is None else val
-    # Post process.
-    lineending = d.get('lineending')
-    lang_dict = d.get('lang-dict')
+    d = c.scanAllDirectives(p)
+    #
+    # Language &amp; delims: Do *not* use the default language returned by c.scanAllDirectives.
+    lang_dict = d.get('lang-dict') or {}
     if lang_dict:
         delims = lang_dict.get('delims')
-        at.language = lang_dict.get('language')
+        language = lang_dict.get('language')
     else:
         # No language directive.  Look for @&lt;file&gt; nodes.
+        language = d.get('language')
+        delims = g.set_delims_from_language(language)
+    if not language:  # Defensive code.
         language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
-        delims = g.set_delims_from_language(language)
-    at.encoding = d.get('encoding')
+    at.language = language
+    &lt;&lt; Set comment strings from delims &gt;&gt;
+    #
+    # Easy cases
+    at.encoding = d.get('encoding') or c.config.default_derived_file_encoding
+    lineending = d.get('lineending')
     at.explicitLineEnding = bool(lineending)
     at.output_newline = lineending or g.getOutputNewline(c=c)
-    at.page_width = d.get('pagewidth')
-    at.default_directory = d.get('path')
-    at.tab_width = d.get('tabwidth')
-    if not importing and not reading:
-        # Don't override comment delims when reading!
-        &lt;&lt; set comment strings from delims &gt;&gt;
-    # For unit testing.
-    d = {
-        "all": all,
+    at.page_width = d.get('pagewidth') or c.page_width
+    at.tab_width = d.get('tabwidth') or c.tab_width
+    return {
         "encoding": at.encoding,
         "language": at.language,
         "lineending": at.output_newline,
         "pagewidth": at.page_width,
-        "path": at.default_directory,
+        "path": d.get('path'),
         "tabwidth": at.tab_width,
     }
-    return d
@language python
</t>
<t tx="ekr.20210502131534.64">def scanAllDirectives(self,
    p,
    forcePythonSentinels=False,
    importing=False,
    issuePathWarning=False,
    reading=False,
):
    '''
    Scan p and p's ancestors looking for directives,
    setting corresponding AtFile ivars.
    '''
    at, c = self, self.c
    g.app.atPathInBodyWarning = None
    &lt;&lt; set ivars &gt;&gt;
    lang_dict = {'language': at.language, 'delims': delims,}
    table = (
        ('encoding', at.encoding, g.scanAtEncodingDirectives),
        # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
        ('lineending', None, g.scanAtLineendingDirectives),
        ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
        ('path', None, c.scanAtPathDirectives),
        ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key, default, func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process.
    lineending = d.get('lineending')
    lang_dict = d.get('lang-dict')
    if lang_dict:
        delims = lang_dict.get('delims')
        at.language = lang_dict.get('language')
    else:
        # No language directive.  Look for @&lt;file&gt; nodes.
        language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
        delims = g.set_delims_from_language(language)
    at.encoding = d.get('encoding')
    at.explicitLineEnding = bool(lineending)
    at.output_newline = lineending or g.getOutputNewline(c=c)
    at.page_width = d.get('pagewidth')
    at.default_directory = d.get('path')
    at.tab_width = d.get('tabwidth')
    if not importing and not reading:
        # Don't override comment delims when reading!
        &lt;&lt; set comment strings from delims &gt;&gt;
    # For unit testing.
    d = {
        "all": all,
        "encoding": at.encoding,
        "language": at.language,
        "lineending": at.output_newline,
        "pagewidth": at.page_width,
        "path": at.default_directory,
        "tabwidth": at.tab_width,
    }
    return d
</t>
<t tx="ekr.20210502131534.65">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,9 +1,4 @@
-if forcePythonSentinels:
-    # Force Python language.
-    delim1, delim2, delim3 = g.set_delims_from_language("python")
-    self.language = "python"
-else:
-    delim1, delim2, delim3 = delims
+delim1, delim2, delim3 = delims
 # Use single-line comments if we have a choice.
 # delim1,delim2,delim3 now correspond to line,start,end
 if delim1:
@language python
</t>
<t tx="ekr.20210502131534.66">if forcePythonSentinels:
    # Force Python language.
    delim1, delim2, delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1, delim2, delim3 = delims
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = ""  # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:  # Emergency!
    #
    # Issue an error only if at.language has been set.
    # This suppresses a message from the markdown importer.
    if not g.app.unitTesting and at.language:
        g.trace(repr(at.language), g.callers())
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:", c.target_language)
    at.startSentinelComment = "#"  # This should never happen!
    at.endSentinelComment = ""
</t>
<t tx="ekr.20210502131534.7"></t>
<t tx="ekr.20210502131534.75">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1931,9 +1931,6 @@
                 n += len(s)
         return language
     #@+node:ekr.20081006100835.1: *4* c.getNodePath &amp; c.getNodeFileName
-    # Not used in Leo's core.
-    # Used by the UNl plugin.  Does not need to create a path.
-
     def getNodePath(self, p):
         """Return the path in effect at node p."""
         c = self
@@ -1941,26 +1938,18 @@
         path = c.scanAtPathDirectives(aList)
         return path
 
-    # Not used in Leo's core.
-
     def getNodeFileName(self, p):
         """
         Return the full file name at node p,
         including effects of all @path directives.
-        Return None if p is no kind of @file node.
-        """
-        c = self
-        path = g.scanAllAtPathDirectives(c, p)
-        name = ''
+        Return '' if p is no kind of @file node.
+        """
+        c = self
         for p in p.self_and_parents(copy=False):
             name = p.anyAtFileNodeName()
-            if name: break
-        if name:
-            # The commander method supports {{expr}}; the global function does not.
-            path = c.expand_path_expression(path)  # #1341.
-            name = c.expand_path_expression(name)  # #1341.
-            name = g.os_path_finalize_join(path, name)
-        return name
+            if name:
+                return g.fullPath(c, p)  # #1914.
+        return ''
     #@+node:ekr.20171123135625.32: *4* c.hasAmbiguousLangauge
     def hasAmbiguousLanguage(self, p):
         """Return True if p.b contains different @language directives."""
@@ -2010,16 +1999,10 @@
         """
         c = self
         p = p or c.p
-        # Set defaults
-        language = c.target_language and c.target_language.lower()
-        lang_dict = {
-            'language':language,
-            'delims':g.set_delims_from_language(language),
-        }
         wrap = c.config.getBool("body-pane-wraps")
         table = (
             ('encoding',    None,           g.scanAtEncodingDirectives),
-            ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
+            ('lang-dict',   {},             g.scanAtCommentAndAtLanguageDirectives),
             ('lineending',  None,           g.scanAtLineendingDirectives),
             ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
             ('path',        None,           c.scanAtPathDirectives),
@@ -2036,13 +2019,15 @@
         lang_dict = d.get('lang-dict')
         d = {
             "delims":       lang_dict.get('delims'),
+            "comment":      lang_dict.get('comment'),  # Leo 6.4: New.
             "encoding":     d.get('encoding'),
-            "language":     lang_dict.get('language'),
+            # Note: at.scanAllDirectives does not use the defaults for "language".
+            "language":     lang_dict.get('language') or c.target_language and c.target_language.lower(),
+            "lang-dict":    lang_dict,  # Leo 6.4: New.
             "lineending":   d.get('lineending'),
             "pagewidth":    d.get('pagewidth'),
             "path":         d.get('path'), # Redundant: or g.getBaseDirectory(c),
             "tabwidth":     d.get('tabwidth'),
-            "pluginsList":  [], # No longer used.
             "wrap":         d.get('wrap'),
         }
         return d
@@ -2088,24 +2073,6 @@
         path = g.os_path_finalize_join(*paths)  # #1341.
         return path or g.getBaseDirectory(c)
             # 2010/10/22: A useful default.
-    #@+node:ekr.20080828103146.12: *4* c.scanAtRootDirectives (no longer used)
-    # No longer used. Was called only by scanLanguageDirectives.
-
-    def scanAtRootDirectives(self, aList):
-        """Scan aList for @root-code and @root-doc directives."""
-        c = self
-        # To keep pylint happy.
-        tag = 'at_root_bodies_start_in_doc_mode'
-        start_in_doc = hasattr(c.config, tag) and getattr(c.config, tag)
-        # New in Leo 4.6: dashes are valid in directive names.
-        for d in aList:
-            if 'root-code' in d:
-                return 'code'
-            if 'root-doc' in d:
-                return 'doc'
-            if 'root' in d:
-                return 'doc' if start_in_doc else 'code'
-        return None
     #@+node:ekr.20190921130036.1: *3* c.expand_path_expression
     def expand_path_expression(self, s):
         """Expand all {{anExpression}} in c's context."""
@language python
</t>
<t tx="ekr.20210502131534.8">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.outputList = []
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            contents = ''.join(at.outputList)
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20210502131534.80"></t>
<t tx="ekr.20210502131534.81"># No longer used. Was called only by scanLanguageDirectives.

def scanAtRootDirectives(self, aList):
    """Scan aList for @root-code and @root-doc directives."""
    c = self
    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config, tag) and getattr(c.config, tag)
    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        if 'root-doc' in d:
            return 'doc'
        if 'root' in d:
            return 'doc' if start_in_doc else 'code'
    return None
</t>
<t tx="ekr.20210502131534.82"></t>
<t tx="ekr.20210502131534.83">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -1,6 +1,3 @@
-# Not used in Leo's core.
-# Used by the UNl plugin.  Does not need to create a path.
-
 def getNodePath(self, p):
     """Return the path in effect at node p."""
     c = self
@@ -8,23 +5,15 @@
     path = c.scanAtPathDirectives(aList)
     return path
 
-# Not used in Leo's core.
-
 def getNodeFileName(self, p):
     """
     Return the full file name at node p,
     including effects of all @path directives.
-    Return None if p is no kind of @file node.
+    Return '' if p is no kind of @file node.
     """
     c = self
-    path = g.scanAllAtPathDirectives(c, p)
-    name = ''
     for p in p.self_and_parents(copy=False):
         name = p.anyAtFileNodeName()
-        if name: break
-    if name:
-        # The commander method supports {{expr}}; the global function does not.
-        path = c.expand_path_expression(path)  # #1341.
-        name = c.expand_path_expression(name)  # #1341.
-        name = g.os_path_finalize_join(path, name)
-    return name
+        if name:
+            return g.fullPath(c, p)  # #1914.
+    return ''
@language python
</t>
<t tx="ekr.20210502131534.84"># Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
</t>
<t tx="ekr.20210502131534.85">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -8,16 +8,10 @@
     """
     c = self
     p = p or c.p
-    # Set defaults
-    language = c.target_language and c.target_language.lower()
-    lang_dict = {
-        'language':language,
-        'delims':g.set_delims_from_language(language),
-    }
     wrap = c.config.getBool("body-pane-wraps")
     table = (
         ('encoding',    None,           g.scanAtEncodingDirectives),
-        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
+        ('lang-dict',   {},             g.scanAtCommentAndAtLanguageDirectives),
         ('lineending',  None,           g.scanAtLineendingDirectives),
         ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
         ('path',        None,           c.scanAtPathDirectives),
@@ -34,13 +28,15 @@
     lang_dict = d.get('lang-dict')
     d = {
         "delims":       lang_dict.get('delims'),
+        "comment":      lang_dict.get('comment'),  # Leo 6.4: New.
         "encoding":     d.get('encoding'),
-        "language":     lang_dict.get('language'),
+        # Note: at.scanAllDirectives does not use the defaults for "language".
+        "language":     lang_dict.get('language') or c.target_language and c.target_language.lower(),
+        "lang-dict":    lang_dict,  # Leo 6.4: New.
         "lineending":   d.get('lineending'),
         "pagewidth":    d.get('pagewidth'),
         "path":         d.get('path'), # Redundant: or g.getBaseDirectory(c),
         "tabwidth":     d.get('tabwidth'),
-        "pluginsList":  [], # No longer used.
         "wrap":         d.get('wrap'),
     }
     return d
@language python
</t>
<t tx="ekr.20210502131534.86">@nobeautify

def scanAllDirectives(self,p=None):
    """
    Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.
    """
    c = self
    p = p or c.p
    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body-pane-wraps")
    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')
    d = {
        "delims":       lang_dict.get('delims'),
        "encoding":     d.get('encoding'),
        "language":     lang_dict.get('language'),
        "lineending":   d.get('lineending'),
        "pagewidth":    d.get('pagewidth'),
        "path":         d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth":     d.get('tabwidth'),
        "pluginsList":  [], # No longer used.
        "wrap":         d.get('wrap'),
    }
    return d
</t>
<t tx="ekr.20210502131534.9">at.page_width = c.page_width
at.tab_width = c.tab_width
at.default_directory = None  # 8/2: will be set later.
if c.target_language:
    c.target_language = c.target_language.lower()
delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language
at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=c)  # Init from config settings.
</t>
<t tx="ekr.20210502131534.95">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -71,7 +71,8 @@
     'nopyflakes',  # Leo 6.1.
     'nosearch',  # Leo 5.3.
     'others', 'pagewidth', 'path', 'quiet',
-    'raw', 'root-code', 'root-doc', 'root', 'silent',
+    'raw',
+    'silent',
     'tabwidth', 'terse',
     'unit', 'verbose', 'wrap',
 ]
@@ -3255,11 +3256,7 @@
                     # A unit test tests that @path:any is invalid.
             k = g.skip_line(s, j)
             val = s[j:k].strip()
-            if word in ('root-doc', 'root-code'):
-                d['root'] = val  # in addition to optioned version
             d[word] = val
-            # New in Leo 5.7.1: @path is allowed in body text.
-            # This is very useful when doing recursive imports.
     if root:
         anIter = g_noweb_root.finditer(p.b)
         for m in anIter:
@@ -3461,46 +3458,6 @@
     aList = g.get_directives_dict_list(p)
     path = c.scanAtPathDirectives(aList)
     return path
-#@+node:ekr.20100507084415.5760: *3* g.scanAtRootDirectives
-def scanAtRootDirectives(aList):
-    """Scan aList for @root directives."""
-    for d in aList:
-        s = d.get('root')
-        if s is not None:
-            i, mode = g.scanAtRootOptions(s, 0)
-            return mode
-    return None
-#@+node:ekr.20031218072017.3154: *3* g.scanAtRootOptions
-def scanAtRootOptions(s, i, err_flag=False):
-    # The @root has been eaten when called from tangle.scanAllDirectives.
-    if g.match(s, i, "@root"):
-        i += len("@root")
-        i = g.skip_ws(s, i)
-    mode = None
-    while g.match(s, i, '-'):
-        #@+&lt;&lt; scan another @root option &gt;&gt;
-        #@+node:ekr.20031218072017.3155: *4* &lt;&lt; scan another @root option &gt;&gt;
-        i += 1; err = -1
-        if g.match_word(s, i, "code"):  # Just match the prefix.
-            if not mode: mode = "code"
-            elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
-        elif g.match(s, i, "doc"):  # Just match the prefix.
-            if not mode: mode = "doc"
-            elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
-        else:
-            err = i - 1
-        # Scan to the next minus sign.
-        while i &lt; len(s) and s[i] not in (' ', '\t', '\n', '-'):
-            i += 1
-        if err &gt; -1 and err_flag:
-            z_opt = s[err:i]
-            z_line = g.get_line(s, i)
-            g.es("unknown option:", z_opt, "in", z_line)
-        #@-&lt;&lt; scan another @root option &gt;&gt;
-    if mode is None:
-        doc = app.config.at_root_bodies_start_in_doc_mode
-        mode = "doc" if doc else "code"
-    return i, mode
 #@+node:ekr.20080827175609.37: *3* g.scanAtTabwidthDirectives &amp; scanAllTabWidthDirectives
 def scanAtTabwidthDirectives(aList, issue_error_flag=False):
     """Scan aList for @tabwidth directives."""
@@ -3662,46 +3619,6 @@
     if issue_errors_flag:
         g.es("ignoring:", g.get_line(s, i))
     return None, None, None, None
-#@+node:ekr.20081001062423.9: *3* g.setDefaultDirectory &amp; helper
-def setDefaultDirectory(c, p, importing=False):
-    """ Return a default directory by scanning @path directives."""
-    if p:
-        name = p.anyAtFileNodeName()
-        if name:
-            # An absolute path overrides everything.
-            d = g.os_path_dirname(name)
-            if d and g.os_path_isabs(d):
-                return d
-        aList = g.get_directives_dict_list(p)
-        path = c.scanAtPathDirectives(aList)
-            # Returns g.getBaseDirectory(c) by default.
-            # However, g.getBaseDirectory can return ''
-    else:
-        path = None
-    if path:
-        path = g.os_path_finalize(path)
-    else:
-        g.checkOpenDirectory(c)
-        for d in (c.openDirectory, g.getBaseDirectory(c)):
-            # Errors may result in relative or invalid path.
-            if d and g.os_path_isabs(d):
-                path = d
-                break
-        else:
-            path = ''
-    if not importing and not path:
-        # This should never happen, but is not serious if it does.
-        g.warning("No absolute directory specified anywhere.")
-    return path
-#@+node:ekr.20101022124309.6132: *4* g.checkOpenDirectory
-def checkOpenDirectory(c):
-    if c.openDirectory != c.frame.openDirectory:
-        g.error(
-            f"Error: c.openDirectory != c.frame.openDirectory\n"
-            f"c.openDirectory: {c.openDirectory}\n"
-            f"c.frame.openDirectory: {c.frame.openDirectory}")
-    if not g.os_path_isabs(c.openDirectory):
-        g.error(f"Error: relative c.openDirectory: {c.openDirectory}")
 #@+node:ekr.20071109165315: *3* g.stripPathCruft
 def stripPathCruft(path):
     """Strip cruft from a path name."""
@language python
</t>
<t tx="ekr.20210502131535.1"></t>
<t tx="ekr.20210502131535.10">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -29,11 +29,7 @@
                     # A unit test tests that @path:any is invalid.
             k = g.skip_line(s, j)
             val = s[j:k].strip()
-            if word in ('root-doc', 'root-code'):
-                d['root'] = val  # in addition to optioned version
             d[word] = val
-            # New in Leo 5.7.1: @path is allowed in body text.
-            # This is very useful when doing recursive imports.
     if root:
         anIter = g_noweb_root.finditer(p.b)
         for m in anIter:
@language python
</t>
<t tx="ekr.20210502131535.11"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

def get_directives_dict(p, root=None):
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    if root:
        root_node = root[0]
    d = {}
    #
    # #1688:    legacy: Always compute the pattern.
    #           g.directives_pat is updated whenever loading a plugin.
    #
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = g.directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j &lt; len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            if word in ('root-doc', 'root-code'):
                d['root'] = val  # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0  # value not immportant
            else:
                g.es(f'{g.angleBrackets("*")} may only occur in a topmost node (i.e., without a parent)')
            break
    return d
</t>
<t tx="ekr.20210502131535.2">def scanAtRootDirectives(aList):
    """Scan aList for @root directives."""
    for d in aList:
        s = d.get('root')
        if s is not None:
            i, mode = g.scanAtRootOptions(s, 0)
            return mode
    return None
</t>
<t tx="ekr.20210502131535.3">def scanAtRootOptions(s, i, err_flag=False):
    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s, i, "@root"):
        i += len("@root")
        i = g.skip_ws(s, i)
    mode = None
    while g.match(s, i, '-'):
        &lt;&lt; scan another @root option &gt;&gt;
    if mode is None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = "doc" if doc else "code"
    return i, mode
</t>
<t tx="ekr.20210502131535.4">i += 1; err = -1
if g.match_word(s, i, "code"):  # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
elif g.match(s, i, "doc"):  # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
else:
    err = i - 1
# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ', '\t', '\n', '-'):
    i += 1
if err &gt; -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s, i)
    g.es("unknown option:", z_opt, "in", z_line)
</t>
<t tx="ekr.20210502131535.5">def setDefaultDirectory(c, p, importing=False):
    """ Return a default directory by scanning @path directives."""
    if p:
        name = p.anyAtFileNodeName()
        if name:
            # An absolute path overrides everything.
            d = g.os_path_dirname(name)
            if d and g.os_path_isabs(d):
                return d
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
            # Returns g.getBaseDirectory(c) by default.
            # However, g.getBaseDirectory can return ''
    else:
        path = None
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory, g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''
    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")
    return path
</t>
<t tx="ekr.20210502131535.6">def checkOpenDirectory(c):
    if c.openDirectory != c.frame.openDirectory:
        g.error(
            f"Error: c.openDirectory != c.frame.openDirectory\n"
            f"c.openDirectory: {c.openDirectory}\n"
            f"c.frame.openDirectory: {c.frame.openDirectory}")
    if not g.os_path_isabs(c.openDirectory):
        g.error(f"Error: relative c.openDirectory: {c.openDirectory}")
</t>
<t tx="ekr.20210502131535.7"></t>
<t tx="ekr.20210502131535.8">@ignore
@nosearch
@language patch
--- 7aa7adfe
+++ HEAD
@@ -15,7 +15,8 @@
     'nopyflakes',  # Leo 6.1.
     'nosearch',  # Leo 5.3.
     'others', 'pagewidth', 'path', 'quiet',
-    'raw', 'root-code', 'root-doc', 'root', 'silent',
+    'raw',
+    'silent',
     'tabwidth', 'terse',
     'unit', 'verbose', 'wrap',
 ]
@language python
</t>
<t tx="ekr.20210502131535.9"># Visible externally so plugins may add to the list of directives.
globalDirectiveList = [
    # Order does not matter.
    'all',
    'beautify',
    'colorcache', 'code', 'color', 'comment', 'c',
    'delims', 'doc',
    'encoding', 'end_raw',
    'first', 'header', 'ignore',
    'killbeautify', 'killcolor',
    'language', 'last', 'lineending',
    'markup',
    'nobeautify',
    'nocolor-node', 'nocolor', 'noheader', 'nowrap',
    'nopyflakes',  # Leo 6.1.
    'nosearch',  # Leo 5.3.
    'others', 'pagewidth', 'path', 'quiet',
    'raw', 'root-code', 'root-doc', 'root', 'silent',
    'tabwidth', 'terse',
    'unit', 'verbose', 'wrap',
]

directives_pat = None  # Set below.
</t>
<t tx="ekr.20210503050503.1">^def\b.+\s*=

cff: suboutline-only.</t>
<t tx="ekr.20210503050728.1">@nosearch

# Ignore Case, Regex, Head, Body

Found:^def\b.+\s*=

# found 21 nodes</t>
<t tx="ekr.20210503050941.1"></t>
<t tx="ekr.20210503051329.1"></t>
<t tx="ekr.20210503051412.1"></t>
<t tx="ekr.20210503055743.1"># It's not worth trying to simplify these.</t>
<t tx="ekr.20210503062101.1"></t>
<t tx="lukagolibrodo.20210329145317.1">@language python

from leo.core.leoQt import QtWidgets, QtCore
import leo.core.leoGlobals as g

# This script make iconbar always expanded. Mainly based on this solution:
#https://stackoverflow.com/questions/55930004/keep-qtoolbar-showing-always-all-items

class eventfilterinst(QtCore.QObject):
    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.Leave: # and obj is qt_widget:
            return True
        return super().eventFilter(obj, event)
        
def do_hack(c):
    iconbar=c.frame.iconBar.w
    layout = iconbar.findChild(QtWidgets.QLayout)
    if layout is not None:
        layout.setExpanded(True)
    
    button = iconbar.findChild(QtWidgets.QToolButton, "qt_toolbar_ext_button")
    if button is not None:
        button.setFixedSize(0, 0)
    
    ieventfilterinst=eventfilterinst()
    c.frame.iconBar.w.installEventFilter(ieventfilterinst)


#first, do it immediately
### do_hack(c)

# maybe there is some elegant solution,
# but if only to expand iconbar it overlaps with body and tree areas -&gt; so just enlarge it

### c.frame.iconBar.w.setFixedHeight(100)

# second, register hook (if not, behavoir of iconbar reset when save)
# this code may be dirty because every time new objects are created
def expandiconbar(tag, keywords):
    c = keywords.get('c')
    if c:
        # global ieventfilterinst #?
        do_hack(c)

g.registerHandler('save2', expandiconbar)

g.es('fin')

</t>
<t tx="tbnorth.20170616103256.1">def linkUrl(self):
    """linkUrl - link from current position to an URL / UNL"""

    c = self.c
    url = g.app.gui.runAskOkCancelStringDialog(
        c, "Link to URL/UNL",
        "Enter URL / UNL to link to from this node",
        default=g.app.gui.getTextFromClipboard()
    )
    if url is None or not url.strip():
        return
    if '://' not in url:
        url = 'unl://' + url
        g.es("Assuming unl:// url, use file:// explicitly for files")
    self.initBacklink(c.p.v)
    if url in [i.rsplit('##', 1)[0] for i in c.p.v.u['_bklnk']['urls']]:
        g.es("Already linked from this node")
        return
    c.p.v.u['_bklnk']['urls'].append(url)
    c.p.setDirty()
    c.setChanged()

</t>
<t tx="tbnorth.20170616105931.1">def handleURL(self, url):
    """handleUrl - user clicked an URL / UNL link

    :param str url: URL for link
    """
    g.es(url)
    # UNL detection copied from g.handleUrl()
    if (
        url.lower().startswith('unl:' + '//') or
        url.lower().startswith('file://') and url.find('--&gt;') &gt; -1 or
        url.startswith('#')
    ):
        our_unl = 'unl://'+self.c.p.get_UNL(with_index=False)
        # don't use .get_UNL(with_proto=True), that
        # unecessarily does ' ' -&gt; %20 conversion
        new_c = g.handleUnl(url, self.c)
        if new_c and hasattr(new_c, 'backlinkController'):
            unl = url.replace('%20', ' ').split('#', 1)[-1].split('--&gt;')
            found, _, new_p = g.recursiveUNLFind(unl, new_c)
            if not found:
                g.es("No perfect match, not creating backlink")
                return
            new_c.backlinkController.initBacklink(new_p.v)
            if our_unl not in [i.rsplit('##', 1)[0] for i in new_p.v.u['_bklnk']['urls']]:
                new_p.v.u['_bklnk']['urls'].append("%s##%s" % (our_unl, self.c.p.h))
                new_c.backlinkController.updateTabInt()
                new_p.setDirty()
                new_c.setChanged()
                g.es("NOTE: created back link automatically")
    else:
        g.handleUrl(url, c=self.c)
</t>
<t tx="tbnorth.20170616135915.1">def nextLink(self):
    """nextLink - jump to next node with a link
    """

    c = self.c
    hits = [[]]  # hits/including before the current node

    current = c.p.v

    for v in c.all_unique_nodes():

        if '_bklnk' in v.u and (
          v.u['_bklnk']['links'] or v.u['_bklnk'].get('urls')):
            hits[-1].append(v)
        # forgo this optimization in favor of total count
        # if len(hits) &gt; 1 and hits[-1]):
        #     break  # got one after the current node
        if v == current:
            hits.append([])  # hits after the current node

    total = sum(map(len, hits))
    g.es("%d nodes with links" % total)
    if hits[1]:
        c.selectPosition(c.vnode2position(hits[1][0]))
        return
    if total == 0:
        return
    g.es("Search wrapped")
    c.selectPosition(c.vnode2position(hits[0][0]))
</t>
<t tx="tbnorth.20170925093004.1">def _date(self, d):
    """_date - convert a string to a date

    :param str d: date to convert
    :return: datetime.date
    """
    if not d.strip():
        return ''
    return datetime.datetime.strptime(d.split('T')[0], "%Y-%m-%d").date()

def _time(self, d):
    """_time - convert a string to a time

    :param str d: time to convert
    :return: datetime.time
    """
    if not d.strip():
        return ''
    return datetime.datetime.strptime(d, "%H:%M:%S.%f").time()
</t>
<t tx="tbrown.20070117104409.4">class quickMove:

    """quickMove binds to a controller, adds menu entries for
       creating buttons, and creates buttons as needed
    """

    flavors = [
      # name   first/last  long  short
      ('move', True, "Move", "to"),
      ('copy', True, "Copy", "to"),
      ('clone', True, "Clone", "to"),
      ('bkmk', True, "Bookmark", "to"),
      ('linkTo', False, "Link", "to"),
      ('linkFrom', False, "Link", "from"),
      ('jump', False, "Jump to", ""),
    ]

    @others

</t>
<t tx="tbrown.20070117104409.5">class quickMoveButton:

    """contains target data and function for moving node"""

    @others
</t>
<t tx="tbrown.20090119215428.10">priorities = {
  1: {'long': 'Urgent',    'short': '1', 'icon': 'pri1.png'},
  2: {'long': 'Very High', 'short': '2', 'icon': 'pri2.png'},
  3: {'long': 'High',      'short': '3', 'icon': 'pri3.png'},
  4: {'long': 'Medium',    'short': '4', 'icon': 'pri4.png'},
  5: {'long': 'Low',       'short': '5', 'icon': 'pri5.png'},
  6: {'long': 'Very Low',  'short': '6', 'icon': 'pri6.png'},
  7: {'long': 'Sometime',  'short': '7', 'icon': 'pri7.png'},
  8: {'long': 'Level 8',   'short': '8', 'icon': 'pri8.png'},
  9: {'long': 'Level 9',   'short': '9', 'icon': 'pri9.png'},
 10: {'long': 'Level 0',   'short': '0', 'icon': 'pri0.png'},
 19: {'long': 'To do',     'short': 'o', 'icon': 'chkboxblk.png'},
 20: {'long': 'Bang',      'short': '!', 'icon': 'bngblk.png'},
 21: {'long': 'Cross',     'short': 'X', 'icon': 'xblk.png'},
 22: {'long': '(cross)',   'short': 'x', 'icon': 'xgry.png'},
 23: {'long': 'Query',     'short': '?', 'icon': 'qryblk.png'},
 24: {'long': 'Bullet',    'short': '-', 'icon': 'bullet.png'},
100: {'long': 'Done',      'short': 'D', 'icon': 'chkblk.png'},
}

todo_priorities = 1,2,3,4,5,6,7,8,9,10,19

_date_fields = ['created', 'date', 'duedate', 'nextworkdate', 'prisetdate']
_time_fields = ['duetime', 'nextworktime', 'time']
_datetime_fields = _date_fields + _time_fields
</t>
<t tx="tbrown.20090119215428.11">def __init__ (self,c):
    '''ctor for todoController class.'''
    self.c = c
    c.cleo = self
    self.donePriority = 100
    self.menuicons = {}  # menu icon cache
    self.recentIcons = []
    #X self.smiley = None
    self.redrawLevels = 0
    self._widget_to_style = None  # see updateStyle()
    self.reloadSettings()
    self.handlers = [
       ("close-frame",self.close),
       ('select3', self.updateUI),
       ('save2', self.loadAllIcons),
       ('idle', self.updateStyle),
    ]
    # chdir so the Icons can be located, needed for uic resources
    owd = os.getcwd()
    os.chdir(g.os_path_join(g.app.loadDir, '..', 'plugins'))
    self.ui = todoQtUI(self)
    os.chdir(owd)
    for i in self.handlers:
        g.registerHandler(i[0], i[1])
    self.loadAllIcons()
    # correct spinTime suffix:
    self.ui.UI.spinTime.setSuffix(" " + self.time_name)
    # #1591: patch labels if necessary.
    self.patch_1591()
</t>
<t tx="tbrown.20090119215428.12">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.time_name = c.config.getString('todo-time-name') or 'days'
    self.icon_location = c.config.getString('todo-icon-location') or 'beforeHeadline'
    self.prog_location = c.config.getString('todo-prog-location') or 'beforeHeadline'
    self.icon_order = c.config.getString('todo-icon-order') or 'pri-first'
</t>
<t tx="tbrown.20090119215428.13">def redrawer(fn):
    """decorator for methods which create the need for a redraw"""
    # pylint: disable=no-self-argument
    def todo_redrawer_callback(self, *args, **kargs):
        self.redrawLevels += 1
        try:
            # pylint: disable=not-callable
            ans = fn(self,*args, **kargs)
        finally:
            self.redrawLevels -= 1
            if self.redrawLevels == 0:
                self.redraw()
        return ans
    return todo_redrawer_callback
</t>
<t tx="tbrown.20090119215428.14">def projectChanger(fn):
    """decorator for methods which change projects"""
    # pylint: disable=no-self-argument
    def project_changer_callback(self, *args, **kargs):
        # pylint: disable=not-callable
        ans = fn(self,*args, **kargs)
        self.update_project()
        return ans
    return project_changer_callback
</t>
<t tx="tbrown.20090119215428.15">@redrawer
def loadAllIcons(self, tag=None, k=None, clear=None):
    """Load icons to represent cleo state"""
    for p in self.c.all_positions():
        self.loadIcons(p, clear=clear)
</t>
<t tx="tbrown.20090119215428.16">@redrawer
def loadIcons(self, p,clear=False):

    com = self.c.editCommands
    allIcons = com.getIconList(p)
    icons = [i for i in allIcons if 'cleoIcon' not in i]
    if self.icon_order == 'pri-first':
        iterations = ['priority', 'progress', 'duedate']
    else:
        iterations = ['progress', 'priority', 'duedate']
    if clear:
        iterations = []
    today = datetime.date.today()
    for which in iterations:
        if which == 'priority':
            pri = self.getat(p.v, 'priority')
            if pri: pri = int(pri)
            if pri in self.priorities:
                com.appendImageDictToList(icons, g.os_path_join('cleo', self.priorities[pri]['icon']),
                    2, on='vnode', cleoIcon='1', where=self.icon_location)
                    # Icon location defaults to 'beforeIcon' unless cleo_icon_location global defined.
                    # Example: @strings[beforeIcon,beforeHeadline] cleo_icon_location = beforeHeadline
        elif which == 'progress':
            prog = self.getat(p.v, 'progress')
            # pylint: disable=literal-comparison
            if prog != '':
                prog = int(prog or 0)
                use = prog//10*10
                use = 'prg%03d.png' % use
                com.appendImageDictToList(icons, g.os_path_join('cleo', use),
                    2, on='vnode', cleoIcon='1', where=self.prog_location)
        elif which == 'duedate':
            duedate = self.getat(p.v, 'duedate')
            nextworkdate = self.getat(p.v, 'nextworkdate')
            icondate = min(duedate or NO_TIME, nextworkdate or NO_TIME)
            if icondate != NO_TIME:
                if icondate &lt; today:
                    icon = "date_past.png"
                elif icondate == today:
                    icon = "date_today.png"
                else:
                    icon = "date_future.png"
                com.appendImageDictToList(icons, g.os_path_join('cleo', icon),
                    2, on='vnode', cleoIcon='1', where=self.prog_location)

    com.setIconList(p, icons, setDirty=False)
</t>
<t tx="tbrown.20090119215428.17">def close(self, tag, key):
    "unregister handlers on closing commander"

    if self.c != key['c']: return  # not our problem

    for i in self.handlers:
        g.unregisterHandler(i[0], i[1])
</t>
<t tx="tbrown.20090119215428.18">def showHelp(self):
    g.es('Check the Plugins menu Todo entry')
</t>
<t tx="tbrown.20090119215428.19">@
annotate was the previous name of this plugin, which is why the default values
for several keyword args is 'annotate'.
</t>
<t tx="tbrown.20090119215428.20">def delUD (self,node,udict="annotate"):

    ''' Remove our dict from the node'''

    if (hasattr(node,"unknownAttributes") and
        udict in node.unknownAttributes
    ):

        del node.unknownAttributes[udict]
</t>
<t tx="tbrown.20090119215428.21">def hasUD (self,node,udict="annotate"):

    ''' Return True if the node has an UD.'''

    return (
        hasattr(node,"unknownAttributes") and
        udict in node.unknownAttributes and
        isinstance(node.unknownAttributes.get(udict), dict)
    )
</t>
<t tx="tbrown.20090119215428.22">def getat(self, node, attrib):
    "new attribute getter"
    if (hasattr(node,'unknownAttributes') and
        "annotate" in node.unknownAttributes and
        isinstance(node.unknownAttributes["annotate"], dict) and
        attrib in node.unknownAttributes["annotate"]
    ):
        x = node.unknownAttributes["annotate"][attrib]
        if attrib in self._date_fields and isinstance(x, str):
            x = self._date(x)
        if attrib in self._time_fields and isinstance(x, str):
            x = self._time(x)
        return x
    return 9999 if attrib == "priority" else ''
</t>
<t tx="tbrown.20090119215428.23">def testDefault(self, attrib, val):
    "return true if val is default val for attrib"
    # pylint: disable=consider-using-ternary
    return attrib == "priority" and val == 9999 or val == ""
</t>
<t tx="tbrown.20090119215428.24">def setat(self, node, attrib, val):
    "new attribute setter"

    if attrib in self._datetime_fields and isinstance(val,
        (datetime.date, datetime.time, datetime.datetime)):
        val = val.isoformat()

    if 'annotate' in node.u and 'src_unl' in node.u['annotate']:

        if (not hasattr(node, '_cached_src_vnode') or
            not node._cached_src_vnode
        ):
            src_unl = node.u['annotate']['src_unl']
            c1 = self.c
            p1 = c1.vnode2position(node)
            c2, p2 = self.unl_to_pos(src_unl, p1)
            if p2 is None:
                g.es("Failed to access '%s' for attribute update." % src_unl)
            else:
                node._cached_src_c = c2
                node._cached_src_vnode = p2.v

        # if the above succeeded in getting the required attributes
        if (hasattr(node, '_cached_src_vnode') and
            node._cached_src_vnode
        ):
            node._cached_src_c.cleo.setat(node._cached_src_vnode, attrib, val)
            op = node._cached_src_c.vnode2position(node._cached_src_vnode)
            node._cached_src_c.cleo.loadIcons(op)
            node._cached_src_c.cleo.updateUI(k={'c': node._cached_src_c})
            node._cached_src_c.setChanged()

    isDefault = self.testDefault(attrib, val)

    if (not hasattr(node,'unknownAttributes') or
        "annotate" not in node.unknownAttributes or
        not isinstance(node.unknownAttributes["annotate"], dict)
    ):
        # dictionary doesn't exist
        if isDefault:
            return  # don't create dict. for default value
        if not hasattr(node,'unknownAttributes'):  # node has no unknownAttributes
            node.unknownAttributes = {}
            node.unknownAttributes["annotate"] = {}
        elif("annotate" not in node.unknownAttributes or
             not isinstance(node.unknownAttributes["annotate"], dict)
        ):
            node.unknownAttributes["annotate"] = {}
        # node.unknownAttributes["annotate"]['created'] = datetime.datetime.now()
        node.unknownAttributes["annotate"][attrib] = val
        return

    # dictionary exists
    if (attrib not in node.unknownAttributes["annotate"] or
        node.unknownAttributes["annotate"][attrib] != val
    ):
        self.c.setChanged()
        node.setDirty()

    node.unknownAttributes["annotate"][attrib] = val

    if isDefault:  # check if all default, if so drop dict.
        self.dropEmpty(node, dictOk = True)
</t>
<t tx="tbrown.20090119215428.25">def dropEmpty(self, node, dictOk = False):

    if (dictOk or
        hasattr(node,'unknownAttributes') and
        "annotate" in node.unknownAttributes and
        isinstance(node.unknownAttributes["annotate"], dict)
    ):
        isDefault = True
        for ky, vl in node.unknownAttributes["annotate"].items():

            if not self.testDefault(ky, vl):
                isDefault = False
                break

        if isDefault:  # no non-defaults seen, drop the whole cleo dictionary
            del node.unknownAttributes["annotate"]
            self.c.setChanged()
            return True

    return False
</t>
<t tx="tbrown.20090119215428.26">def safe_del(self, d, k):
    "delete a key from a dict. if present"
    if k in d: del d[k]
</t>
<t tx="tbrown.20090119215428.27"></t>
<t tx="tbrown.20090119215428.28" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323031382d30382d31387103752e">def redraw(self):

    self.updateUI()
    if not g.app.initing:
        self.c.redraw()
            # This is disabled (converted to redraw_later) during startup.
</t>
<t tx="tbrown.20090119215428.29">@redrawer
def clear_all(self, recurse=False, all=False):

    if all:
        what = self.c.all_positions()
    elif recurse:
        what = self.c.currentPosition().self_and_subtree()
    else:
        what = iter([self.c.currentPosition()])

    for p in what:
        self.delUD(p.v)
        self.loadIcons(p)
        self.show_times(p)

</t>
<t tx="tbrown.20090119215428.30"></t>
<t tx="tbrown.20090119215428.31">@redrawer
@projectChanger
def progress_clear(self,v=None):

    self.setat(self.c.currentPosition().v, 'progress', '')
</t>
<t tx="tbrown.20090119215428.32">@redrawer
@projectChanger
def set_progress(self,p=None, val=None):
    if p is None:
        p = self.c.currentPosition()
    v = p.v

    if val is None: return

    self.setat(v, 'progress', val)
</t>
<t tx="tbrown.20090119215428.33">@redrawer
@projectChanger
def set_time_req(self,p=None, val=None):
    if p is None:
        p = self.c.currentPosition()
    v = p.v
    if val is None:
        return
    self.setat(v, 'time_req', val)
    if self.getat(v, 'progress') == '':
        self.setat(v, 'progress', 0)
</t>
<t tx="tbrown.20090119215428.34">@redrawer
def show_times(self, p=None, show=False):

    def rnd(x):
        return re.sub('.0$', '', '%.1f' % x)

    if p is None:
        p = self.c.currentPosition()

    for nd in p.self_and_subtree():
        nd.h = re.sub(' &lt;[^&gt;]*&gt;$', '', nd.headString())
        tr = self.getat(nd.v, 'time_req')
        pr = self.getat(nd.v, 'progress')
        try: pr = float(pr)
        except Exception: pr = ''
        if tr != '' or pr != '':
            ans = ' &lt;'
            if tr != '':
                if pr == '' or pr == 0 or pr == 100:
                    ans += rnd(tr) + ' ' + self.time_name
                else:
                    ans += '%s+%s=%s %s' % (rnd(pr/100.*tr), rnd((1-pr/100.)*tr), rnd(tr), self.time_name)
                if pr != '': ans += ', '
            if pr != '':
                ans += rnd(pr) + '%'  # pr may be non-integer if set by recalc_time
            ans += '&gt;'

            if show:
                nd.h = nd.h+ans
            self.loadIcons(nd)  # update progress icon

</t>
<t tx="tbrown.20090119215428.35">def recalc_time(self, p=None, clear=False):

    if p is None:
        p = self.c.currentPosition()

    v = p.v
    time_totl = None
    time_done = None

    # get values from children, if any
    for cn in p.children():
        ans = self.recalc_time(cn.copy(), clear)
        if time_totl is None:
            time_totl = ans[0]
        else:
            if ans[0] is not None: time_totl += ans[0]

        if time_done is None:
            time_done = ans[1]
        else:
            if ans[1] is not None: time_done += ans[1]

    if time_totl is not None:  # some value returned

        if clear:  # then we should just clear our values
            self.setat(v, 'progress', '')
            self.setat(v, 'time_req', '')
            return (time_totl, time_done)

        if time_done is not None:  # some work done
            # can't round derived progress without getting bad results form show_times
            if time_totl == 0:
                pr = 0.
            else:
                pr = float(time_done) / float(time_totl) * 100.
            self.setat(v, 'progress', pr)
        else:
            self.setat(v, 'progress', 0)
        self.setat(v, 'time_req', time_totl)
    else:  # no values from children, use own
        tr = self.getat(v, 'time_req')
        pr = self.getat(v, 'progress')
        if tr != '':
            time_totl = tr
            if pr != '':
                time_done = float(pr) / 100. * tr
            else:
                self.setat(v, 'progress', 0)

    return (time_totl, time_done)
</t>
<t tx="tbrown.20090119215428.36">@redrawer
@projectChanger
def clear_time_req(self, p=None):

    if p is None:
        p = self.c.currentPosition()
    v = p.v
    self.setat(v, 'time_req', '')
</t>
<t tx="tbrown.20090119215428.37">@redrawer
def update_project(self, p=None):
    """Find highest parent with '@project' in headline and run recalc_time
    and maybe show_times (if headline has '@project time')"""

    if p is None:
        p = self.c.currentPosition()
    project = None

    for nd in p.self_and_parents():
        if nd.headString().find('@project') &gt; -1:
            project = nd.copy()

    if project:
        self.recalc_time(project)
        if project.headString().find('@project time') &gt; -1:
            self.show_times(project, show=True)
        else:
            self.show_times(p, show=True)
    else:
        self.show_times(p, show=False)
</t>
<t tx="tbrown.20090119215428.38">@redrawer
def local_recalc(self, p=None):
    self.recalc_time(p)
</t>
<t tx="tbrown.20090119215428.39">@redrawer
def local_clear(self, p=None):
    self.recalc_time(p, clear=True)
</t>
<t tx="tbrown.20090119215428.40"></t>
<t tx="tbrown.20090119215428.41">@redrawer
def childrenTodo(self, p=None):
    if p is None:
        p = self.c.currentPosition()
    for p in p.children():
        if self.getat(p.v, 'priority') != 9999: continue
        self.setat(p.v, 'priority', 19)
        self.loadIcons(p)
</t>
<t tx="tbrown.20090119215428.42">@redrawer
def find_todo(self, p=None, stage = 0):
    """Recursively find the next todo"""

    # search is like XPath 'following' axis, all nodes after p in document order.
    # returning True should always propogate all the way back up to the top
    # stages: 0 - user selected start node, 1 - searching siblings, parents siblings, 2 - searching children

    if p is None:
        p = self.c.currentPosition()

    # see if this node is a todo
    if stage != 0 and self.needs_doing(p.v):
        if p.getParent():
            self.c.selectPosition(p.getParent())
            self.c.expandNode()
        self.c.selectPosition(p)
        return True

    for nd in p.children():
        if self.find_todo(nd, stage = 2): return True

    if stage &lt; 2 and p.getNext():
        if self.find_todo(p.getNext(), stage = 1): return True

    if stage &lt; 2 and p.getParent() and p.getParent().getNext():
        if self.find_todo(p.getParent().getNext(), stage = 1): return True

    if stage == 0: g.es("None found")

    return False
</t>
<t tx="tbrown.20090119215428.43">def prikey(self, v):
    """key function for sorting by priority"""
    # getat returns 9999 for nodes without priority, so you'll only get -1
    # if a[1] is not a node.  Or even an object.

    try:
        pa = int(self.getat(v, 'priority'))
    except ValueError:
        pa = -1

    return pa if pa != 24 else 0
</t>
<t tx="tbrown.20090119215428.44">@redrawer
def priority_clear(self,v=None):

    if v is None:
        v = self.c.currentPosition().v
    self.setat(v, 'priority', 9999)
    self.loadIcons(self.c.currentPosition())
</t>
<t tx="tbrown.20090119215428.45">@redrawer
def priSort(self, p=None):
    if p is None:
        p = self.c.currentPosition()
    self.c.selectPosition(p)
    self.c.sortSiblings(key=self.prikey)
</t>
<t tx="tbrown.20090119215428.46">@redrawer
def reclassify(self, p=None):
    """change priority codes"""

    if p is None:
        p = self.c.currentPosition()
    g.es('\n Current distribution:')
    self.showDist()
    dat = {}
    for end in 'from', 'to':
        if QtConst:
            x0,ok = QtWidgets.QInputDialog.getText(None, 'Reclassify priority' ,'%s priorities (1-9,19)'%end)
            if not ok:
                x0 = None
            else:
                x0 = str(x0)
        else:
            x0 = g.app.gui.runAskOkCancelStringDialog(
                self.c,'Reclassify priority' ,'%s priorities (1-7,19)' % end.upper())
        try:
            while re.search(r'\d+-\d+', x0):
                what = re.search(r'\d+-\d+', x0).group(0)
                rng = [int(n) for n in what.split('-')]
                repl = []
                if rng[0] &gt; rng[1]:
                    for n in range(rng[0], rng[1]-1, -1):
                        repl.append(str(n))
                else:
                    for n in range(rng[0], rng[1]+1):
                        repl.append(str(n))
                x0 = x0.replace(what, ','.join(repl))

            x0 = [int(i) for i in x0.replace(',',' ').split()]
                  # if int(i) in self.todo_priorities]
        except Exception:
            g.es('Not understood, no action')
            return
        if not x0:
            g.es('No action')
            return
        dat[end] = x0

    if len(dat['from']) != len(dat['to']):
        g.es('Unequal list lengths, no action')
        return

    cnt = 0
    for p in p.subtree():
        pri = int(self.getat(p.v, 'priority'))
        if pri in dat['from']:
            self.setat(p.v, 'priority', dat['to'][dat['from'].index(pri)])
            self.loadIcons(p)
            cnt += 1
    g.es('\n%d priorities reclassified, new distribution:' % cnt)
    self.showDist()
</t>
<t tx="tbrown.20090119215428.47">@redrawer
def setPri(self,pri):

    if pri in self.recentIcons:
        self.recentIcons.remove(pri)
    self.recentIcons.insert(0, pri)
    self.recentIcons = self.recentIcons[:3]

    p = self.c.currentPosition()
    self.setat(p.v, 'priority', pri)
    self.setat(p.v, 'prisetdate', str(datetime.date.today()))
    self.loadIcons(p)
</t>
<t tx="tbrown.20090119215428.48">def showDist(self, p=None):
    """show distribution of priority levels in subtree"""
    if p is None:
        p = self.c.currentPosition()
    pris = {}
    for p in p.subtree():
        pri = int(self.getat(p.v, 'priority'))
        if pri not in pris:
            pris[pri] = 1
        else:
            pris[pri] += 1
    pris = sorted([(k,v) for k,v in pris.items()])
    for pri in pris:
        if pri[0] in self.priorities:
            g.es('%s\t%d\t%s\t(%s)' % (self.priorities[pri[0]]['short'], pri[1],
                self.priorities[pri[0]]['long'],pri[0]))
</t>
<t tx="tbrown.20090119215428.49">def updateUI(self,tag=None,k=None):

    if k and k['c'] != self.c:
        return  # wrong number

    v = self.c.currentPosition().v

    # check work date &lt; due date and do stylesheet re-evaluation stuff
    nwd = self.getat(v, 'nextworkdate')
    due = self.getat(v, 'duedate')
    w = self.ui.UI.frmDates
    if nwd and due and str(nwd) &gt; str(due):
        w.setProperty('style_class', 'tododate_error')
    else:
        w.setProperty('style_class', '')
    # update style on this widget on idle, see updateStyle()
    self._widget_to_style = (w, time.time())

    self.ui.setProgress(int(self.getat(v, 'progress') or 0 ))
    self.ui.setTime(float(self.getat(v, 'time_req') or 0 ))

    self.ui.setDueDate(self.getat(v, 'duedate'))
    # default is "", which is understood by setDueDate()
    self.ui.setDueTime(self.getat(v, 'duetime'))
    # ditto

    self.ui.setDueDate(self.getat(v, 'duedate'))
    self.ui.setDueTime(self.getat(v, 'duetime'))
    self.ui.setNextWorkDate(self.getat(v, 'nextworkdate'))
    self.ui.setNextWorkTime(self.getat(v, 'nextworktime'))
    # pylint: disable=maybe-no-member
    created = self.getat(v,'created')
    if created and isinstance(created, datetime.datetime) and created.year &gt;= 1900:
        self.ui.UI.createdTxt.setText(created.strftime("%d %b %y"))
        self.ui.UI.createdTxt.setToolTip(created.strftime("Created %H:%M %d %b %Y"))
    else:
        # .strftime doesn't work here! This has has happened...
        try:
            gdate = self.c.p.v.gnx.split('.')[1][:12]
            created = datetime.datetime.strptime(gdate, '%Y%m%d%H%M')
            if created.year &lt; 1900:
                created = None
        except Exception:
            created = None
        if created:
            self.ui.UI.createdTxt.setText(created.strftime("Created %d %b %Y"))
            self.ui.UI.createdTxt.setToolTip(created.strftime("gnx created %H:%M %d %b %Y"))
        else:
            self.ui.UI.createdTxt.setText("")

    # Update the label.
    h = self.c and self.c.p and self.c.p.h
    due = self.getat(v, 'duedate')
    ago = (datetime.date.today()-created.date()).days if created else 0
    if due:
        days = (due - datetime.date.today()).days
        txt = f"{h}\nCreated {ago} days ago, due in {days}"
    else:
        txt = f"{h}\nCreated {ago} days ago"
    self.ui.UI.txtDetails.setText(txt)
    prisetdate = self.getat(v, 'prisetdate')
    self.ui.UI.txtDetails.setToolTip("Priority set %s" %
        (str(prisetdate).strip() or '?')
    )
</t>
<t tx="tbrown.20090119215428.9">class todoController:

    '''A per-commander class that manages tasks.'''

    @others
</t>
<t tx="tbrown.20090219095555.63">def handleUrl(url, c=None, p=None):
    """Open a url or a unl."""
    if c and not p:
        p = c.p
    urll = url.lower()
    if urll.startswith('@url'):
        url = url[4:].lstrip()
    if (
        urll.startswith('unl:' + '//') or
        urll.startswith('file://') and url.find('--&gt;') &gt; -1 or
        urll.startswith('#')
    ):
        return g.handleUnl(url, c)
    try:
        return g.handleUrlHelper(url, c, p)
    except Exception:
        g.es_print("exception opening", repr(url))
        g.es_exception()
        return None
</t>
<t tx="tbrown.20090522142657.7894">def __del__(self):
    for i in self.handlers:
        g.unregisterHandler(i[0], i[1])
</t>
<t tx="tbrown.20090630144958.5319">def addPopupMenu(self,c,p,menu):

    def rnd(x):
        return re.sub('.0$', '', '%.1f' % x)
    taskmenu = menu.addMenu("Task")
    submenu = taskmenu.addMenu("Status")
    iconlist = [(menu, i) for i in self.recentIcons]
    iconlist.extend([(submenu, i) for i in self.priorities])
    for m,i in iconlist:
        icon = self.menuicon(i)
        a = m.addAction(icon, self.priorities[i]["long"])
        a.setIconVisibleInMenu(True)
        def icon_cb(checked, pri=i):
            self.setPri(pri)
        a.triggered.connect(icon_cb)
    submenu = taskmenu.addMenu("Progress")
    for i in range(11):
        icon = self.menuicon(10*i, progress=True)
        a = submenu.addAction(icon, "%d%%" % (i*10))
        a.setIconVisibleInMenu(True)
        def progress_cb(checked, prog=i):
            self.set_progress(val=10*prog)
        a.triggered.connect(progress_cb)
    prog = self.getat(p.v, 'progress')
    if isinstance(prog,int):
        a = taskmenu.addAction("(%d%% complete)"%prog)
        a.setIconVisibleInMenu(True)
        a.enabled = False
    time_ = self.getat(p.v, 'time_req')
    if isinstance(time_,float):
        if isinstance(prog,int):
            f = prog/100.
            a = taskmenu.addAction("(%s+%s=%s %s)"%(rnd(f*time_),
                rnd((1.-f)*time_),rnd(time_), self.time_name))
        else:
            a = taskmenu.addAction("(%s %s)"%(rnd(time_), self.time_name))
        a.enabled = False
    todoQtUI.populateMenu(taskmenu, self)
</t>
<t tx="tbrown.20090630144958.5320">def menuicon(self, pri, progress=False):
    """return icon from cache, placing it there if needed"""

    if progress:
        prog = pri
        pri = 'prog-%d'%pri

    if pri not in self.menuicons:

        if progress:
            fn = 'prg%03d.png' % prog
        else:
            fn = self.priorities[pri]["icon"]

        # use getImageImage because it's theme aware
        fn = g.os_path_join('cleo', fn)
        self.menuicons[pri] = QtGui.QIcon(g.app.gui.getImageImage(fn))

    return self.menuicons[pri]
</t>
<t tx="tbrown.20091005145931.5227">def fixIDs(self, c):

    update = {}

    for v in c.all_unique_nodes():
        # collect old -&gt; new ID mapping
        if (hasattr(v, 'unknownAttributes') and
            '_bklnk' in v.u and
            'id' in v.u['_bklnk']
        ):
            update[v.u['_bklnk']['id']] = v.gnx

    for v in c.all_unique_nodes():
        if (hasattr(v, 'unknownAttributes') and '_bklnk' in v.u):

            if 'id' in v.u['_bklnk']:
                # remove old id
                del v.u['_bklnk']['id']

            if 'links' in v.u['_bklnk']:
                v.u['_bklnk']['links'] = [
                    i for i in v.u['_bklnk']['links']
                    if i[1] not in update
                ]
                v.u['_bklnk']['links'].extend([
                    (i[0], update[i[1]]) for i in v.u['_bklnk']['links']
                    if i[1] in update])
</t>
<t tx="tbrown.20091009210724.10979">class attrib_edit_Controller:

    '''A per-commander class that manages attribute editing.'''

    @others
</t>
<t tx="tbrown.20091009210724.10981">def __init__ (self, c):

    self.c = c
    c.attribEditor = self
    self.pname = "_attrib_edit_frame"  # used to tag out panel
    self.reloadSettings()
    self.attrPaths = set()  # set of tuples (getter-class, path)
    self.handlers = [
       ('select3', self.updateEditor),
    ]
    for i in self.handlers:
        g.registerHandler(i[0], i[1])
    # 'body' or 'tab' mode
    # self.guiMode = c.config.getString('attrib-edit-placement') or 'tab'
    self.guiMode = 'tab'
    # body mode in not compatible with nested_splitter, causes hard crash
    if self.guiMode == 'body':
        self.holder = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        self.holder.setMinimumWidth(300)
        parent = c.frame.top.leo_body_frame.parent()
        self.holder.addWidget(c.frame.top.leo_body_frame)
        parent.addWidget(self.holder)
        self.parent = self.holder
    elif self.guiMode == 'tab':
        self.parent = QtWidgets.QFrame()
        self.holder = QtWidgets.QHBoxLayout()
        self.parent.setLayout(self.holder)
        c.frame.log.createTab('Attribs', widget = self.parent)
        
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    active = c.config.getData('attrib_edit_active_modes') or []
    self.getsetters = []
    for i in AttributeGetter.implementations:
        s = i(c)
        self.getsetters.append([s, (s.name() in active) ])
    if not active:
        self.getsetters[0][1] = True  # turn on the first one
</t>
<t tx="tbrown.20091009210724.10983">def __del__(self):
    for i in self.handlers:
        g.unregisterHandler(i[0], i[1])
</t>
<t tx="tbrown.20091009210724.11047">def updateEditor(self,tag,k):
    """update edit panel when new node selected"""

    if k['c'] != self.c: return  # not our problem

    self.updateEditorInt()
</t>
<t tx="tbrown.20091009210724.11210">def initForm(self):
    """set up self.form, the blank form layout before adding edit widgets"""
    self.editors = []

    w = self.holder

    for i in w.parent().findChildren(QtCore.QObject):
        if i.objectName() == self.pname:
            i.hide()
            i.deleteLater()

    pnl = QtWidgets.QFrame()
    pnl.setObjectName(self.pname)
    self.form = QtWidgets.QFormLayout()
    self.form.setVerticalSpacing(0)
    pnl.setLayout(self.form)
    pnl.setAutoFillBackground(True)
    w.addWidget(pnl)
</t>
<t tx="tbrown.20091010211613.5257">class editWatcher:
    """class to supply widget for editing attribute and handle
    its textChanged signal"""

    def __init__(self, c, v, class_, name, value, path, type_):
        """v - node whose attribute we edit
        name - name of edited attribute
        value - initial value of edited attribute
        path - dictionary key path to attribute in v.u
        type_ - attribute type
        """
        self.c = c
        self.v = v
        self.class_ = class_
        self.name = name
        self.value = value
        self.path = path
        self.type_ = type_
        self._widget = None

    def widget(self):
        """return widget for editing this attribute"""
        if not self._widget:
            self._widget = w = QtWidgets.QLineEdit(str(self.value))
            w.textChanged.connect(self.updateValue)
                # QtCore.QObject.connect(w,
                    # QtCore.SIGNAL("textChanged(QString)"), self.updateValue)
            self._widget.focusOutEvent = self.lostFocus
            # see lostFocus()
        return self._widget

    def updateValue(self, newValue):
        """copy value from widget to v.u"""
        self.class_.setAttrib(self.v, self.path, self.type_(newValue))
        self.v.setDirty()

    def lostFocus(self, event):
        """Can activate this in in widget(), but it stops tabbing through
        the attributes - unless we can check that none of our siblings
        has focus..."""
        sibs = self._widget.parent().findChildren(QtWidgets.QLineEdit)
        for i in sibs:
            if i.hasFocus():
                break
        else:
            self.c.redraw()

    #X def setValue(a, path, value):
    #X     """copy value into dict a on path,
    #X     e.g. a['one']['more']['level'] = value
    #X     """
    #X     for i in path[:-1]:
    #X         a = a.setdefault(i, {})
    #X     a[path[-1]] = value
</t>
<t tx="tbrown.20091011151836.14788">def createAttrib(self, event=None, readonly=False):

    ans = []

    for getter, isOn in self.getsetters:
        if not isOn:
            continue

        if getter.helpCreate() is True:
            ans.append(getter)
        else:
            g.es("For '%s' attributes:\n  %s" % (getter.name(), getter.helpCreate()))

    if len(ans) &gt; 1:
        g.error('Eror: more than one attribute type (%s) active' %
        ', '.join([i.name() for i in ans]))
    elif ans:
        ans[0].createAttrib(self.c.currentPosition().v, gui_parent=self.parent)
        self.updateEditorInt()
        self.c.currentPosition().v.setDirty()
        self.c.redraw()
</t>
<t tx="tbrown.20091028100922.1493">def updateEditorInt(self):

    c = self.c

    self.initForm()
    for attr in self.getAttribs():
        class_, name, value, path, type_, readonly = attr
        if readonly:
            self.form.addRow(QtWidgets.QLabel(name), QtWidgets.QLabel(str(value)))

        else:
            editor = editWatcher(c, c.currentPosition().v, class_, name, value, path, type_)
            self.editors.append(editor)

            self.form.addRow(QtWidgets.QLabel(name), editor.widget())
</t>
<t tx="tbrown.20091028131637.1358">def manageAttrib(self):

    attribs = [(i[0],i[1],i[3]) for i in self.getAttribs()]

    dat = []
    for attr in self.attrPaths:

        txt = attr[0].longDescrip(attr[2])

        active = attr in attribs

        dat.append([txt, active, attr])

    if not dat:
        g.es('No attributes seen (yet)')
        return

    dat.sort(key=lambda x: x[0])

    res = ListDialog(self.parent, "Enter attribute path",
        "Enter path to attribute (space separated words)",
        dat)

    res.exec_()

    if res.result() == QtWidgets.QDialog.Rejected:
        return

    # check for deletions
    for i in dat:
        if i[2] in attribs and not i[1]:
            res = QtWidgets.QMessageBox(QtWidgets.QMessageBox.Question,
                "Really delete attributes?","Really delete attributes?",
                QtWidgets.QMessageBox.Ok|QtWidgets.QMessageBox.Cancel, self.parent)
            if res.exec_() == QtWidgets.QMessageBox.Cancel:
                return
            break

    # apply changes
    for i in dat:
        if i[2] in attribs and not i[1]:
            self.delAttrib(i[2])
        elif i[2] not in attribs and i[1]:
            self.addAttrib(i[2])

    self.updateEditorInt()
    self.c.redraw()

</t>
<t tx="tbrown.20091029101116.1413">def addAttrib(self, attrib):

    attrib[0].setAttrib(self.c.currentPosition().v, attrib[2], '')
</t>
<t tx="tbrown.20091029101116.1414">def delAttrib(self, attrib):

    attrib[0].delAttrib(self.c.currentPosition().v, attrib[2])
</t>
<t tx="tbrown.20091029101116.1424">def scanAttribs(self):
    """scan all of c for attrbutes"""
    for v in self.c.all_unique_nodes():
        self.getAttribs(v)  # updates internal list of attribs
    g.es("%d attributes found" % len(self.attrPaths))
</t>
<t tx="tbrown.20091103080354.1405"># def JUNKrecSearch(self, d, path, ans):
    # """recursive search of tree of dicts for values whose
    # key path is like [*][*][*]['_edit'][*] or
    # [*][*][*]['_edit']['_int'][*]

    # Modifies list ans
    # """
    # for k in d:
        # if isinstance(d[k], dict):
            # if k not in ('_edit', '_view'):
                # self.recSearch(d[k], path+[k], ans)
            # else:
                # # k == '_edit' or '_view'
                # for ek in d[k]:
                    # if ek in self.typeMap:
                        # # ek is '_int' or similar
                        # type_ = self.typeMap[ek]
                        # for ekt in d[k][ek]:
                            # ans.append((ekt, d[k][ek][ekt], tuple(path+['_edit',ek,ekt]),
                                # type_, k != '_edit'))
                    # else:
                        # ans.append((ek, d[k][ek], tuple(path+['_edit',ek]), str, k != '_edit'))
</t>
<t tx="tbrown.20091103080354.1406">def getAttribs(self, v = None):
    """Return a list of tuples describing editable uAs.

    (class, name, value, path, type, readonly)


    e.g.

    (class, 'created', '2009-09-23', ('stickynotes','_edit','created'), str, False),
    (class, 'cars', 2, ('inventory','_edit','_int','cars'), int, False)

    Changes should be written back to
    v.uA['stickynotes']['_edit']['created'] and
    v.uA['inventory']['_edit']['_int']['cars'] respectively
    """

    ans = []
    if not v:
        v = self.c.currentPosition().v

    for getter, isOn in self.getsetters:

        if not isOn:
            continue

        ans.extend(getter.getAttribs(v))


    for ns in ans:
        self.attrPaths.add( (ns[0], ns[1], ns[3]) )  # class, name, path

    return ans
</t>
<t tx="tbrown.20091103080354.1415">def manageModes(self):

    modes = [ [i[0].name(), i[1]] for i in self.getsetters ]

    res = ListDialog(self.parent, "Enter attribute path",
        "Enter path to attribute (space separated words)",
        modes)

    res.exec_()

    if res.result() == QtWidgets.QDialog.Rejected:
        return

    for n,i in enumerate(modes):
        self.getsetters[n][1] = i[1]

    self.updateEditorInt()
</t>
<t tx="tbrown.20091207102637.11494">def popup(self, c, p, menu):
    """make popup menu entry for tree context menu"""
    # pylint: disable=function-redefined
    # several callbacks have the same name.
    if c != self.c:
        return  # wrong commander
    for cb, name in reversed(self.recent_moves):
        a = QtWidgets.QAction(name, menu)
        a.triggered.connect(lambda checked, cb=cb, name=name: self.do_wrap(cb, name))
        menu.insertAction(menu.actions()[0], a)
    pathmenu = menu.addMenu("Move")
    # copy / cut to other outline
    cut = None
    for txt, cut in ("Copy to...", False), ("Move to...", True):
        sub = pathmenu.addMenu(txt)
        # global targets
        for target in g.app.db['_quickmove']['global_targets']:
            a = sub.addAction(target['name'])
            def cb(c2=target['unl'], cut=cut):
                self.to_other(c2, cut=cut)
            def wrap(checked, cb=cb, name=txt.strip('.')+' '+target['name']):
                self.do_wrap(cb, name)
            a.triggered.connect(wrap)
        # top of open outlines
        for c2 in g.app.commanders():
            a = sub.addAction("Top of " +
                g.os_path_basename(c2.fileName()))
            def cb(c2=c2, cut=cut):
                self.to_other(c2, cut=cut)
            def wrap(checked, cb=cb, name=txt.strip('.')+' top of '+g.os_path_basename(c2.fileName())):
                self.do_wrap(cb, name)
            a.triggered.connect(wrap)
    # bookmark to other outline
    sub = pathmenu.addMenu("Bookmark to...")
    # global targets
    for target in g.app.db['_quickmove']['global_targets']:
        a = sub.addAction(target['name'])
        def cb(c2=target['unl'], cut=cut):
            self.bookmark_other(c2)
        def wrap(checked, cb=cb, name="Bookmark to "+target['name']):
            self.do_wrap(cb, name)
        a.triggered.connect(wrap)
    # top of open outlines
    for c2 in g.app.commanders():
        a = sub.addAction(g.os_path_basename(c2.fileName()))
        def cb(c2=c2):
            self.bookmark_other(c2)
        def wrap(checked, cb=cb, name="Bookmark to top of "+g.os_path_basename(c2.fileName())):
            self.do_wrap(cb, name)
        a.triggered.connect(wrap)
    # actions within this outline
    need_submenu = 'Move', 'Copy', 'Clone', 'Bookmark', 'Link'
    current_kind = None
    current_submenu = None
    for name,dummy,command in self.local_imps:
        kind = name.split()[0]
        if kind in need_submenu:
            if current_kind != kind:
                current_submenu = pathmenu.addMenu(kind)
                current_kind = kind
        else:
            current_submenu = pathmenu
        a = current_submenu.addAction(name)
        a.triggered.connect(lambda checked, command=command: command())
    # add new global target, etc.
    a = pathmenu.addAction("Add node as target")
    a.triggered.connect(lambda checked, p=p: self.add_target(p))
    a = pathmenu.addAction("Show targets")
    a.triggered.connect(lambda checked, p=p: self.show_targets())
    a = pathmenu.addAction("Read targets")
    a.triggered.connect(lambda checked, p=p: self.read_targets())
</t>
<t tx="tbrown.20091207120031.5356">def __del__(self, c=None):
    # pylint: disable=unexpected-special-method-signature
    if g.app.gui.guiName() == "qt":
        g.tree_popup_handlers.remove(self.popup)
</t>
<t tx="tbrown.20091214233510.5353">class geotag_Controller:

    '''A per-commander class that manages geotagging.'''

    @others
</t>
<t tx="tbrown.20091214233510.5354">def __init__ (self, c):

    self.c = c
    c.geotag = self
</t>
<t tx="tbrown.20091214233510.5356">def callback(self, data):

    c = self.c
    p = c.p

    nd = self.getAttr(p)

    nd.h = '@LatLng %(lat)f %(lng)f %(zoom)d %(maptype)s  %(description)s ' % data
    c.setChanged()
    if hasattr(c, 'attribEditor'):
        c.attribEditor.updateEditorInt()
    c.redraw()
</t>
<t tx="tbrown.20091215204347.11403">@staticmethod
def getAttr(p):
    for nd in p.children():
        if nd.h.startswith('@LatLng '):
            break
    else:
        nd = p.insertAsLastChild()
    return nd
</t>
<t tx="tbrown.20091217114654.5372">def permanentButton (self, event=None, v=None, type_=None, first=None):
    """make buttons on this node permanent

    NOTE: includes buttons deleted"""

    c = self.c
    if not v:
        p = c.p
        v = p.v

    qm = c.quickMove

    if 'quickMove' not in v.u or 'buttons' not in v.u['quickMove']:
        # possibly deleting old style list
        v.u['quickMove'] = {'buttons':[]}

    cnt = 0
    for mover, button in qm.buttons:
        if (mover.target == v and
            (not type_ or mover.type_ == type_) and
            (not first or mover.which == first)
        ):  # TNB untested .first -&gt; .which
            cnt += 1
            v.u['quickMove']['buttons'].append(
                {'first':mover.which, 'type': mover.type_})

    if cnt:
        g.es('Made buttons permanent')
        c.setChanged()
    else:
        g.es("Didn't find button")
</t>
<t tx="tbrown.20091217114654.5374">def clearButton (self, event=None, v=None):
    """clear permanent buttons specs from uA"""
    c = self.c
    if not v:
        p = c.p
        v = p.v

    if 'quickMove' in v.u:
        del v.u['quickMove']
        c.setChanged()
        g.es('Removing buttons - reload to apply')
    else:
        g.es('Quickmove buttons not found')
</t>
<t tx="tbrown.20100114111020.15726">def computeUNL(self, p):

    p = p.copy()
    heads = []
    while p:
        heads.insert(0, p.h)
        p = p.parent()
    return "#"+"--&gt;".join(heads)
</t>
<t tx="tbrown.20100226095909.12783">class leoscreen_Controller:

    '''A per-commander class that manages screen interaction.'''

    @others
</t>
<t tx="tbrown.20100226095909.12784">def __init__ (self, c):
    """set up vars., prepare temporary file"""
    self.c = c
    c.leo_screen = self
    self.use_screen = None  # to select a particular screen session
    # skip line -1, which is usually a prompt and not interesting
    self.first_line = -2
    # pulling in lines from output, this is the next one to get
    self.next_unread_line = self.first_line
    # output from last command
    self.output = []
    self.old_output = []
    # file name for hardcopy and paste commands
    fd, self.tmpfile = tempfile.mkstemp()
    os.close(fd)
    # Settings
    self.reloadSettings()
    self._get_output()  # prime output diffing system
    self.popups = []  # store references to popup windows
    self.stack_frame = 0
        # used by jump to error commands, 0 = innermost frame
    
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    # line prefix for pasting results into leo (#, --, //, C, etc.)
    x = self.c.config.getString('leoscreen-prefix')
    self.get_line_prefix = x.replace('SPACE', ' ') if x else ''
    self.time_fmt = self.c.config.getString('leoscreen-time-fmt') or '%Y-%m-%d %H:%M:%S'
</t>
<t tx="tbrown.20100226095909.12785">def __del__(self):
    """remove temporary file"""
    try:
        os.unlink(self.tmpfile)
    except IOError:
        pass
</t>
<t tx="tbrown.20100226095909.12786">def screen_cmd(self, cmds):
    """Execute a screen command via screen -X"""
    cmd = [
        'screen',
    ]

    if self.use_screen:
        cmd.extend(['-d', '-r', self.use_screen.split()[0]])

    cmd.extend([
        '-X', 'eval',
        'msgwait 0',    # avoid waiting for message display
    ])
    cmd.extend(cmds)

    cmd.extend([
        'msgwait 5',
    ])

    proc = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,  # don't just inherit, which alters
        stderr=subprocess.PIPE)  # screen's behavior
    out, err = proc.communicate()
    return out, err
</t>
<t tx="tbrown.20100226095909.12787">def run_text(self, txt, c=None):
    """Send txt to screen"""

    if c and c != self.c:
        return

    if not c:
        c = self.c

    if not txt:
        return
        # otherwise there's an annoying delay for "Slurped zero chars" msg.

    if self.output:
        self.old_output = self.output
    self.output = []  # forget previous output (mostly)

    open(self.tmpfile,'w').write(txt)

    self.screen_cmd([
        'readbuf "%s"'%self.tmpfile,
        'paste .',
    ])
</t>
<t tx="tbrown.20100226095909.12788">def get_line(self, c=None):
    """Get the next line of output from the last command"""

    if c and c != self.c:
        return None
    if not c:
        c = self.c
    if not self.output:
        self._get_output()
    if not self.output:
        g.es('No output retreived')
        return ''
    line = self.output[self.next_unread_line]
    self.next_unread_line -= 1
    return line
</t>
<t tx="tbrown.20100421115534.14949">def get_prefix(self):
    """get the prefix for insertions from get_line"""

    x = g.app.gui.runAskOkCancelStringDialog(
        self.c,'Prefix for text loading' ,'Prefix for text loading')

    if x is not None:
        self.get_line_prefix = x
</t>
<t tx="tbrown.20100421115534.21602">def insert_line(self, line, c=None):
    """insert a line of text into the current body"""

    if not c:
        c = self.c

    editor = c.frame.body.wrapper

    insert_point = editor.getInsertPoint()
    editor.insert(insert_point, self.get_line_prefix+line+'\n')
    editor.setInsertPoint(insert_point)
    c.setChanged()
</t>
<t tx="tbrown.20100422203442.5579">def get_all(self, c=None):
    """Get all output from the last command"""

    if c and c != self.c:
        return None
    if not c:
        c = self.c
    self.output = None  # trick get_line into getting output
    self.get_line()     # updates self.output, ignore returned line
    sm = difflib.SequenceMatcher(None, self.old_output, self.output)
    x = sm.find_longest_match(0, len(self.old_output)-1, 0, len(self.output)-1)
    ans = self.output[:]
    del ans[x.b:x.b+x.size]
    return '\n'.join(ans[:self.first_line])
</t>
<t tx="tbrown.20100424115939.5735">def show(self, what, title=None, plain=False):

    try:
        from leo.core.leoQt import QtWidgets, QtGui
        QTextEdit, QTextCursor = QtWidgets.QTextEdit, QtGui.QTextCursor
    except ImportError:
        g.es("Need Qt for show command")
        return

    if not title:
        title = what.split('\n', 1)[0].strip()

    te = QTextEdit()
    te.setReadOnly(True)
    if plain:
        te.setText(what)
    else:
        te.setHtml("&lt;pre&gt;%s&lt;/pre&gt;" % what)
    te.setLineWrapMode(QTextEdit.NoWrap)
    te.resize(800, 600)
    te.setWindowTitle(title)
    te.moveCursor(QTextCursor.End)
    te.show()
    self.popups.append(te)
</t>
<t tx="tbrown.20100502155649.5599">def get_note(self, c=None):
    """Get all output from the last command"""

    if c and c != self.c:
        return

    if not c:
        c = self.c

    dat = self.get_all(c)

    p = c.currentPosition()
    n = p.insertAsLastChild()
    n.h = time.strftime(self.time_fmt)
    n.b = dat
    c.setChanged()
    c.selectPosition(n)
    c.redraw()
</t>
<t tx="tbrown.20100502155649.5605">def show_note(self):
    if stickynotes:
        stickynotes.stickynote_f({'c':self.c})
    else:
        g.es('stickynotes not available')

</t>
<t tx="tbrown.20100528205637.5725">def _get_output(self):
    """grab some output"""
    self.screen_cmd(['hardcopy -h "%s"'%self.tmpfile])
    # seems new output file isn't visible to the process
    # without this call
    cmd = ['ls', self.tmpfile]
    proc = subprocess.Popen(cmd,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.communicate()
    f = open(self.tmpfile, encoding='latin-1')
    self.output = f.read().strip().split('\n')
    self.next_unread_line = self.first_line
</t>
<t tx="tbrown.20100810095317.24878">def set_parent(self, v, first, type_):

    ans = []
    for i in self.buttons:
        if i[0].target is v and i[0].which == first and i[0].type_ == type_:
              # TNB untested .first -&gt; .which
            ans.append(i)

    if not ans:
        g.es("Didn't find button")
        return
    if len(ans) != 1:
        g.es("Note: found multiple %s/first=%s buttons, using first"%(type_,first))

    qmb, b = ans[0]

    # need to set 'parent' key in v.u['quickMove'] list item to gnx of parent

    parents = [[i[0].targetHeadString, False, i[0]] for i in self.buttons
               if i[0] is not qmb and not i[0].has_parent]

    if not parents:
        g.es("No suitable Move buttons found")
        return

    ld = ListDialog(None, 'Pick parent', 'Pick parent', parents)
    ld.exec_()

    if ld.result() == QtWidgets.QDialog.Rejected:
        return

    for i in parents:
        if i[1]:
            parent = i[2].target
            break
    else:
        return

    if 'quickMove' not in v.u or 'buttons' not in v.u['quickMove']:
        # make button permanent first
        self.permanentButton(v=v, type_=type_, first=first)

    for i in v.u['quickMove']['buttons']:
        if i['type'] == qmb.type_ and i['first'] == qmb.which:   # TNB untested .first -&gt; .which
            i['parent'] = parent.gnx
            break
    else:
        v.u['quickMove']['buttons'].append({'type':qmb.type_,
            'first':qmb.which, 'parent':parent.gnx})  # TNB untested .first -&gt; .which

    self.addButton(qmb.which, qmb.type_, v=qmb.target, parent=parent.gnx)  # TNB untested .first -&gt; .which
    self.buttons = [i for i in self.buttons if i[0] is not qmb]
    print(b)
    b.button.parent().layout().removeWidget(b.button)

    g.es('Moved to parent')
</t>
<t tx="tbrown.20110122085529.15388">def nodeitemForPos(self, pos=None):

    if not pos:
        pos = self.c.currentPosition()

    if pos.v not in self.nodeItem:
        return pos.v, None

    return pos.v, self.nodeItem[pos.v]
</t>
<t tx="tbrown.20110122085529.15400">def reset_zoom(self):

    self.canvasView.resetTransform()
    self.canvasView.current_scale = 0
</t>
<t tx="tbrown.20110122085529.15402">def layouts(self):

    if pygraphviz:
        return [
            ('PyGraphViz:', lambda: None),
            ('neato', lambda: self.layout('neato')),
            ('dot', lambda: self.layout('dot')),
            ('dot LR', lambda: self.layout('dot LR')),
        ]
    if pydot:
        return [
            ('PyDot:', lambda: None),
            ('neato', lambda: self.layout('neato')),
            ('dot', lambda: self.layout('dot')),
            ('dot LR', lambda: self.layout('dot LR')),
            ('fdp', lambda: self.layout('fdp')),
            ('circo', lambda: self.layout('circo')),
            ('osage', lambda: self.layout('osage')),
            ('sfdp', lambda: self.layout('sfdp')),
    ]
    return [('install pygraphviz or pydot for layouts', lambda: None)]

</t>
<t tx="tbrown.20110122085529.15403">def layout(self, type_):

    if pygraphviz:
        G = pygraphviz.AGraph(strict=False,directed=True)
        if type_ == 'dot LR':
            G.graph_attr['rankdir']='LR'
        type_ = type_.split()[0]
        G.graph_attr['ranksep']='0.125'
    elif pydot:
        G = pydot.Dot('graphname', graph_type='digraph')
        if type_ == 'dot LR':
            G.set_layout('dot')
            G.set('rankdir', 'LR')
        else:
            G.set_layout(type_)
        G.set('ranksep', '0.125')
    for from_, to in self.link.values():
        if pygraphviz:
            G.add_edge(
                (from_, from_.gnx),
                (to, to.gnx),
        )
        elif pydot:
            G.add_edge(pydot.Edge( from_.gnx, to.gnx ))

    for i in self.nodeItem:
        if pygraphviz:
            G.add_node( (i, i.gnx) )
        elif pydot:
            gnode = pydot.Node( i.gnx)
            # rect = self.nodeItem[i].boundingRect()
            G.add_node(gnode)
            for child in i.children:
                key = (i, child)
                if key not in self.hierarchyLinkItem or child not in self.nodeItem:
                    continue
                G.add_edge(pydot.Edge( i.gnx, child.gnx ))
    if pygraphviz:
        G.layout(prog=type_)
    elif pydot:
        tempName = tempfile.NamedTemporaryFile(dir=tempfile.gettempdir(), delete=False)
        G.write_dot(tempName.name)
        G = pydot.graph_from_dot_file(tempName.name)

    for i in self.nodeItem:
        if pygraphviz:
            gn = G.get_node( (i, i.gnx) )
            x,y = map(float, gn.attr['pos'].split(','))
            i.u['_bklnk']['x'] = x
            i.u['_bklnk']['y'] = -y
            self.nodeItem[i].setPos(x, -y)
            self.nodeItem[i].do_update()
        elif pydot:
            lst = G.get_node(''.join(['"', i.gnx, '"']))
            if lst:
                x,y = map(float, lst[0].get_pos().strip('"').split(','))
                i.u['_bklnk']['x'] = x
                i.u['_bklnk']['y'] = -y
                self.nodeItem[i].setPos(x, -y)
                self.nodeItem[i].do_update()
    if pydot:
        x,y,width,height = map(float, G.get_bb().strip('"').split(','))
        self.ui.canvasView.setSceneRect(self.ui.canvas.sceneRect().adjusted(x,y,width,height))
    self.do_update(adjust=False)
    self.center_graph()
    # self.ui.canvasView.centerOn(self.ui.canvas.sceneRect().center())
    # self.ui.canvasView.fitInView(self.ui.canvas.sceneRect(), QtConst.KeepAspectRatio)
</t>
<t tx="tbrown.20110205084504.15370">def scale_centers(self, direction):

    direction = 0.9 if direction &lt; 0 else 1.1

    minx = maxx = miny = maxy = None

    for i in self.nodeItem:

        if i.u['_bklnk']['x'] &lt; minx or minx is None:
            minx = i.u['_bklnk']['x']
        if i.u['_bklnk']['x'] &gt; maxx or maxx is None:
            maxx = i.u['_bklnk']['x']
        if i.u['_bklnk']['y'] &lt; miny or miny is None:
            miny = i.u['_bklnk']['y']
        if i.u['_bklnk']['y'] &gt; maxy or maxy is None:
            maxy = i.u['_bklnk']['y']

    midx = (minx + maxx) / 2.
    midy = (miny + maxy) / 2.

    bbox = self.ui.canvas.itemsBoundingRect()
    midx = bbox.center().x()
    midy = bbox.center().y()

    for i in self.nodeItem:

        i.u['_bklnk']['x'] = midx + (i.u['_bklnk']['x']-midx) * direction
        i.u['_bklnk']['y'] = midy + (i.u['_bklnk']['y']-midy) * direction
        self.nodeItem[i].setPos(i.u['_bklnk']['x'], i.u['_bklnk']['y'])
        self.nodeItem[i].do_update()

    self.do_update()

    self.center_graph()
</t>
<t tx="tbrown.20110205084504.19507">def center_graph(self):
    """scale and center current scene, and add space around it for movement
    """

    # scale and center current scene
    bbox = self.ui.canvas.itemsBoundingRect()
    self.ui.canvas.setSceneRect(bbox)
    self.ui.canvasView.updateSceneRect(bbox)
    self.ui.canvasView.fitInView(bbox, QtConst.KeepAspectRatio)
    self.ui.canvasView.centerOn(bbox.center())

    # and add space around it for movement
    adj = -bbox.width(), -bbox.height(), +bbox.width(), +bbox.height()
    bbox.adjust(*adj)
    self.ui.canvas.setSceneRect(bbox)
    self.ui.canvasView.updateSceneRect(bbox)

    self.ui.canvas.setSceneRect(bbox)
    self.ui.canvasView.updateSceneRect(bbox)

    self.ui.canvas.setSceneRect(bbox)
    self.ui.canvasView.updateSceneRect(bbox)
</t>
<t tx="tbrown.20110213091328.16233">def set_due_date(self,p=None, val=None, mode='adjust', field='duedate'):
    "mode: `adjust` for change in time, `check` for checkbox toggle"
    if p is None:
        p = self.c.currentPosition()
    v = p.v

    if field == 'duedate':
        toggle = self.ui.UI.dueDateToggle
    else:
        toggle = self.ui.UI.nxtwkDateToggle

    if mode == 'check':
        if toggle.checkState() == QtConst.Unchecked:
            self.setat(v, field, "")
        else:
            self.setat(v, field, val.toPyDate())
    else:
        toggle.setCheckState(QtConst.Checked)
        self.setat(v, field, val.toPyDate())

    self.updateUI()  # if change was made to date with offset selector
    self.loadIcons(p)
</t>
<t tx="tbrown.20110213091328.16235">def set_due_time(self,p=None, val=None, mode='adjust', field='duetime'):
    "mode: `adjust` for change in time, `check` for checkbox toggle"
    if p is None:
        p = self.c.currentPosition()
    v = p.v

    if field == 'duetime':
        toggle = self.ui.UI.dueTimeToggle
    else:
        toggle = self.ui.UI.nxtwkTimeToggle

    if mode == 'check':
        if toggle.checkState() == QtConst.Unchecked:
            self.setat(v, field, "")
        else:
            self.setat(v, field, val.toPyTime())
    else:
        toggle.setCheckState(QtConst.Checked)
        self.setat(v, field, val.toPyTime())
    self.loadIcons(p)

</t>
<t tx="tbrown.20110213153425.16373">def duekey(self, v, field='due'):
    """key function for sorting by due date/time"""
    # pylint: disable=boolean-datetime
    priority = self.getat(v, 'priority')
    done = priority not in self.todo_priorities
    date_ = self.getat(v, field+'date') or datetime.date(3000,1,1)
    time_ = self.getat(v, field+'time') or datetime.time(23, 59, 59)
    return done, date_, time_, priority
</t>
<t tx="tbrown.20110213153425.16377">@redrawer
def dueSort(self, p=None, field='due'):
    if p is None:
        p = self.c.currentPosition()
    self.c.selectPosition(p)
    self.c.sortSiblings(key=lambda x: self.duekey(x, field=field))
</t>
<t tx="tbrown.20110407091036.17530">class nodeTable(nodeRect):

    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)
        # can't load children here, because we don't know where we are yet
        self.updating = False

    def do_update(self):
        nodeRect.do_update(self)
        if self.updating:
            return
        what = []
        dy = self.text.document().size().height()
        for n, child in enumerate(self.node.children):
            if child not in self.owner.nodeItem:
                if '_bklnk' not in child.u:
                    child.u['_bklnk'] = {}
                if 'x' not in child.u['_bklnk']:
                    child.u['_bklnk']['x'] = self.node.u['_bklnk']['x'] + 16
                    child.u['_bklnk']['y'] = self.node.u['_bklnk']['y'] + dy * (n+1)
                child.u['_bklnk']['type'] = nodeRect.__name__
                what.append(child)

        if what:
            self.updating = True
            self.owner.loadGraph(what=what)
            self.updating = False

    def mouseMoveEvent(self, event):

        ox, oy = self.x(), self.y()

        nodeRect.mouseMoveEvent(self, event)

        dx, dy = self.x()-ox, self.y()-oy

        for n, child in enumerate(self.node.children):
            if child in self.owner.nodeItem:
                childItem = self.owner.nodeItem[child]
                childItem.setX(childItem.x()+dx)
                childItem.setY(childItem.y()+dy)
                self.owner.newPos(childItem, None)


nodeBase.node_types[nodeTable.__name__] = nodeTable
</t>
<t tx="tbrown.20110407091036.17531">class nodeBase(QtWidgets.QGraphicsItemGroup):

    node_types = {}

    @classmethod
    def make_node(cls, owner, node, ntype):
        return nodeBase.node_types[ntype](owner, node)

    def __init__(self, owner, node, *args, **kargs):

        super().__init__(*args, **kargs)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)

        self.owner = owner
        self.node = node

        self.iconHPos = 0
        self.iconVPos = 0

    def set_text_color(self, color):
        pass

    def set_bg_color(self, color):
        pass

    @others
</t>
<t tx="tbrown.20110407091036.17533">class nodeRect(nodeBase):
    """text with shape behind it node type"""

    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)

        self.text = self.text_item()
        # .text must be first for nodeComment, see its bg_item()
        self.bg = self.bg_item()
        if g.app.config.getBool("color-theme-is-dark"):
            bgcolor = QtGui.QColor(30,50,30)
        else:
            bgcolor = QtGui.QColor(200,240,200)
        self.bg.setBrush(QtGui.QBrush(bgcolor))

        self.setZValue(20)
        self.bg.setZValue(10)
        self.text.setZValue(15)
        self.bg.setPen(QtGui.QPen(QtConst.NoPen))

        self.text.setPos(QtCore.QPointF(0, self.iconVPos))
        self.addToGroup(self.text)

        self.bg.setPos(QtCore.QPointF(0, self.iconVPos))
        self.addToGroup(self.bg)

    def bg_item(self):
        """return a canvas item for the shape in the background"""
        return QtWidgets.QGraphicsRectItem(-2,+2,30,20)

    def text_item(self):
        """return a canvas item for the text in the foreground"""
        return QtWidgets.QGraphicsTextItem(self.get_text())

    def get_text(self):
        """return text content for the text in the foreground"""
        return self.node.h

    def size(self):
        return self.text.document().size()

    def set_text_color(self, color):
        self.text.setDefaultTextColor(QtGui.QColor(color))

    def set_bg_color(self, color):
        self.bg.setBrush(QtGui.QBrush(QtGui.QColor(color)))

    def do_update(self):

        self.text.setPlainText(self.get_text())

        self.bg.setRect(-2, +2,
            self.text.document().size().width()+4,
            self.text.document().size().height()-2)

nodeBase.node_types[nodeRect.__name__] = nodeRect
</t>
<t tx="tbrown.20110407091036.17535">def setNode(self, node_class):

    if not self.lastNodeItem:
        return
    node = self.node[self.lastNodeItem]
    self.unLoad()

    if '_bklnk' in node.u:
        node.u['_bklnk']['type'] = node_class.__name__

    self.loadGraph()

    self.releaseNode(self.nodeItem[node])
</t>
<t tx="tbrown.20110407091036.17536">def mouseMoveEvent(self, event):

    QtWidgets.QGraphicsItemGroup.mouseMoveEvent(self, event)
    self.owner.newPos(self, event)
</t>
<t tx="tbrown.20110407091036.17537">def mouseReleaseEvent(self, event):

    QtWidgets.QGraphicsItemGroup.mouseReleaseEvent(self, event)
    self.owner.releaseNode(self, event)
</t>
<t tx="tbrown.20110407091036.17538">def focusOutEvent(self, event):
    QtWidgets.QGraphicsItemGroup.focusOutEvent(self, event)
    self.bg.setBrush(QtGui.QBrush(QtGui.QColor(200,240,200)))
    g.es("focusOutEvent")
</t>
<t tx="tbrown.20110407091036.17539">def do_update(self):

    raise NotImplementedError
</t>
<t tx="tbrown.20110412222027.19250">class nodeEllipse(nodeRect):
    """text with shape behind it node type"""

    def bg_item(self):
        """return a canvas item for the shape in the background"""
        return QtWidgets.QGraphicsEllipseItem(-5,+5,30,20)

    def do_update(self):
        marginX = self.text.document().size().width()/2
        # marginY = self.text.document().size().height()/2
        self.bg.setRect(-marginX, 0,
            self.text.document().size().width()*2,
            self.text.document().size().height())

nodeBase.node_types[nodeEllipse.__name__] = nodeEllipse
</t>
<t tx="tbrown.20110412222027.19252">class nodeDiamond(nodeRect):
    """text with shape behind it node type"""

    def bg_item(self):
        """return a canvas item for the shape in the background"""
        bg = QtWidgets.QGraphicsPolygonItem()
        poly = QtGui.QPolygonF()
        poly.append(QtCore.QPointF(-5, 5))
        poly.append(QtCore.QPointF(15, -5))
        poly.append(QtCore.QPointF(35, 5))
        poly.append(QtCore.QPointF(15, 15))
        bg.setPolygon(poly)
        return bg

    def do_update(self):
        poly = QtGui.QPolygonF()
        marginX = self.text.document().size().width()/2
        marginY = self.text.document().size().height()/2
        poly.append(QtCore.QPointF(-marginX, marginY))
        poly.append(QtCore.QPointF(marginX, 3*marginY))
        poly.append(QtCore.QPointF(3*marginX, marginY))
        poly.append(QtCore.QPointF(marginX, -marginY))
        self.bg.setPolygon(poly)

nodeBase.node_types[nodeDiamond.__name__] = nodeDiamond
</t>
<t tx="tbrown.20110412222027.19253">class nodeComment(nodeRect):

    def get_text(self):
        """return text content for the text in the foreground"""
        return self.node.b.strip()

    def _set_text(self, what):
        text = self.get_text()
        if self.node.h.startswith('@html ') or text and text[0] == '&lt;':
            what.setHtml(text)
        else:
            what.setPlainText(text)

    def text_item(self):
        """return a canvas item for the text in the foreground"""
        item = QtWidgets.QGraphicsTextItem()

        f = item.font()
        f.setPointSize(7)
        item.setFont(f)
        self._set_text(item)

        return item

    def do_update(self):

        self._set_text(self.text)

        self.bg.setRect(-2, +2,
            self.text.document().size().width()+4,
            self.text.document().size().height()-2)

        self.setToolTip(self.node.h)

nodeBase.node_types[nodeComment.__name__] = nodeComment
</t>
<t tx="tbrown.20110413094721.20406">class nodeNone(nodeBase):
    """text with shape behind it node type"""

    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)

        self.text = self.text_item()

        self.setZValue(20)
        self.text.setZValue(15)

        self.text.setPos(QtCore.QPointF(0, self.iconVPos))
        self.addToGroup(self.text)

    def text_item(self):
        """return a canvas item for the text in the foreground"""
        return QtWidgets.QGraphicsTextItem(self.get_text())

    def get_text(self):
        """return text content for the text in the foreground"""
        return self.node.h

    def size(self):
        return self.text.document().size()

    def set_text_color(self, color):
        self.text.setDefaultTextColor(QtGui.QColor(color))

    def do_update(self):

        self.text.setPlainText(self.get_text())

nodeBase.node_types[nodeNone.__name__] = nodeNone
</t>
<t tx="tbrown.20110413094721.20407">class nodeImage(nodeBase):

    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)

        self.bg = self.bg_item()

        self.setZValue(20)
        self.bg.setZValue(10)

        self.bg.setPos(QtCore.QPointF(0, self.iconVPos))
        self.addToGroup(self.bg)

    def bg_item(self):

        img, descr = GetImage.get_image('/', self.node.h, self.node.b)

        self.setToolTip(descr)

        return img

    def size(self):
        return self.bg.pixmap().size()

    def do_update(self):
        pass

nodeBase.node_types[nodeImage.__name__] = nodeImage
</t>
<t tx="tbrown.20110914094319.18255">def to_other(self, c2, cut=False):
    """Copy/Move(cut == True) p from self.c to c2 at quickmove node,
    or top of outline.  c2 may be self.c., *OR AN UNL* - see unl_to_pos()
    """

    p = self.c.p

    p_v = p.v  # p may be invalid by the time we want to use it

    c2, nd = self.unl_to_pos(c2, p)

    if c2 is None:
        return

    p = self.c.vnode2position(p_v)  # in case nd was created in this outline,
                                    # invalidating p

    self.copy_recursively(p, nd)

    p = self.c.vnode2position(p_v)

    nxt = p.copy().visNext(self.c).v

    if cut:
        self.c.selectPosition(p)
        self.c.deleteOutline()
        self.c.setChanged()

    if nxt:
        self.c.selectPosition(self.c.vnode2position(nxt))

    c2.setChanged()
    c2.redraw()
    self.c.bringToFront(c2=self.c)
    self.c.redraw()  # must come second to keep focus
</t>
<t tx="tbrown.20110914094319.18256">@staticmethod
def copy_recursively(nd0, nd1):
    """Recursively copy subtree
    """

    nd1.h = nd0.h
    nd1.b = nd0.b
    nd1.v.u = deepcopy(nd0.v.u)

    for child in nd0.children():
        quickMove.copy_recursively(child, nd1.insertAsLastChild())
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20120104084659.21948">def bookmark_other(self, c2):
    """Bookmark p from self.c to c2 at quickmove node,
    or c.db['_leo_bookmarks_show'] or top of
    outline.  c2 may be self.c, *OR AN UNL* - see unl_to_pos()
    """

    p = self.c.p

    p_v = p.v  # p may be invalid by the time we want to use it

    if isinstance(c2, self.c.__class__):  # i.e. an outline
        if '_leo_bookmarks_show' in c2.db:
            c2 = c2.db['_leo_bookmarks_show']

    c2, nd = self.unl_to_pos(c2, p, bookmark=True)

    if c2 is None:
        return

    p = self.c.vnode2position(p_v)  # in case nd was created in this outline,
                                    # invalidating p

    in_bookmarks = False
    for i in nd.parents():
        if '@bookmarks' in i.h:
            in_bookmarks = True
            break

    if in_bookmarks:
        nd.h = p.h
    else:
        nd.h = "@url %s"%p.h

    nd.b = p.get_UNL()
    nd.v.u = dict(p.v.u)

    nxt = p.copy().visNext(self.c)
    if nxt:
        self.c.selectPosition(nxt)

    c2.redraw()
    self.c.bringToFront(c2=self.c)
    self.c.redraw()  # must come second to keep focus
</t>
<t tx="tbrown.20120619072702.22812">def add_target(self, p):
    """add the current node as a target for global operations"""

    name, ok = QtWidgets.QInputDialog.getText(None,"Target name","Target name",text=p.h)
    if not ok:
        return

    g.app.db['_quickmove']['global_targets'].append({
        'name': name,
        'unl': p.get_UNL(),
    })

    # make sure g.app.db knows it's been changed
    g.app.db['_quickmove'] = g.app.db['_quickmove']
</t>
<t tx="tbrown.20120620073922.22304">def show_targets(self):
    """Add a node with the global targets listed by name and UNL"""

    c = self.c
    c.p.contract()
    nd = c.p.insertAfter()
    nd.h = "Global QuickMove targets"
    nd.b = """
There are the current global QuickMove targets.  Use the tree context menu
Move -&gt; Read targets command to replace the stored targets with the content
of this node, after editing.

Targets are a pair of lines, starting with "NAME:" and "UNL:", with the whole
UNL on one line.\n\n"""

    for target in g.app.db['_quickmove']['global_targets']:
        nd.b += "NAME: %s\nUNL: %s\n\n" % (target['name'], target['unl'])

    c.selectPosition(nd)
    c.redraw()
</t>
<t tx="tbrown.20120620073922.28410">def read_targets(self):
    """Read the targets displayed for editing by show_targets(), and
    replace the global list"""

    c = self.c

    new = []
    name = None

    for line in c.p.b.split('\n'):

        if line.startswith('NAME: '):
            if name is not None:
                g.es("Error reading targets, two NAMEs without an UNL between them")
                return
            name = line[6:].strip()
            continue

        if line.startswith('UNL: '):
            if name is None:
                g.es("Error reading targets, UNL without preceeding NAME")
                return
            unl = line[5:].strip()
            new.append((name, unl))
            name = None
            continue

        # other lines are just ignored

    g.app.db['_quickmove']['global_targets'] = [
        {'name': name2, 'unl': unl2} for name2, unl2 in new
    ]
    # make sure g.app.db knows it's been changed
    g.app.db['_quickmove'] = g.app.db['_quickmove']

    g.es("%d targets read - you should delete this node now" % len(new))
</t>
<t tx="tbrown.20120620073922.33740">def unl_to_pos(self, c2, for_p, bookmark=False):
    """"c2 may be an outline (like c) or an UNL (string)

    return c, p where c is an outline and p is a node to copy data to
    in that outline

    for_p is the p to be copied - needed to check for invalid recursive
    copy / move
    """

    if isinstance(c2, str):
        # c2 is an UNL indicating where to insert
        full_path = c2
        path, unl = full_path.split('#', 1)
        c2 = g.openWithFileName(path, old_c=self.c)
        self.c.bringToFront(c2=self.c)
        found, maxdepth, maxp = g.recursiveUNLFind(unl.split('--&gt;'), c2)

        if found:

            if not bookmark and (for_p == maxp or for_p.isAncestorOf(maxp)):
                g.es("Invalid move")
                return None, None

            nd = maxp.insertAsNthChild(0)
        else:
            g.es("Could not find '%s'"%full_path)
            self.c.bringToFront(c2=self.c)
            return None, None
    else:
        # c2 is an outline, insert at top
        nd = c2.rootPosition().insertAfter()
        nd.copy().back().moveAfter(nd)

    return c2, nd
</t>
<t tx="tbrown.20120621072000.19675">def do_wrap(self, cb, name):
    """Call a callback and store it in the list of recent actions
    which get top level menu items"""

    while (cb, name) in self.recent_moves:
        self.recent_moves.remove((cb, name))

    self.recent_moves.insert(0, (cb, name))

    while len(self.recent_moves) &gt; 5:
        del self.recent_moves[-1]

    cb()
</t>
<t tx="tbrown.20121129095833.39490">def unl_to_pos(self, unl, for_p):
    """"unl may be an outline (like c) or an UNL (string)

    return c, p where c is an outline and p is a node to copy data to
    in that outline

    for_p is the p to be copied - needed to check for invalid recursive
    copy / move
    """

    # COPIED FROM quickMove.py

    # unl is an UNL indicating where to insert
    full_path = unl
    path, unl = full_path.split('#', 1)
    c2 = g.openWithFileName(path, old_c=self.c)
    self.c.bringToFront(c2=self.c)
    found, maxdepth, maxp = g.recursiveUNLFind(unl.split('--&gt;'), c2)

    if found:

        if (for_p == maxp or for_p.isAncestorOf(maxp)):
            g.es("Invalid move")
            return None, None

        nd = maxp
    else:
        g.es("Could not find '%s'"%full_path)
        self.c.bringToFront(c2=self.c)
        return None, None

    return c2, nd
</t>
<t tx="tbrown.20121204084515.60965">def set_date_offset(self, field='nextworkdate'):
    """set_nxtwk_date_offset - update date by selected offset

    offset sytax::

        +5 five days after today
        -5 five days before today
        &gt;5 move current date 5 days later
        &lt;5 move current date 5 days earlier

    """

    if field == 'nextworkdate':
        offset = str(self.ui.UI.nxtwkDateOffset.currentText())
    else:
        offset = str(self.ui.UI.dueDateOffset.currentText())

    mult = 1  # to handle '&lt;' as a negative relative offset

    date = QtCore.QDate.currentDate()

    if '&lt;' in offset or '&gt;' in offset:
        date = self.ui.UI.nxtwkDateEdit.date()

    if offset.startswith('&lt;'):
        mult = -1

    self.set_due_date(val=date.addDays(mult*int(offset.strip('&lt;&gt;'))), field=field)
    p = self.c.currentPosition()
    self.loadIcons(p)
</t>
<t tx="tbrown.20130207095125.20463">@redrawer
def dueClear(self, p=None):
    """clear due date on descendants, useful for creating a master todo
    item with sub items which previously had their own dates"""
    if p is None:
        p = self.c.currentPosition()
    for p in p.subtree():
        self.setat(p.v, 'duedate', '')
</t>
<t tx="tbrown.20130207103126.28498">def needs_doing(self, v=None, pri=None, due=None):
    """needs_doing - Return true if the node is a todo node that needs doing

    :Parameters:
    - `v`: vnode
    """

    if v is not None:
        pri = self.getat(v, 'priority')
        due = self.getat(v, 'duedate')

    return (pri in self.todo_priorities) or (due and pri == 9999)
</t>
<t tx="tbrown.20130316075512.28478">dump_given = False
@functools.lru_cache(maxsize=128)
def getImageFinder(self, name):
    """Theme aware image (icon) path searching."""
    trace = 'themes' in g.app.debug
    exists = g.os_path_exists
    getString = g.app.config.getString

    def dump(var, val):
        print(f"{var:20}: {val}")

    join = g.os_path_join
    #
    # "Just works" for --theme and theme .leo files *provided* that
    # theme .leo files actually contain these settings!
    #
    theme_name1 = getString('color-theme')
    theme_name2 = getString('theme-name')
    roots = [
        g.os_path_join(g.computeHomeDir(), '.leo'),
        g.computeLeoDir(),
    ]
    theme_subs = [
        "themes/{theme}/Icons",
        "themes/{theme}",
        "Icons/{theme}",
    ]
    bare_subs = ["Icons", "."]
        # "." for icons referred to as Icons/blah/blah.png
    paths = []
    for theme_name in (theme_name1, theme_name2):
        for root in roots:
            for sub in theme_subs:
                paths.append(join(root, sub.format(theme=theme_name)))
    for root in roots:
        for sub in bare_subs:
            paths.append(join(root, sub))
    table = [z for z in paths if exists(z)]
    for base_dir in table:
        path = join(base_dir, name)
        if exists(path):
            if trace: g.trace(f"Found {name} in {base_dir}")
            return path
        # if trace: g.trace(name, 'not in', base_dir)
    if trace: g.trace('not found:', name)
    return None
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20131219205216.30229">def keyboard_popup(self):
    """Assign a quick move action with the current node
    as a target, to be triggered with quickmove_keyboard_action
    """
    c = self.c
    menu = QtWidgets.QMenu(c.frame.top)

    cmds = {}

    need_submenu = 'Move', 'Copy', 'Clone', 'Bookmark', 'Link'
    current_kind = None
    current_submenu = None
    for name, first_last, long, short in quickMove.flavors:
        if first_last:
            todo = 'first child', 'last child', 'next sibling', 'prev sibling'
        else:
            todo = ['']
        for which in todo:
            if which:
                which = " "+which.title()
            k = "Set as "+long+" "+short+which+' target'
            cmds[k] = {'first': which, 'type': name}
            kind = long.split()[0]
            if kind in need_submenu:
                if current_kind != kind:
                    current_submenu = menu.addMenu(kind)
                    current_kind = kind
            else:
                current_submenu = menu
            current_submenu.addAction(k)

    pos = c.frame.top.window().frameGeometry().center()
    action = menu.exec_(pos)
    if action is None:
        return
    k = str(action.text())
    g.es(k)
    self.keyboard_target = quickMoveButton(
        self, c.p.v, cmds[k]['first'], type_=cmds[k]['type'])

def keyboard_action(self):

    self.keyboard_target.moveCurrentNodeToTarget()
</t>
<t tx="tbrown.20150605111428.1">def updateStyle(self,tag=None,k=None):
    """
    updateStyle - calling widget.setStyleSheet("/* */") is a trick to get Qt to
    update appearance on a widget styled depending on changes in attributes.
    It's faster than applying the whole stylesheet at top level or applying the
    whole stylesheet to the widget, which also breaks style cascading. But it's
    still too slow to do as the user up/down-arrows through nodes, so we just do
    it on idle instead.

    However, the idle event isn't only called when Leo is truely idle, it's just
    called at a set frequency. So by checking that time (0.2 sec) as passed
    since the need to restyle the node was noted, we avoid updating every
    idle-time seconds as the user scrolls through the outline with the arrow
    keys, which causes hiccups in scrolling speed.
    """

    if self._widget_to_style:
        # pylint: disable = unpacking-non-sequence
        # this would be neat, but hasPendingEvents() always returns True
        # (google it), so check time has passed instead
        # if QtWidgets.QApplication.instance().hasPendingEvents():
        #     return  # not truely idle
        w, old_time = self._widget_to_style
        if time.time() - old_time &gt; 0.2:
            w.setStyleSheet("/* */")
            self._widget_to_style = None
</t>
<t tx="tbrown.20150805094115.1">def select_screen(self):
    """select_screen - select which screen session to target
    """
    cmd = ['screen', '-ls']
    proc = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    out, err = proc.communicate()
    out = out.decode('utf-8')

    screens = [[('CURRENT: ' if i == self.use_screen else '')+i, False, i]
               for i in out.split('\n') if i.startswith('\t')]

    ld = ListDialog(None, 'Pick screen', 'Pick screen', screens)
    ld.exec_()

    screen = [i for i in screens if i[1]]
    if screen:
        self.use_screen = screen[0][2]
    else:
        self.use_screen = None
</t>
<t tx="tbrown.20150818161651.6">def find_setting(self, setting):
    # g.es("Settings finder: find %s" % setting)
    key = g.app.config.canonicalizeSettingName(setting)
    value = self.c.config.settingsDict.get(key)
    which = None
    while value and isinstance(value.val, str) and value.val.startswith('@'):
        msg = ("The relevant setting, '@{specific}', is using the value of "
        "a more general setting, '{general}'.  Would you like to edit the "
        "more specific setting, '@{specific}', or the more general setting, "
        "'{general}'?  The more general setting may alter appearance / "
        "behavior in more places, which may or may not be what you prefer."
        ).format(specific=setting, general=value.val)
        which = g.app.gui.runAskYesNoCancelDialog(self.c, "Which setting?",
            message=msg, yesMessage='Edit Specific', noMessage='Edit General')
        if which != 'no':
            break
        setting = value.val
        key = g.app.config.canonicalizeSettingName(setting[1:])
        value = self.c.config.settingsDict.get(key)
    if which == 'cancel' or not value:
        return
    unl = value and value.unl
    if (
        g.os_path_realpath(value.path) == g.os_path_realpath(g.os_path_join(
        g.app.loadManager.computeGlobalConfigDir(), 'leoSettings.leo')
    )):

        msg = ("The setting '@{specific}' is in the Leo global configuration "
        "file 'leoSettings.leo'\nand should be copied to "
        "'myLeoSettings.leo' before editing.\n"
        "It may make more sense to copy a group or category of settings.\nIf "
        "'myLeoSettings.leo' contains duplicate settings, the last definition "
        "is used."
        "\n\nChoice:\n"
        "1. just select the node in 'leoSettings.leo', I will decide how much\n"
        "   to copy into 'myLeoSettings.leo' (Recommended).\n"
        "2. copy the one setting, '@{specific}'\n")

        # get the settings already defined in myLeoSettings
        my_settings_c = self.c.openMyLeoSettings()
        _, settingsDict = g.app.loadManager.createSettingsDicts(my_settings_c, False)
        # find this setting's node
        path, src_unl = unl.split('#', 1)
        path = path.replace("file://", "").replace("unl://", "")
        src_unl = src_unl.replace('%20', ' ').split("--&gt;")
        c2 = g.app.loadManager.openSettingsFile(path)
        found, maxdepth, maxp = g.recursiveUNLFind(src_unl, c2)
        # scan this setting's group and category for conflicts
        up = maxp.parent()
        if up and self.no_conflict(up, settingsDict):
            msg += "3. copy the setting group, '{group}'\n"
            up = up.parent()
            if up and self.no_conflict(up, settingsDict):
                msg += "4. copy the whole setting category, '{category}'\n"

        msg = msg.format(specific=setting.lstrip('@'),
            group=unl.split('--&gt;')[-2].split(':', 1)[0].replace('%20', ' '),
            category=unl.split('--&gt;')[-3].split(':', 1)[0].replace('%20', ' '))
        which = g.app.gui.runAskOkCancelNumberDialog(
            self.c, "Copy setting?", message=msg)
        if which is None:
            return
        which = int(which)
        if which &gt; 1:
            unl = self.copy_to_my_settings(unl, which-1)
    if unl:
        g.handleUnl(unl, c=self.c)
</t>
<t tx="ville.20110115234843.8748">class pluginController:

    @others
</t>
<t tx="ville.20110115234843.8749">def __init__ (self,c):

    pass

</t>
<t tx="ville.20110219221839.6555">class pluginController:

    @others
</t>
<t tx="ville.20110219221839.6556">def __init__ (self,c):

    self.c = c

</t>
<t tx="ville.20110219221839.6557">def makeButtons(self):
    ib_w = self.c.frame.iconBar.w
    if not ib_w: return # EKR: can be None when unit testing.
    icon_l = ib_w.style().standardIcon(QtWidgets.QStyle.SP_ArrowLeft)
    icon_r = ib_w.style().standardIcon(QtWidgets.QStyle.SP_ArrowRight)
    act_l = QtWidgets.QAction(icon_l, 'prev', ib_w)
    act_r = QtWidgets.QAction(icon_r, 'next', ib_w)
    # act_l.connect(act_l, QtCore.SIGNAL("triggered()"), self.clickPrev)
    # act_r.connect(act_r, QtCore.SIGNAL("triggered()"), self.clickNext)
    act_l.triggered.connect(self.clickPrev)
    act_r.triggered.connect(self.clickNext)
    self.c.frame.iconBar.add(qaction = act_l, command = self.clickPrev)
    self.c.frame.iconBar.add(qaction = act_r, command = self.clickNext)
</t>
<t tx="ville.20110219221839.6558">def clickPrev(self):

    c = self.c
    c.goPrevVisitedNode()
</t>
<t tx="ville.20110219221839.6559">def clickNext(self):
    c = self.c
    p = c.goNextVisitedNode()
    if p: c.selectPosition(p)
</t>
<t tx="vitalije.20170708161511.1">def handleInputShortcut(self, event, stroke):
    c, k, p, u = self.c, self, self.c.p, self.c.undoer
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body.wrapper
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = u.beforeChangeNodeContents(p)
        pos = w.getYScrollPosition()
        i = len(before)
        j = max(i, len(before) + len(sel) - 1)
        w.setAllText(before + sel + after)
        w.setSelectionRange(i, j, insert=j)
        w.setYScrollPosition(pos)
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = u.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
</t>
<t tx="vitalije.20170709151653.1">_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
</t>
<t tx="vitalije.20170709151658.1">def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
</t>
<t tx="vitalije.20170709202924.1">def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
</t>
<t tx="vitalije.20170727214320.1">NUMBERINGS = {}

def renumber(c):
    if c.user_dict.get(LNOFF, False):
        nums = tuple()
    else:
        p = new_p = c.p
        for p in new_p.self_and_parents():
            if p.isAnyAtFileNode() or p.v.u.get(LNR):
                root = p
                break
        else:
            p = root = new_p
        at = c.atFileCommands
        at.scanAllDirectives(new_p)
        delim_st = at.startSentinelComment
        delim_en = at.endSentinelComment
        if (p.isAtCleanNode() or p.isAtAutoNode() or p.isAtEditNode() or p.isAtNoSentFileNode()) \
            or not p.isAnyAtFileNode():
            delim_st = ''
            delim_en = ''
        nums = universal_line_numbers(root, new_p, delim_st, delim_en)
        NUMBERINGS[c.hash() + new_p.gnx] = nums
    if c.user_dict.get(LNT) != nums:
        c.user_dict[LNT] = nums
        with number_bar_widget(c) as w:
            w.highest_line = nums[-1] if nums else 10
            w.update()
    finish_update(c)
</t>
<t tx="vitalije.20200329153148.1">def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
</t>
<t tx="vitalije.20200329153154.1">def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
</t>
</tnodes>
</leo_file>
